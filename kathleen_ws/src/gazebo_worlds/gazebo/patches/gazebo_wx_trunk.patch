Index: src/gazeboros.cpp
===================================================================
--- src/gazeboros.cpp	(revision 34477)
+++ src/gazeboros.cpp	(working copy)
@@ -37,6 +37,8 @@
 
 #include "gazebo/gazebo.h"
 #include "gazebo/Simulator.hh"
+#include "gazebo/Common.hh"
+#include "gazebo/Events.hh"
 #include "gazebo/GazeboConfig.hh"
 #include "gazebo/GazeboError.hh"
 #include "gazebo/Global.hh"
@@ -255,9 +257,9 @@
       this->AdvertiseServices();
 
       // connect helper function to signal for scheduling torque/forces, etc
-      gazebo::World::Instance()->ConnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::wrenchBodySchedulerSlot,this));
-      gazebo::World::Instance()->ConnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::forceJointSchedulerSlot,this));
-      gazebo::World::Instance()->ConnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishSimTime,this));
+      gazebo::Events::ConnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::wrenchBodySchedulerSlot,this));
+      gazebo::Events::ConnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::forceJointSchedulerSlot,this));
+      gazebo::Events::ConnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishSimTime,this));
 
       // for internal gazebo xml use
       this->xmlPrefix_ = std::string("<?xml version='1.0'?> <gazebo:world xmlns:xi='http://www.w3.org/2001/XInclude' xmlns:gazebo='http://playerstage.sourceforge.net/gazebo/xmlschema/#gz' xmlns:model='http://playerstage.sourceforge.net/gazebo/xmlschema/#model' xmlns:sensor='http://playerstage.sourceforge.net/gazebo/xmlschema/#sensor' xmlns:body='http://playerstage.sourceforge.net/gazebo/xmlschema/#body' xmlns:geom='http://playerstage.sourceforge.net/gazebo/xmlschema/#geom' xmlns:joint='http://playerstage.sourceforge.net/gazebo/xmlschema/#joint' xmlns:interface='http://playerstage.sourceforge.net/gazebo/xmlschema/#interface' xmlns:rendering='http://playerstage.sourceforge.net/gazebo/xmlschema/#rendering' xmlns:renderable='http://playerstage.sourceforge.net/gazebo/xmlschema/#renderable' xmlns:controller='http://playerstage.sourceforge.net/gazebo/xmlschema/#controller' xmlns:physics='http://playerstage.sourceforge.net/gazebo/xmlschema/#physics' >");
@@ -270,13 +272,13 @@
     ~GazeboROSNode()
     {
       // disconnect slots
-      gazebo::World::Instance()->DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::wrenchBodySchedulerSlot,this));
-      gazebo::World::Instance()->DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::forceJointSchedulerSlot,this));
-      gazebo::World::Instance()->DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishSimTime,this));
+      gazebo::Events::DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::wrenchBodySchedulerSlot,this));
+      gazebo::Events::DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::forceJointSchedulerSlot,this));
+      gazebo::Events::DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishSimTime,this));
       if (this->pub_link_states_connection_count_ > 0) // disconnect if there are subscribers on exit
-        gazebo::World::Instance()->DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishLinkStates,this));
+        gazebo::Events::DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishLinkStates,this));
       if (this->pub_model_states_connection_count_ > 0) // disconnect if there are subscribers on exit
-        gazebo::World::Instance()->DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishModelStates,this));
+        gazebo::Events::DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishModelStates,this));
 
       // shutdown ros
       this->rosnode_.shutdown();
@@ -512,19 +514,19 @@
     {
       this->pub_link_states_connection_count_++;
       if (this->pub_link_states_connection_count_ == 1) // connect on first subscriber
-        gazebo::World::Instance()->ConnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishLinkStates,this));
+        gazebo::Events::ConnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishLinkStates,this));
     }
     void onModelStatesConnect()
     {
       this->pub_model_states_connection_count_++;
       if (this->pub_model_states_connection_count_ == 1) // connect on first subscriber
-        gazebo::World::Instance()->ConnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishModelStates,this));
+        gazebo::Events::ConnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishModelStates,this));
     }
     void onLinkStatesDisconnect()
     {
       this->pub_link_states_connection_count_--;
       if (this->pub_link_states_connection_count_ == 0) // disconnect with no subscribers
-        gazebo::World::Instance()->DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishLinkStates,this));
+        gazebo::Events::DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishLinkStates,this));
       else if (this->pub_link_states_connection_count_ < 0) // should not be possible
         ROS_ERROR("one too mandy disconnect from pub_link_states_ in gazeboros.cpp? something weird");
     }
@@ -532,7 +534,7 @@
     {
       this->pub_model_states_connection_count_--;
       if (this->pub_model_states_connection_count_ == 0) // disconnect with no subscribers
-        gazebo::World::Instance()->DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishModelStates,this));
+        gazebo::Events::DisconnectWorldUpdateStartSignal(boost::bind(&GazeboROSNode::publishModelStates,this));
       else if (this->pub_model_states_connection_count_ < 0) // should not be possible
         ROS_ERROR("one too mandy disconnect from pub_model_states_ in gazeboros.cpp? something weird");
     }
@@ -591,7 +593,7 @@
     {
       // check to see if model name already exist as a model
       std::string model_name = req.model_name;
-      if (gazebo::World::Instance()->GetEntityByName(model_name))
+      if (gazebo::Common::GetByName(model_name))
       {
         ROS_ERROR("SpawnModel: Failure - model name %s already exist.",model_name.c_str());
         res.success = false;
@@ -608,7 +610,7 @@
       gazebo::Quatern initial_q(req.initial_pose.orientation.w,req.initial_pose.orientation.x,req.initial_pose.orientation.y,req.initial_pose.orientation.z);
 
       // refernce frame for initial pose definition, modify initial pose if defined
-      gazebo::Body* frame = dynamic_cast<gazebo::Body*>(gazebo::World::Instance()->GetEntityByName(req.reference_frame));
+      gazebo::Body* frame = dynamic_cast<gazebo::Body*>(gazebo::Common::GetByName(req.reference_frame));
       if (frame)
       {
         // convert to relative pose
@@ -737,7 +739,7 @@
         }
         {
           boost::recursive_mutex::scoped_lock lock(*gazebo::Simulator::Instance()->GetMRMutex());
-          if (gazebo::World::Instance()->GetEntityByName(model_name)) break;
+          if (gazebo::Common::GetByName(model_name)) break;
         }
         ROS_DEBUG("Waiting for spawning model (%s)",model_name.c_str());
         usleep(1000);
@@ -756,7 +758,7 @@
     {
       // clear forces, etc for the body in question
 
-      gazebo::Model* model = dynamic_cast<gazebo::Model*>(gazebo::World::Instance()->GetEntityByName(req.model_name));
+      gazebo::Model* model = dynamic_cast<gazebo::Model*>(gazebo::Common::GetByName(req.model_name));
       if (!model)
       {
         ROS_ERROR("DeleteModel: model [%s] does not exist",req.model_name.c_str());
@@ -766,10 +768,10 @@
       }
 
       // delete wrench jobs on bodies
-      const std::vector<gazebo::Entity*> children = model->GetChildren();
-      for (std::vector<gazebo::Entity*>::const_iterator iter=children.begin();iter!=children.end();iter++)
+      for (unsigned int i = 0; i < model->GetChildCount(); i++)
       {
-        gazebo::Body* body = (gazebo::Body*)(*iter);
+        gazebo::Entity* entity = dynamic_cast<gazebo::Entity*>(model->GetChild(i));
+        gazebo::Body* body = (gazebo::Body*)(entity);
         if (body)
         {
           // look for it in jobs, delete body wrench jobs
@@ -785,7 +787,7 @@
       }
 
       // delete model
-      gazebo::World::Instance()->DeleteEntity(req.model_name);
+      gazebo::Events::deleteEntitySignal(req.model_name);
 
       ros::Duration model_spawn_timeout(60.0);
       ros::Time timeout = ros::Time::now() + model_spawn_timeout;
@@ -800,7 +802,7 @@
         }
         {
           boost::recursive_mutex::scoped_lock lock(*gazebo::Simulator::Instance()->GetMRMutex());
-          if (!gazebo::World::Instance()->GetEntityByName(req.model_name)) break;
+          if (!gazebo::Common::GetByName(req.model_name)) break;
         }
         ROS_DEBUG("Waiting for model deletion (%s)",req.model_name.c_str());
         usleep(1000);
@@ -816,8 +818,8 @@
     /// \brief 
     bool getModelState(gazebo::GetModelState::Request &req,gazebo::GetModelState::Response &res)
     {
-      gazebo::Model* model = dynamic_cast<gazebo::Model*>(gazebo::World::Instance()->GetEntityByName(req.model_name));
-      gazebo::Body* frame = dynamic_cast<gazebo::Body*>(gazebo::World::Instance()->GetEntityByName(req.relative_entity_name));
+      gazebo::Model* model = dynamic_cast<gazebo::Model*>(gazebo::Common::GetByName(req.model_name));
+      gazebo::Body* frame = dynamic_cast<gazebo::Body*>(gazebo::Common::GetByName(req.relative_entity_name));
       if (!model)
       {
         ROS_ERROR("GetModelState: model [%s] does not exist",req.model_name.c_str());
@@ -889,7 +891,7 @@
     /// \brief 
     bool getModelProperties(gazebo::GetModelProperties::Request &req,gazebo::GetModelProperties::Response &res)
     {
-      gazebo::Model* model = dynamic_cast<gazebo::Model*>(gazebo::World::Instance()->GetEntityByName(req.model_name));
+      gazebo::Model* model = dynamic_cast<gazebo::Model*>(gazebo::Common::GetByName(req.model_name));
       if (!model)
       {
         ROS_ERROR("GetModelProperties: model [%s] does not exist",req.model_name.c_str());
@@ -900,16 +902,16 @@
       else
       {
         // get model parent name
-        gazebo::Entity* parent_model = model->GetParent();
+        gazebo::Entity* parent_model = dynamic_cast<gazebo::Entity*>(model->GetParent());
         if (parent_model) res.parent_model_name = parent_model->GetName();
 
         // get list of child bodies, geoms
         res.body_names.clear();
         res.geom_names.clear();
-        const std::vector< gazebo::Entity* > entities = model->GetChildren();
-        for (std::vector< gazebo::Entity* >::const_iterator eiter = entities.begin();eiter!=entities.end();eiter++)
+        for (unsigned int i = 0; i < model->GetChildCount(); i++)
         {
-          gazebo::Body* body = dynamic_cast<gazebo::Body*>(*eiter);
+          gazebo::Entity* entity = dynamic_cast<gazebo::Entity*>(model->GetChild(i));
+          gazebo::Body* body = dynamic_cast<gazebo::Body*>(entity);
           if (body)
           {
             res.body_names.push_back(body->GetName());
@@ -928,9 +930,8 @@
 
         // get children model names
         res.child_model_names.clear();
-        const std::vector< gazebo::Entity* > children = model->GetChildren();
-        for (std::vector< gazebo::Entity* >::const_iterator citer = children.begin(); citer != children.end();  citer++)
-          res.child_model_names.push_back((*citer)->GetName() );
+        for (unsigned int i = 0; i < model->GetChildCount(); i++)
+          res.child_model_names.push_back(model->GetChild(i)->GetName() );
 
         // is model static
         res.is_static = model->IsStatic();
@@ -947,9 +948,8 @@
     {
       res.sim_time = gazebo::Simulator::Instance()->GetSimTime().Double();
       res.model_names.clear();
-      const std::vector<gazebo::Model*> models = gazebo::World::Instance()->GetModels();
-      for (std::vector<gazebo::Model*>::const_iterator miter = models.begin(); miter != models.end(); miter++)
-        res.model_names.push_back((*miter)->GetName());
+      for (unsigned int i = 0; i < gazebo::World::Instance()->GetModelCount(); i++)
+        res.model_names.push_back(gazebo::World::Instance()->GetModel(i)->GetName());
       res.rendering_enabled = gazebo::Simulator::Instance()->GetRenderEngineEnabled();
       res.success = true;
       res.status_message = "GetWorldProperties: got properties";
@@ -962,10 +962,9 @@
     bool getJointProperties(gazebo::GetJointProperties::Request &req,gazebo::GetJointProperties::Response &res)
     {
       gazebo::Joint* joint = NULL;
-      const std::vector<gazebo::Model*> models = gazebo::World::Instance()->GetModels();
-      for (std::vector<gazebo::Model*>::const_iterator miter = models.begin(); miter != models.end(); miter++)
+      for (unsigned int i = 0; i < gazebo::World::Instance()->GetModelCount(); i++)
       {
-        joint = (*miter)->GetJoint(req.joint_name);
+        joint = gazebo::World::Instance()->GetModel(i)->GetJoint(req.joint_name);
         if (joint) break;
       }
 
@@ -999,7 +998,7 @@
     /// \brief 
     bool getLinkProperties(gazebo::GetLinkProperties::Request &req,gazebo::GetLinkProperties::Response &res)
     {
-      gazebo::Body* body = dynamic_cast<gazebo::Body*>(gazebo::World::Instance()->GetEntityByName(req.link_name));
+      gazebo::Body* body = dynamic_cast<gazebo::Body*>(gazebo::Common::GetByName(req.link_name));
       if (body == NULL)
       {
         res.success = false;
@@ -1042,8 +1041,8 @@
     /// \brief 
     bool getLinkState(gazebo::GetLinkState::Request &req,gazebo::GetLinkState::Response &res)
     {
-      gazebo::Body* body = dynamic_cast<gazebo::Body*>(gazebo::World::Instance()->GetEntityByName(req.link_name));
-      gazebo::Body* frame = dynamic_cast<gazebo::Body*>(gazebo::World::Instance()->GetEntityByName(req.reference_frame));
+      gazebo::Body* body = dynamic_cast<gazebo::Body*>(gazebo::Common::GetByName(req.link_name));
+      gazebo::Body* frame = dynamic_cast<gazebo::Body*>(gazebo::Common::GetByName(req.reference_frame));
       if (body == NULL)
       {
         res.success = false;
@@ -1108,7 +1107,7 @@
     /// \brief 
     bool setLinkProperties(gazebo::SetLinkProperties::Request &req,gazebo::SetLinkProperties::Response &res)
     {
-      gazebo::Body* body = dynamic_cast<gazebo::Body*>(gazebo::World::Instance()->GetEntityByName(req.link_name));
+      gazebo::Body* body = dynamic_cast<gazebo::Body*>(gazebo::Common::GetByName(req.link_name));
       if (body == NULL)
       {
         res.success = false;
@@ -1196,10 +1195,9 @@
       /// @todo: FIXME: current settings only allows for setting of 1DOF joints (e.g. HingeJoint and SliderJoint) correctly.
       //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
       gazebo::Joint* joint = NULL;
-      const std::vector<gazebo::Model*> models = gazebo::World::Instance()->GetModels();
-      for (std::vector<gazebo::Model*>::const_iterator miter = models.begin(); miter != models.end(); miter++)
+      for (unsigned int i = 0; i < gazebo::World::Instance()->GetModelCount(); i++)
       {
-        joint = (*miter)->GetJoint(req.joint_name);
+        joint = gazebo::World::Instance()->GetModel(i)->GetJoint(req.joint_name);
         if (joint) break;
       }
 
@@ -1248,7 +1246,7 @@
       gazebo::Vector3 target_pos_dot(req.model_state.twist.linear.x,req.model_state.twist.linear.y,req.model_state.twist.linear.z);
       gazebo::Vector3 target_rot_dot(req.model_state.twist.angular.x,req.model_state.twist.angular.y,req.model_state.twist.angular.z);
 
-      gazebo::Model* model = dynamic_cast<gazebo::Model*>(gazebo::World::Instance()->GetEntityByName(req.model_state.model_name));
+      gazebo::Model* model = dynamic_cast<gazebo::Model*>(gazebo::Common::GetByName(req.model_state.model_name));
       if (!model)
       {
         ROS_ERROR("SetModelState: model [%s] does not exist",req.model_state.model_name.c_str());
@@ -1258,7 +1256,7 @@
       }
       else
       {
-        gazebo::Entity* relative_entity = gazebo::World::Instance()->GetEntityByName(req.model_state.reference_frame);
+        gazebo::Entity* relative_entity = dynamic_cast<gazebo::Entity*>(gazebo::Common::GetByName(req.model_state.reference_frame));
         if (relative_entity)
         {
           gazebo::Pose3d  frame_pose = relative_entity->GetWorldPose(); // - this->myBody->GetCoMPose();
@@ -1312,7 +1310,7 @@
       gazebo::Vector3 target_pos_dot(model_state->twist.linear.x,model_state->twist.linear.y,model_state->twist.linear.z);
       gazebo::Vector3 target_rot_dot(model_state->twist.angular.x,model_state->twist.angular.y,model_state->twist.angular.z);
 
-      gazebo::Model* model = dynamic_cast<gazebo::Model*>(gazebo::World::Instance()->GetEntityByName(model_state->model_name));
+      gazebo::Model* model = dynamic_cast<gazebo::Model*>(gazebo::Common::GetByName(model_state->model_name));
       if (!model)
       {
         ROS_ERROR("updateModelState: model [%s] does not exist",model_state->model_name.c_str());
@@ -1322,7 +1320,7 @@
       {
         gazebo::Entity* relative_entity = NULL;
 
-        relative_entity = gazebo::World::Instance()->GetEntityByName(model_state->reference_frame);
+        relative_entity = dynamic_cast<gazebo::Entity*>(gazebo::Common::GetByName(model_state->reference_frame));
         if (relative_entity)
         {
           gazebo::Pose3d  frame_pose = relative_entity->GetWorldPose(); // - this->myBody->GetCoMPose();
@@ -1363,10 +1361,9 @@
     bool applyJointEffort(gazebo::ApplyJointEffort::Request &req,gazebo::ApplyJointEffort::Response &res)
     {
       gazebo::Joint* joint = NULL;
-      const std::vector<gazebo::Model*> models = gazebo::World::Instance()->GetModels();
-      for (std::vector<gazebo::Model*>::const_iterator miter = models.begin(); miter != models.end(); miter++)
+      for (unsigned int i = 0; i < gazebo::World::Instance()->GetModelCount(); i++)
       {
-        joint = (*miter)->GetJoint(req.joint_name);
+        joint = gazebo::World::Instance()->GetModel(i)->GetJoint(req.joint_name);
         if (joint) break;
       }
 
@@ -1487,7 +1484,7 @@
       std::string urdf_param_name = req.test_urdf_param_name; // remove test_ prefix if possible or remove this option
 
       // search for model with name
-      gazebo::Model* gazebo_model = dynamic_cast<gazebo::Model*>(gazebo::World::Instance()->GetEntityByName(gazebo_model_name));
+      gazebo::Model* gazebo_model = dynamic_cast<gazebo::Model*>(gazebo::Common::GetByName(gazebo_model_name));
       if (gazebo_model == NULL)
       {
         ROS_ERROR("SetModelConfiguration: model [%s] does not exist",gazebo_model_name.c_str());
@@ -1569,8 +1566,8 @@
     /// \brief 
     bool setLinkState(gazebo::SetLinkState::Request &req,gazebo::SetLinkState::Response &res)
     {
-      gazebo::Body* body = dynamic_cast<gazebo::Body*>(gazebo::World::Instance()->GetEntityByName(req.link_state.link_name));
-      gazebo::Body* frame = dynamic_cast<gazebo::Body*>(gazebo::World::Instance()->GetEntityByName(req.link_state.reference_frame));
+      gazebo::Body* body = dynamic_cast<gazebo::Body*>(gazebo::Common::GetByName(req.link_state.link_name));
+      gazebo::Body* frame = dynamic_cast<gazebo::Body*>(gazebo::Common::GetByName(req.link_state.reference_frame));
       if (!body)
       {
         ROS_ERROR("SetLinkState: link [%s] does not exist",req.link_state.link_name.c_str());
@@ -1637,8 +1634,8 @@
     /// \brief 
     void updateLinkState(const gazebo::LinkState::ConstPtr& link_state)
     {
-      gazebo::Body* body = dynamic_cast<gazebo::Body*>(gazebo::World::Instance()->GetEntityByName(link_state->link_name));
-      gazebo::Body* frame = dynamic_cast<gazebo::Body*>(gazebo::World::Instance()->GetEntityByName(link_state->reference_frame));
+      gazebo::Body* body = dynamic_cast<gazebo::Body*>(gazebo::Common::GetByName(link_state->link_name));
+      gazebo::Body* frame = dynamic_cast<gazebo::Body*>(gazebo::Common::GetByName(link_state->reference_frame));
       if (!body)
       {
         ROS_ERROR("SetLinkState: link [%s] does not exist",link_state->link_name.c_str());
@@ -1702,8 +1699,8 @@
     /// \brief 
     bool applyBodyWrench(gazebo::ApplyBodyWrench::Request &req,gazebo::ApplyBodyWrench::Response &res)
     {
-      gazebo::Body* body = dynamic_cast<gazebo::Body*>(gazebo::World::Instance()->GetEntityByName(req.body_name));
-      gazebo::Body* frame = dynamic_cast<gazebo::Body*>(gazebo::World::Instance()->GetEntityByName(req.reference_frame));
+      gazebo::Body* body = dynamic_cast<gazebo::Body*>(gazebo::Common::GetByName(req.body_name));
+      gazebo::Body* frame = dynamic_cast<gazebo::Body*>(gazebo::Common::GetByName(req.reference_frame));
 
       ROS_WARN("ApplyBodyWrench: reference frame and reference_point not implemented yet, force is defined and applied at the body frame");
 
@@ -1968,11 +1965,11 @@
     gazebo::Joint* getJointByName(std::string joint_name)
     {
       // look through all models in the world, search for body name that matches frameName
-      std::vector<gazebo::Model*> all_models = gazebo::World::Instance()->GetModels();
-      for (std::vector<gazebo::Model*>::iterator miter = all_models.begin(); miter != all_models.end(); miter++)
+      for (unsigned int i = 0; i < gazebo::World::Instance()->GetModelCount(); i++)
       {
-        if ((*miter) && (*miter)->GetJoint(joint_name))
-          return (*miter)->GetJoint(joint_name);
+        gazebo::Model* model = gazebo::World::Instance()->GetModel(i);
+        if (model && model->GetJoint(joint_name))
+          return model->GetJoint(joint_name);
       }
       return NULL;
     }
@@ -2089,13 +2086,13 @@
     {
       gazebo::LinkStates link_states;
       // fill link_states
-      const std::vector<gazebo::Model*> models = gazebo::World::Instance()->GetModels();
-      for (std::vector<gazebo::Model*>::const_iterator miter = models.begin(); miter != models.end(); miter++)
+      for (unsigned int i = 0; i < gazebo::World::Instance()->GetModelCount(); i++)
       {
-        const std::vector< gazebo::Entity* > entities = (*miter)->GetChildren();
-        for (std::vector< gazebo::Entity* >::const_iterator eiter = entities.begin();eiter!=entities.end();eiter++)
+        gazebo::Model* model = gazebo::World::Instance()->GetModel(i);
+        for (unsigned int i = 0; i < model->GetChildCount(); i++)
         {
-          gazebo::Body* body = dynamic_cast<gazebo::Body*>(*eiter);
+          gazebo::Entity* entity = dynamic_cast<gazebo::Entity*>(model->GetChild(i));
+          gazebo::Body* body = dynamic_cast<gazebo::Body*>(entity);
           if (body)
           {
             link_states.name.push_back(body->GetName());
@@ -2133,12 +2130,12 @@
     {
       gazebo::ModelStates model_states;
       // fill model_states
-      const std::vector<gazebo::Model*> models = gazebo::World::Instance()->GetModels();
-      for (std::vector<gazebo::Model*>::const_iterator miter = models.begin(); miter != models.end(); miter++)
+      for (unsigned int i = 0; i < gazebo::World::Instance()->GetModelCount(); i++)
       {
-        model_states.name.push_back((*miter)->GetName());
+        gazebo::Model* model = gazebo::World::Instance()->GetModel(i);
+        model_states.name.push_back(model->GetName());
         geometry_msgs::Pose pose;
-        gazebo::Pose3d  model_pose = (*miter)->GetWorldPose(); // - this->myBody->GetCoMPose();
+        gazebo::Pose3d  model_pose = model->GetWorldPose(); // - this->myBody->GetCoMPose();
         gazebo::Vector3 pos = model_pose.pos;
         gazebo::Quatern rot = model_pose.rot;
         pose.position.x = pos.x;
@@ -2149,8 +2146,8 @@
         pose.orientation.y = rot.y;
         pose.orientation.z = rot.z;
         model_states.pose.push_back(pose);
-        gazebo::Vector3 linear_vel  = (*miter)->GetWorldLinearVel();
-        gazebo::Vector3 angular_vel = (*miter)->GetWorldAngularVel();
+        gazebo::Vector3 linear_vel  = model->GetWorldLinearVel();
+        gazebo::Vector3 angular_vel = model->GetWorldAngularVel();
         geometry_msgs::Twist twist;
         twist.linear.x = linear_vel.x;
         twist.linear.y = linear_vel.y;
@@ -2276,7 +2273,7 @@
   // Main loop of the simulator
   try
   {
-    gazebo::Simulator::Instance()->MainLoop();
+    gazebo::Simulator::Instance()->Run();
   }
   catch (gazebo::GazeboError e)
   {
Index: manifest.xml
===================================================================
--- manifest.xml	(revision 34477)
+++ manifest.xml	(working copy)
@@ -15,14 +15,12 @@
   <license>LGPL</license>
   <review status="simulator_gazebo" notes=""/>
   <depend package="ogre" />
-
-  <!-- uncomment for cuda for parallel_quickstep
+  <!-- uncomment for cuda for parallel_quickstep -->
   <depend package="parallel_quickstep" />
-  -->
 
   <url>http://playerstage.sf.net</url>
   <export>
-    <cpp lflags="`xml2-config --libs` `rosboost-cfg --lflags thread,signals` -Wl,-rpath,${prefix}/gazebo/lib -L${prefix}/gazebo/lib -lgazebo -lgazebo_server -lgazebo_av -lgazebo_gui -lgazebo_physics -lgazebo_rendering -lgazebo_physics_ode -lgazebo_physics_bullet `fltk-config --use-gl --ldflags` -lfreeimage" cflags="`xml2-config --cflags` `rosboost-cfg --cflags` -I${prefix}/gazebo/include"/>
+    <cpp lflags="`xml2-config --libs` `rosboost-cfg --lflags thread,signals` -Wl,-rpath,${prefix}/gazebo/lib -L${prefix}/gazebo/lib -lgazebo -lgazebo_server -lgazebo_av -lgazebo_wx -lgazebo_physics -lgazebo_rendering -lgazebo_physics_ode -lgazebo_physics_bullet -ltbb `fltk-config --use-gl --ldflags` -lfreeimage" cflags="`xml2-config --cflags` `rosboost-cfg --cflags` -I${prefix}/gazebo/include"/>
     <doxymaker external="http://playerstage.sourceforge.net/doc/Gazebo-manual-svn-html/"/>
     <gazebo gazebo_media_path="${prefix}/gazebo/share/gazebo" />
   </export>
Index: gazebo_wx_trunk.patch
===================================================================
--- gazebo_wx_trunk.patch	(revision 34477)
+++ gazebo_wx_trunk.patch	(working copy)
@@ -1,6 +1,6 @@
 Index: src/gazeboros.cpp
 ===================================================================
---- src/gazeboros.cpp	(revision 34467)
+--- src/gazeboros.cpp	(revision 34477)
 +++ src/gazeboros.cpp	(working copy)
 @@ -37,6 +37,8 @@
  
@@ -428,12 +428,13 @@
    {
 Index: manifest.xml
 ===================================================================
---- manifest.xml	(revision 34467)
+--- manifest.xml	(revision 34477)
 +++ manifest.xml	(working copy)
-@@ -16,13 +16,12 @@
+@@ -15,14 +15,12 @@
+   <license>LGPL</license>
    <review status="simulator_gazebo" notes=""/>
    <depend package="ogre" />
- 
+-
 -  <!-- uncomment for cuda for parallel_quickstep
 +  <!-- uncomment for cuda for parallel_quickstep -->
    <depend package="parallel_quickstep" />
@@ -446,39 +447,3 @@
      <doxymaker external="http://playerstage.sourceforge.net/doc/Gazebo-manual-svn-html/"/>
      <gazebo gazebo_media_path="${prefix}/gazebo/share/gazebo" />
    </export>
-Index: CMakeLists.txt
-===================================================================
---- CMakeLists.txt	(revision 34467)
-+++ CMakeLists.txt	(working copy)
-@@ -10,14 +10,14 @@
- rosbuild_add_boost_directories()
- 
- # Build Gazebo
--execute_process(COMMAND cmake -E chdir ${PROJECT_SOURCE_DIR} make -f Makefile.gazebo.tarball
-+execute_process(COMMAND cmake -E chdir ${PROJECT_SOURCE_DIR} make -f Makefile.gazebo.svn
-                 RESULT_VARIABLE _make_failed)
- if(_make_failed)
-   message(FATAL_ERROR "Build of Gazebo failed")
- endif(_make_failed)
- 
--#set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES gazebo-svn)
--set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES build/gazebo-r8967)
-+set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES gazebo-svn)
-+#set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES build/gazebo-r8967)
- 
- # Find the build flags for Gazebo server
- #set(ENV{PKG_CONFIG_PATH} "${PROJECT_SOURCE_DIR}/gazebo/lib/pkgconfig:$ENV{PKG_CONFIG_PATH}")
-@@ -35,11 +35,11 @@
- add_dependencies(bin/gazebo build_gazebo urdf2gazebo)
- rosbuild_add_compile_flags(bin/gazebo ${GAZEBO_CFLAGS_OTHERS} ${GAZEBO_CFLAGS})
- target_link_libraries(bin/gazebo ${GAZEBO_LIBRARIES} urdf2gazebo)
--rosbuild_add_link_flags(bin/gazebo ${GAZEBO_LDFLAGS_OTHERS} ${GAZEBO_LDFLAGS})
-+rosbuild_add_link_flags(bin/gazebo -lglut -ltbb ${GAZEBO_LDFLAGS_OTHERS} ${GAZEBO_LDFLAGS})
- 
- 
- # extra utility for setting complex model pose
- rosbuild_add_executable(bin/set_model_pose src/set_model_pose.cpp)
- rosbuild_add_compile_flags(bin/set_model_pose ${GAZEBO_CFLAGS_OTHERS} ${GAZEBO_CFLAGS})
- target_link_libraries(bin/set_model_pose ${GAZEBO_LIBRARIES})
--rosbuild_add_link_flags(bin/set_model_pose ${GAZEBO_LDFLAGS_OTHERS} ${GAZEBO_LDFLAGS})
-+rosbuild_add_link_flags(bin/set_model_pose -lglut -ltbb ${GAZEBO_LDFLAGS_OTHERS} ${GAZEBO_LDFLAGS})
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 34477)
+++ CMakeLists.txt	(working copy)
@@ -1,7 +1,7 @@
 cmake_minimum_required(VERSION 2.4.6)
 include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)
 include(FindPkgConfig)
-set(ROS_BUILD_TYPE RelWithDeb)
+set(ROS_BUILD_TYPE Debug)
 rosbuild_init()
 
 rosbuild_genmsg()
@@ -10,14 +10,14 @@
 rosbuild_add_boost_directories()
 
 # Build Gazebo
-execute_process(COMMAND cmake -E chdir ${PROJECT_SOURCE_DIR} make -f Makefile.gazebo.tarball
+execute_process(COMMAND cmake -E chdir ${PROJECT_SOURCE_DIR} make -f Makefile.gazebo.svn
                 RESULT_VARIABLE _make_failed)
 if(_make_failed)
   message(FATAL_ERROR "Build of Gazebo failed")
 endif(_make_failed)
 
-#set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES gazebo-svn)
-set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES build/gazebo-r8967)
+set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES gazebo-svn)
+#set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES build/gazebo-r8967)
 
 # Find the build flags for Gazebo server
 #set(ENV{PKG_CONFIG_PATH} "${PROJECT_SOURCE_DIR}/gazebo/lib/pkgconfig:$ENV{PKG_CONFIG_PATH}")
@@ -35,11 +35,11 @@
 add_dependencies(bin/gazebo build_gazebo urdf2gazebo)
 rosbuild_add_compile_flags(bin/gazebo ${GAZEBO_CFLAGS_OTHERS} ${GAZEBO_CFLAGS})
 target_link_libraries(bin/gazebo ${GAZEBO_LIBRARIES} urdf2gazebo)
-rosbuild_add_link_flags(bin/gazebo ${GAZEBO_LDFLAGS_OTHERS} ${GAZEBO_LDFLAGS})
+rosbuild_add_link_flags(bin/gazebo -lglut -ltbb ${GAZEBO_LDFLAGS_OTHERS} ${GAZEBO_LDFLAGS})
 
 
 # extra utility for setting complex model pose
 rosbuild_add_executable(bin/set_model_pose src/set_model_pose.cpp)
 rosbuild_add_compile_flags(bin/set_model_pose ${GAZEBO_CFLAGS_OTHERS} ${GAZEBO_CFLAGS})
 target_link_libraries(bin/set_model_pose ${GAZEBO_LIBRARIES})
-rosbuild_add_link_flags(bin/set_model_pose ${GAZEBO_LDFLAGS_OTHERS} ${GAZEBO_LDFLAGS})
+rosbuild_add_link_flags(bin/set_model_pose -lglut -ltbb ${GAZEBO_LDFLAGS_OTHERS} ${GAZEBO_LDFLAGS})
