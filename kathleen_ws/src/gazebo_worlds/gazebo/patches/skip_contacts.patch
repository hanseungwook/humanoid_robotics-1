diff -r 45cf796cb43b server/physics/ode/ODEPhysics.cc
--- a/server/physics/ode/ODEPhysics.cc	Fri Apr 15 18:36:27 2011 -0700
+++ b/server/physics/ode/ODEPhysics.cc	Thu Apr 21 15:37:51 2011 -0700
@@ -225,6 +225,7 @@
   dWorldSetAutoDisableSteps(this->worldId, 50);
 
   this->contactGeoms.resize(**this->defaultMaxContactsP);
+  this->contactGeomsSkipped.resize(**this->defaultMaxContactsP);
   this->contactFeedbacks.resize(this->contactFeedbacksP->GetValue());
 
   // Reset the contact pointer
@@ -617,6 +618,7 @@
   // @todo: FIXME: resizes contactGeoms, but can we do this on the fly?
   //               this might need to be done on a new time step
   this->contactGeoms.resize(**this->defaultMaxContactsP);
+  this->contactGeomsSkipped.resize(**this->defaultMaxContactsP);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -802,9 +804,9 @@
     // if dCollide is not threaded out in parallel, this is ok, otherwise
     //   create local contactGeoms buffer for each CallBack instance
     self->contactGeoms.resize(max_contacts);
+    self->contactGeomsSkipped.resize(max_contacts);
 
-    int num_contacts = dCollide(o1,o2,max_contacts, &self->contactGeoms[0],
-                                sizeof(self->contactGeoms[0]));
+    int num_contacts = dCollide(o1,o2,max_contacts, &self->contactGeoms[0], sizeof(self->contactGeoms[0]));
 
     if (num_contacts != 0)
     {
@@ -814,12 +816,54 @@
       (*self->contactFeedbackIter).feedbacks.resize(num_contacts);
 
       double h, kp, kd;
+      bool contact_created = false;
       for (int i = 0; i < num_contacts; i++)
       {
+        // default to non-skip
+        self->contactGeomsSkipped[i] = false;
+
         // skip negative depth contacts
         if(self->contactGeoms[i].depth < 0)
           continue;
 
+        //   
+        // skip adding collision joint if the collisions are
+        //   near each others
+        //   and normals are nearly parallel
+        //   
+        double normal_dot_tol = 0.001;
+        double dist_tol   = 0.003;
+        for (int j = 0; j < i; j++)
+        {
+          // skip comparison with self and negative depth contacts against non-skipped contacts
+          if(self->contactGeoms[j].depth < 0 || self->contactGeomsSkipped[j])
+            continue;
+
+          // if distance(self->contactGeoms[i].pos[:] and self->contactGeoms[j].pos[:]) < tol
+          // && dotproduct(self->contactGeoms[i].normal[:] and self->contactGeoms[j].normal[:]) < tol
+          //   skip this contact
+
+          Vector3 contactPos1(self->contactGeoms[i].pos[0], self->contactGeoms[i].pos[1], self->contactGeoms[i].pos[2]);
+          Vector3 contactNorm1(self->contactGeoms[i].normal[0], self->contactGeoms[i].normal[1], self->contactGeoms[i].normal[2]);
+          Vector3 contactPos2(self->contactGeoms[j].pos[0], self->contactGeoms[j].pos[1], self->contactGeoms[j].pos[2]);
+          Vector3 contactNorm2(self->contactGeoms[j].normal[0], self->contactGeoms[j].normal[1], self->contactGeoms[j].normal[2]);
+
+          double normal_dot = 1.0 - contactNorm1.GetDotProd(contactNorm2);
+          double dist = (contactPos1 - contactPos2).GetLength();
+          if (fabs(normal_dot) < normal_dot_tol && dist < dist_tol)
+          {
+            self->contactGeomsSkipped[i] = true;
+            //printf("skipping norm[%f]<[%f]  dist[%f]<[%f]\n",normal_dot,normal_dot_tol,dist,dist_tol);
+            break;
+          }
+          //else printf("   ...   norm[%f]<[%f]  dist[%f]<[%f]\n",normal_dot,normal_dot_tol,dist,dist_tol);
+
+        }
+        if (self->contactGeomsSkipped[i]) continue;
+
+        //   
+        // proceed to add the contact point and create a contact joint
+        //   
         dContact contact;
         contact.geom = self->contactGeoms[i];
         contact.surface.mode = dContactSoftERP | dContactSoftCFM | dContactApprox1;
@@ -834,14 +878,10 @@
 
         if (geom1->surface->enableFriction && geom2->surface->enableFriction)
         {
-          contact.surface.mu = std::min(geom1->surface->mu1, 
-              geom2->surface->mu1);
-          contact.surface.mu2 = std::min(geom1->surface->mu2, 
-              geom2->surface->mu2);
-          contact.surface.slip1 = std::min(geom1->surface->slip1, 
-              geom2->surface->slip1);
-          contact.surface.slip2 = std::min(geom1->surface->slip2, 
-              geom2->surface->slip2);
+          contact.surface.mu = std::min(geom1->surface->mu1, geom2->surface->mu1);
+          contact.surface.mu2 = std::min(geom1->surface->mu2, geom2->surface->mu2);
+          contact.surface.slip1 = std::min(geom1->surface->slip1, geom2->surface->slip1);
+          contact.surface.slip2 = std::min(geom1->surface->slip2, geom2->surface->slip2);
         }
         else
         {
@@ -912,29 +952,31 @@
         // Store the contact info 
         if (geom1->GetContactsEnabled() || geom2->GetContactsEnabled())
         {
-          (*self->contactFeedbackIter).contact.depths.push_back(
-              contact.geom.depth);
+          (*self->contactFeedbackIter).contact.depths.push_back(contact.geom.depth);
           (*self->contactFeedbackIter).contact.positions.push_back(contactPos);
           (*self->contactFeedbackIter).contact.normals.push_back(contactNorm);
-          (*self->contactFeedbackIter).contact.time = 
-            Simulator::Instance()->GetSimTime();
+          (*self->contactFeedbackIter).contact.time = Simulator::Instance()->GetSimTime();
           dJointSetFeedback(c, &((*self->contactFeedbackIter).feedbacks[i]));
         }
 
         dJointAttach (c, b1, b2);
+        contact_created = true;
       }
 
-      // increase contact feedback buffer size if needed
-      if (geom1->GetContactsEnabled() || geom2->GetContactsEnabled())
+      if (contact_created)
       {
-        self->contactFeedbackIter++;
-        if (self->contactFeedbackIter == self->contactFeedbacks.end())
+        // increase contact feedback buffer size if needed
+        if (geom1->GetContactsEnabled() || geom2->GetContactsEnabled())
         {
-          // extend vector by 100 elements, but
-          //  remember last index, since resize might re-allocate the vector
-          unsigned int index = self->contactFeedbackIter - self->contactFeedbacks.begin();
-          self->contactFeedbacks.resize( self->contactFeedbacks.size() + 100);
-          self->contactFeedbackIter = self->contactFeedbacks.begin() + index;
+          self->contactFeedbackIter++;
+          if (self->contactFeedbackIter == self->contactFeedbacks.end())
+          {
+            // extend vector by 100 elements, but
+            //  remember last index, since resize might re-allocate the vector
+            unsigned int index = self->contactFeedbackIter - self->contactFeedbacks.begin();
+            self->contactFeedbacks.resize( self->contactFeedbacks.size() + 100);
+            self->contactFeedbackIter = self->contactFeedbacks.begin() + index;
+          }
         }
       }
     }
diff -r 45cf796cb43b server/physics/ode/ODEPhysics.hh
--- a/server/physics/ode/ODEPhysics.hh	Fri Apr 15 18:36:27 2011 -0700
+++ b/server/physics/ode/ODEPhysics.hh	Thu Apr 21 15:37:51 2011 -0700
@@ -224,6 +224,7 @@
   private: std::map<std::string, dSpaceID> spaces;
 
   private: std::vector<dContactGeom> contactGeoms;
+  private: std::vector<bool> contactGeomsSkipped;
 
 #ifdef QUICKSTEP_EXPERIMENTAL
   /// experimental ode stuff
