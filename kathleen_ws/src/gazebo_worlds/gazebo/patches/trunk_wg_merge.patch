
Property changes on: .
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk:r8900-8978
   Merged /code/gazebo/branches/wx:r8807-8927

Index: Media/materials/textures/Random3D.dds
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/dirt01.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/green_stop_button.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/cel_shading_diffuse.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/Chrome.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/basic_droplet.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/terr_rock6.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/map.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/heartpsg.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/Sepia1D.tga
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/exclamationPoint.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/smoke.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/blue_pause_button.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/green_play_button.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/NMStripes.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/normalNoiseColor.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/smileyPlain.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/snow_1024.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/nm_dn.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/nm_lf.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/lightwood.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/ribbonband.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/smileyHappy.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/rockwall.tga
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/terr_dirt-grass.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/NMBumpsOut.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/texmap2.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/10points.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/8x8PagesSplotches2.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/RustySteel.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/sphere_create_blue.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/smileyDead.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/floor.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/questionMark.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/1D_Noise2.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/control_pause_blue.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/terr_rock-dirt.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/plate1.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/rockwall_NH.tga
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/MtlPlat2.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/grey_step_button.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/waves2.dds
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/gras_02.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/Dirt.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/cel_shading_specular.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/ogreborderUp.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/logo.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/smokecolors.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/1D_Noise.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/WaterNormal1.tga
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/WaterNormal2.tga
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/r2skin.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/plate.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/black.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/droplet.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/rough_plaster.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/blue_step_button.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/blue_jaiqua.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/nm_up.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/spacesky.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/Water01.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/Water02.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/GreenSkin.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/green_end_button.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/grey_play_button.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/nm_bk.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/stone-2.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/aureola.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/green_pause_button.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/NMHollyBumps.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/BeachStones.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/waveNM.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/grey_pause_button.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/turret_new.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/NPRMetallic.tga
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/nm_fr.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/cylinder_create_blue.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/HeatNoise.tga
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/blue_play_button.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/BumpyMetal.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/control_play_blue.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/fw12b.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/control_end_blue.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/WeirdEye.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/RustyBarrel.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/egyptrockyfull.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/nm_rt.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/grass_1024.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/box_create_blue.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/cel_shading_edge.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/flaretrail.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/RustedMetal.jpg
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/turret.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/NMBalls.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/flare.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/skull.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/textures/smileySad.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: Media/materials/scripts/Gazebo.material
===================================================================
--- Media/materials/scripts/Gazebo.material	(revision 8976)
+++ Media/materials/scripts/Gazebo.material	(working copy)
@@ -1,467 +1,419 @@
-////////////////////////////////////////////////////////////////////////////////
-// Shader Programs 
-vertex_program Gazebo/DepthMapVS glsl
+
+import * from "shadow_receiver.program"
+import * from "perpixel.program"
+
+material Gazebo/GrayGrid : shadow_receiver_template
 {
-  source DepthMap.vert
+  set_texture_alias ambient_tex grayGrid.png
+  set_texture_alias diffuse_tex grayGrid.png
 
-  default_params
+  technique
   {
-    param_named_auto texelOffsets texel_offsets
-    param_named_auto pNear near_clip_distance
-    param_named_auto pFar far_clip_distance
-  }
+    pass spot
+    {
+      specular 0.5 0.5 0.5 128
+    }
+
+    pass directional
+    {
+      specular 0.5 0.5 0.5 128
+    }
+ }
 }
 
-fragment_program Gazebo/DepthMapFS glsl
+material Gazebo/Grey : perpixel_template
 {
-  source DepthMap.frag
-
-  default_params
+  technique
   {
+    pass ambient
+    {
+      ambient .1 .1 .1 
+    }
+
+    pass light
+    {
+      diffuse .1 .1 .1
+      specular .1 .1 .1 128
+    }
   }
 }
 
-material Gazebo/White
+material Gazebo/White : perpixel_template
 {
-	receive_shadows on
-
 	technique
 	{
-		pass Ambient
+		pass ambient
 		{
-			ambient 1.000000 1.000000 1.000000 1.000000
-      diffuse 1.0 1.0 1.0 1.0
-      specular 0.8 0.8 0.8 1 20
-      shading phong
+			ambient 1 1 1 1
 		}
-		pass PointLight
-		{
-			ambient 1.000000 1.000000 1.000000 1.000000
-      diffuse 1.0 1.0 1.0 1.0
-      specular 0.8 0.8 0.8 1 20
-      shading phong
-		}
 
-	}
-}
-
-material Gazebo/Grey
-{
-  receive_shadows on
-
-	technique
-	{
-		pass
+		pass light
 		{
-			ambient 0.3 0.3 0.3 1.0
-      diffuse 0.5 0.5 0.5 1.0
-      specular 0.8 0.8 0.8 1
-      //shading phong
+      diffuse 1 1 1 1
+      specular .1 .1 .1 128
 		}
 	}
 }
 
-material Gazebo/Eyes
+material Gazebo/FlatBlack : perpixel_template
 {
-  receive_shadows on
-
 	technique
 	{
-		pass
+		pass ambient
 		{
-			ambient 0 0 0 1.000000
-      texture_unit
-      {
-        colour_op_ex source1 src_manual src_current 0.1 0.1 0.1
-      }
+			ambient 0 0 0
 		}
+
+    pass light
+    {
+      diffuse 0 0 0
+      specular 0 0 0 0
+    }
 	}
 }
 
-material Gazebo/FlatBlack
+material Gazebo/Black : perpixel_template
 {
-  receive_shadows off
-
 	technique
 	{
-		pass
+		pass ambient
 		{
-			ambient 0.0 0.0 0.0 1.000000
-      texture_unit { colour_op_ex source1 src_manual src_current 0 0 0
-      }
+			ambient 0 0 0 
 		}
+
+    pass light
+    {
+			diffuse 0 0 0 
+      specular 0.1 0.1 0.1 128
+    }
 	}
 }
 
-material Gazebo/Black
-{
-	receive_shadows on
 
+material Gazebo/Red : perpixel_template
+{
 	technique
 	{
-		pass
+		pass ambient
 		{
-			ambient 0.000000 0.000000 0.000000 1.000000
-			diffuse 0.000000 0.000000 0.000000 1.000000
-      lighting on
-      shading phong
+			ambient 1 0 0 
 		}
+
+    pass light
+    {
+			diffuse 1 0 0 
+			specular .1 .1 .1 128 
+    }
 	}
 }
 
-
-material Gazebo/Red
+material Gazebo/Green : perpixel_template
 {
-	receive_shadows on
-
 	technique
 	{
-		pass
+		pass ambient
 		{
-			ambient 1.000000 0.000000 0.000000 1.000000
-			diffuse 1.000000 0.000000 0.000000 1.000000
-			specular 0.200000 0.000000 0.000000 1.000000 
-			emissive 0.000000 0.000000 0.000000 1.000000
-      lighting on
-      shading phong
+			ambient 0 1 0 
 		}
-	}
-}
 
-material Gazebo/Green
-{
-	receive_shadows on
-
-	technique
-	{
-		pass
+		pass light
 		{
-			ambient 0.000000 1.000000 0.000000 1.000000
-			diffuse 0.000000 1.000000 0.000000 1.000000
-			specular 0.000000 0.000000 0.000000 1.000000 
-			emissive 0.000000 0.000000 0.000000 0.000000
-      lighting on
-      shading phong
+			diffuse 0 1 0 
+			specular .1 .1 .1 128 
 		}
 	}
 }
 
-material Gazebo/Yellow
+material Gazebo/Blue : perpixel_template
 {
-	receive_shadows on
-
 	technique
 	{
-		pass
-		{
+    pass ambient
+    {
+			ambient 0 0 1 
+    }
 
-			ambient 1.000000 1.000000 0.000000 1.000000
-			diffuse 1.000000 1.000000 0.000000 1.000000
-			specular 0.200000 0.200000 0.000000 1.000000 
-			emissive 0.000000 0.000000 0.000000 1.000000
-      lighting on
-      shading phong
-		}
+    pass light
+    {
+			diffuse 0 0 1 
+			specular .1 .1 .1 128 
+      emissive 0 0 0
+    }
 	}
 }
 
-material Gazebo/Purple
+material Gazebo/Yellow : perpixel_template
 {
-	receive_shadows on
-
 	technique
 	{
-		pass
+		pass ambient
 		{
-
-			ambient 1.000000 0.000000 1.000000 1.000000
-			diffuse 1.000000 0.000000 1.000000 1.000000
-			specular 0.200000 0.000000 0.200000 1.000000 
-			emissive 0.000000 0.000000 0.000000 1.000000
-      lighting on
-      shading phong
+			ambient 1 1 0 
 		}
+
+    pass light
+    {
+			diffuse 1 1 0 
+			specular .1 .1 .1 128 
+    }
 	}
 }
 
-material Gazebo/Turquoise
+material Gazebo/Purple : perpixel_template
 {
-	receive_shadows on
-
 	technique
 	{
-		pass
+		pass ambient
 		{
-
-			ambient 0.000000 1.000000 1.000000 1.000000
-			diffuse 0.000000 1.000000 1.000000 1.000000
-			specular 0.000000 0.200000 0.200000 1.000000 
-			emissive 0.000000 0.000000 0.000000 1.000000
-      lighting on
-      shading phong
+			ambient 1 0 1 
 		}
+
+    pass light
+    {
+			diffuse 1 0 1 
+			specular .1 .1 .1 128 
+    }
 	}
 }
 
-material Gazebo/WhiteEmissive
+material Gazebo/Turquoise : perpixel_template
 {
-	receive_shadows off
-
 	technique
 	{
-		pass
+		pass ambient
 		{
-      ambient 1.000000 1.000000 1.000000 1.000000
-			diffuse 1.000000 1.000000 1.000000 1.000000
-			specular 0.200000 0.200000 0.200000 1.000000
-			emissive 1.000000 1.000000 1.000000 1.000000
-      lighting on
+			ambient 0 1 1 
 		}
+
+    pass light
+    {
+			diffuse 0 1 1 
+			specular .1 .1 .1 128 
+    }
 	}
 }
 
-material Gazebo/RedEmissive
-{
-	receive_shadows off
 
+material Gazebo/WhiteGlow : Gazebo/White
+{
 	technique
 	{
-		pass
-		{
-      ambient 1.000000 0.000000 0.000000 1.000000
-			diffuse 1.000000 0.000000 0.000000 1.000000
-			specular 0.200000 0.000000 0.000000 1.000000
-			emissive 1.000000 0.000000 0.000000 1.000000
-      lighting on
-		}
+    pass light
+    {
+			emissive 1 1 1
+    }
 	}
 }
 
-material Gazebo/GreenEmissive
+material Gazebo/RedGlow : Gazebo/Red 
 {
-  receive_shadows off
-
-  technique
-  {
-    pass
-    {
-      ambient 0.000000 1.000000 0.000000 1.000000
-      diffuse 0.000000 1.000000 0.000000 1.000000
-      specular 0.000000 0.200000 0.000000 1.000000
-      emissive 0.000000 0.100000 0.000000 1.000000
-      lighting on
-     }
-  }
-}
-
-material Gazebo/PurpleEmissive
-{
-	receive_shadows off
-
 	technique
 	{
-		pass
-		{
-      ambient 1.000000 0.000000 1.000000 1.000000
-			diffuse 1.000000 0.000000 1.000000 1.000000
-			specular 0.200000 0.000000 0.200000 1.000000
-			emissive 1.000000 0.000000 1.000000 1.000000
-      lighting on
-		}
+    pass light
+    {
+			emissive 1 0 0
+    }
 	}
 }
 
-material Gazebo/BlueLaser
+material Gazebo/GreenGlow : Gazebo/Green
 {
-  receive_shadows off
-
   technique
   {
-    pass
+    pass light
     {
-      scene_blend alpha_blend
-      depth_write off
-
-      ambient 0.0 0.0 1.0 1
-      diffuse 0.0 0.0 1.0 1
-
-      texture_unit
-      {
-        colour_op_ex source1 src_current src_current 0 1 0
-        alpha_op_ex source1 src_manual src_current 0.4
-      }
-
+      emissive 0 1 0
     }
   }
 }
 
-material Gazebo/BlueEmissive
+material Gazebo/BlueGlow : Gazebo/Blue
 {
-  receive_shadows off
-
   technique
   {
-    pass
+    pass light
     {
-      ambient 0.000000 0.000000 1.000000 1.000000
-      diffuse 0.000000 0.000000 1.000000 1.000000
-      specular 0.000000 0.000000 0.200000 1.000000
-      emissive 0.000000 0.000000 1.000000 1.000000
-      lighting on
+      emissive 0 0 1 
     }
   }
 }
 
-material Gazebo/JointAnchor
+material Gazebo/YellowGlow : Gazebo/Yellow
 {
-  receive_shadows off
-
-  technique
-  {
-    pass
-    {
-      ambient 1.000000 1.000000 1.000000 1.000000
-      diffuse 1.000000 1.000000 1.000000 1.000000
-      specular 1.000000 1.000000 1.000000 1.000000
-      emissive 1.000000 1.000000 1.000000 1.000000
-      lighting off
-    }
-  }
+	technique
+	{
+		pass light
+		{
+			emissive 1 1 0
+		}
+	}
 }
 
-material Gazebo/Blue
+material Gazebo/PurpleGlow : Gazebo/Purple
 {
-	receive_shadows on
+	technique
+	{
+		pass light
+		{
+			emissive 1 0 1
+		}
+	}
+}
 
+material Gazebo/TurquoiseGlow : Gazebo/Turquoise
+{
 	technique
 	{
-		pass
+		pass light
 		{
-		  ambient 0.000000 0.000000 1.000000 1.000000
-			diffuse 0.000000 0.000000 1.000000 1.000000
-			specular 0.000000 0.000000 0.200000 1.000000
-			emissive 0.000000 0.000000 0.000000 1.000000
-      lighting on
-      shading phong
+			emissive 0 1 1
 		}
 	}
 }
 
-material Gazebo/Skull
+material Gazebo/RedTransparent
 {
-  technique
-  {
+	technique
+	{
     pass
     {
-      depth_write off
       scene_blend alpha_blend
+      depth_write off
 
+      ambient 1.0 0.0 0.0 1
+      diffuse 1.0 0.0 0.0 1
+
       texture_unit
       {
-        texture skull.png
+        colour_op_ex source1 src_current src_current 1 0 0
+        alpha_op_ex source1 src_manual src_current 0.4
       }
     }
-  }
+	}
+
 }
 
-material Gazebo/ExclamationPoint
+material Gazebo/GreenTransparent
 {
-  technique
-  {
+	technique
+	{
     pass
     {
-      depth_write off
       scene_blend alpha_blend
+      depth_write off
 
+      ambient 0.0 1.0 0.0 1
+      diffuse 0.0 1.0 0.0 1
+
       texture_unit
       {
-        texture exclamationPoint.png
+        colour_op_ex source1 src_current src_current 0 1 0
+        alpha_op_ex source1 src_manual src_current 0.4
       }
     }
-  }
+	}
 }
 
-material Gazebo/QuestionMark
+material Gazebo/BlueTransparent
 {
-  technique
-  {
+	technique
+	{
     pass
     {
-      depth_write off
       scene_blend alpha_blend
+      depth_write off
 
+      ambient 0.0 0.0 1.0 1
+      diffuse 0.0 0.0 1.0 1
+
       texture_unit
       {
-        texture questionMark.png
+        colour_op_ex source1 src_current src_current 0 1 0
+        alpha_op_ex source1 src_manual src_current 0.4
       }
     }
-  }
+	}
 }
 
-material Gazebo/SmileyHappy
+material Gazebo/YellowTransparent
 {
   technique
   {
     pass
     {
-      //depth_write alpha_rejection
-      //scene_blend alpha_blend
+      scene_blend alpha_blend
+      depth_write off
 
+      ambient 1.0 1.0 0.0 1
+      diffuse 1.0 1.0 0.0 1
+
       texture_unit
       {
-        texture smileyHappy.png
+        colour_op_ex source1 src_current src_current 0 1 0
+        alpha_op_ex source1 src_manual src_current 0.4
       }
     }
-  }
-}
 
-material Gazebo/SmileySad
-{
-  technique
-  {
     pass
     {
-      //depth_write alpha_rejection
-      //scene_blend alpha_blend
+      depth_write on
 
+      ambient 1.0 1.0 0.0 1
+      diffuse 1.0 1.0 0.0 1
+      polygon_mode points
+
       texture_unit
       {
-        texture smileySad.png
+        colour_op_ex source1 src_current src_current 0 1 0
+        alpha_op_ex source1 src_manual src_current 0.4
       }
+
     }
   }
 }
 
-material Gazebo/SmileyDead
+
+
+
+material Gazebo/BlueLaser
 {
+  receive_shadows off
+
   technique
   {
     pass
     {
-      //depth_write off
-      //scene_blend alpha_blend
+      scene_blend alpha_blend
+      depth_write off
 
+      ambient 0.0 0.0 1.0 1
+      diffuse 0.0 0.0 1.0 1
+
       texture_unit
       {
-        texture smileyDead.png
+        colour_op_ex source1 src_current src_current 0 1 0
+        alpha_op_ex source1 src_manual src_current 0.4
       }
+
     }
   }
 }
 
-material Gazebo/SmileyPlain
+
+
+material Gazebo/JointAnchor
 {
+  receive_shadows off
+
   technique
   {
     pass
     {
-      //depth_write off
-      //scene_blend alpha_blend
-
-      texture_unit
-      {
-        texture smileyPlain.png
-      }
+      ambient 1.000000 1.000000 1.000000 1.000000
+      diffuse 1.000000 1.000000 1.000000 1.000000
+      specular 1.000000 1.000000 1.000000 1.000000
+      emissive 1.000000 1.000000 1.000000 1.000000
+      lighting off
     }
   }
 }
@@ -519,6 +471,7 @@
     }
   }
 }
+
 material Gazebo/PioneerBody
 {
 	receive_shadows on
@@ -611,170 +564,6 @@
 	}
 }
 
-material Gazebo/RustySteel
-{
-	technique
-	{
-		pass
-		{
-
-			texture_unit
-			{
-				texture RustySteel.jpg
-			}
-		}
-	}
-}
-
-material Gazebo/Chrome
-{
-	technique
-	{
-		pass
-		{
-
-			texture_unit
-			{
-				texture Chrome.jpg
-				env_map spherical
-			}
-		}
-	}
-}
-
-material Gazebo/BumpyMetal
-{
-	technique
-	{
-		pass
-		{
-			ambient 0.75 0.75 0.75
-			cull_hardware none
-			cull_software none
-
-			texture_unit
-			{
-				texture BumpyMetal.jpg
-			}
-		}
-	}
-}
-
-material Gazebo/GrayGrid 
-{
-	receive_shadows on
-
-	technique
-	{
-
-    // Decal pass
-		pass
-		{
-			texture_unit
-			{
-				texture grayGrid.png
-			}
-		}
-	}
-}
-
-material Gazebo/Rocky
-{
-	technique
-	{
-		pass
-		{
-			//ambient 0.2 0.2 0.2
-
-			texture_unit
-			{
-				texture egyptrockyfull.jpg
-			}
-		}
-	}
-}
-
-material Gazebo/GrassFloor
-{
-  //receive_shadows on
-	technique
-	{
-		pass 
-    {
-			texture_unit
-			{
-				texture grass_1024.jpg
-			}
-		}
-		//pass DirectionalLight
-    //{
-    //  ambient 0 1 0 1
-    //  diffuse 0 1 0 1
-    //  specular 0 0 0
-		//	texture_unit
-		//	{
-		//		texture grass_1024.jpg
-		//	}
-		//}
-
-		//pass PointLight
-    //{
-    //  ambient 0 1 0
-    //  diffuse 0 1 0
-    //  specular 0 0 0
-		//	texture_unit
-		//	{
-		//		texture grass_1024.jpg
-		//	}
-		//}
-		//pass SpotLight
-    //{
-    //  ambient 0 1 0
-    //  diffuse 0 1 0
-    //  specular 0 0 0
-
-		//	texture_unit
-		//	{
-		//		texture grass_1024.jpg
-		//	}
-		//}
-
-	}
-}
-
-material Gazebo/Rockwall
-{
-	technique
-	{
-		pass
-		{
-			texture_unit
-			{
-				texture rockwall.tga
-			}
-		}
-	}
-}
-
-material Gazebo/RustyBarrel
-{
-	technique
-	{
-		pass
-		{
-			ambient 0.5 0.5 0.5 1.0
-			diffuse 1.0 1.0 1.0 1.0
-			specular 0.0 0.0 0.0 1.0 12.5
-			emissive 0.0 0.0 0.0 1.0
-			texture_unit
-			{
-				texture RustyBarrel.png
-				filtering trilinear
-			}
-		}
-	}
-}
-
 material Gazebo/WoodPallet
 {
 	receive_shadows on
@@ -794,477 +583,3 @@
 		}
 	}
 }
-
-
-
-
-
-//vertex_program ShadowCasterVP glsl
-//{
-//  source v-shadow-caster.cg
-//    entry_point main
-//    profiles arbvp1
-//
-//    default_params
-//    {
-//      param_named_auto p_ModelViewProjection worldviewproj_matrix
-//        param_named_auto p_AmbientLight ambient_light_colour
-//    }
-//}
-
-//fragment_program ShadowCasterFP glsl
-//{
-//  source f-shadow-caster.cg
-//    entry_point main
-//    profiles arbfp1
-//    // Store normalized (usefull to avoid overflowin) or non-normalized depth ?
-//    //compile_arguments -DSTORE_NORMALIZED_DEPTH
-//
-//    default_params
-//    {
-//      // Only used when storing normalized depth values
-//      //param_named_auto p_Near near_clip_distance
-//      //param_named_auto p_Far far_clip_distance
-//      param_named p_DepthOffset float 0.01
-//    }
-//}
-
-//material ShadowCaster
-//{
-//  technique default
-//  {
-//    // Z-write only pass
-//    pass Z-write
-//    {
-//      vertex_program_ref ShadowCasterVP
-//      {
-//      }
-//      fragment_program_ref ShadowCasterFP
-//      {
-//      }
-//    }
-//  }
-//}
-
-material Gazebo/Fish
-{
-  technique
-  {
-    pass
-    {
-      texture_unit
-      {
-        texture steelhead.png
-      }
-    }
-  }
-}
-
-material Gazebo/LightWood
-{
-  technique
-  {
-    pass
-    {
-      texture_unit
-      {
-        texture lightwood.png
-      }
-    }
-  }
-}
-
-material Gazebo/WoodTile
-{
-  technique
-  {
-    pass
-    {
-      texture_unit
-      {
-        texture wood_floor.jpg
-      }
-    }
-  }
-}
-
-material Gazebo/Brick
-{
-  technique
-  {
-    pass
-    {
-      texture_unit
-      {
-        texture brick_5.gif
-      }
-    }
-  }
-}
-
-material Gazebo/RedTransparent
-{
-	technique
-	{
-    pass
-    {
-      scene_blend alpha_blend
-      depth_write off
-
-      ambient 1.0 0.0 0.0 1
-      diffuse 1.0 0.0 0.0 1
-
-      texture_unit
-      {
-        colour_op_ex source1 src_current src_current 1 0 0
-        alpha_op_ex source1 src_manual src_current 0.4
-      }
-    }
-	}
-}
-
-material Gazebo/GreenTransparent
-{
-	technique
-	{
-    pass
-    {
-      scene_blend alpha_blend
-      depth_write off
-
-      ambient 0.0 1.0 0.0 1
-      diffuse 0.0 1.0 0.0 1
-
-      texture_unit
-      {
-        colour_op_ex source1 src_current src_current 0 1 0
-        alpha_op_ex source1 src_manual src_current 0.4
-      }
-    }
-	}
-}
-
-material Gazebo/BlueTransparent
-{
-	technique
-	{
-    pass
-    {
-      scene_blend alpha_blend
-      depth_write off
-
-      ambient 0.0 0.0 1.0 1
-      diffuse 0.0 0.0 1.0 1
-
-      texture_unit
-      {
-        colour_op_ex source1 src_current src_current 0 1 0
-        alpha_op_ex source1 src_manual src_current 0.4
-      }
-    }
-	}
-}
-
-material Gazebo/DepthMap
-{
-  technique
-  {
-    pass
-    {
-      vertex_program_ref Gazebo/DepthMapVS
-      {
-      }
-      fragment_program_ref Gazebo/DepthMapFS
-      {
-      }
-    }
-  }
-}
-
-material Gazebo/PCBGreen
-{
-	technique
-	{
-        	pass
-        	{
-    		  scene_blend alpha_blend
-     		  depth_write off
-	
-     	 	  texture_unit
-     		  {
-     		     colour_op_ex source1 src_manual src_current 0.2 0.43 0.36
-   	  	     alpha_op_ex source1 src_manual src_current 0.2
-    	 	  }
-   		}
-	}
-}
-
-material Gazebo/Turret
-{
-	technique
-	{
-		pass
-		{
-                       lighting off
-
-
-                        ambient 1 1 1 1
-			diffuse 1 1 1 1
-			specular 0 0 0 0
-			emissive 0 0 0
-
-			alpha_rejection greater 128
-			depth_write on
-
-			texture_unit
-			{
-				texture turret_new.png
-				tex_coord_set 0
-				colour_op modulate
-			}
-		}
-	}
-}
-
-
-material Gazebo/EpuckBody
-{
-  technique
-  {
-    pass
-		{
-			lighting off
-
-			ambient 1 1 1 1
-			diffuse 1 1 1 1
-			specular 0 0 0 0
-			emissive 1 1 1
-
-
-			scene_blend alpha_blend
-			depth_write off
-
-			texture_unit
-			{
-			 colour_op_ex source1 src_manual src_current 0.523613 0.500817 0.499183
-                         alpha_op_ex source1 src_manual src_current 0.8
-			}
-		}
-
-  }
-}
-
-material Gazebo/EpuckRing
-{
-  technique
-  {
-    pass
-		{
-			lighting off
-
-			ambient 1 1 1 1
-			diffuse 1 1 1 1
-			specular 0 0 0 0
-			emissive 0 0 0
-
-			scene_blend alpha_blend
-			depth_write off
-
-			texture_unit
-			{
-			 colour_op_ex source1 src_manual src_current 0.8 0.8 0.8
-                         alpha_op_ex source1 src_manual src_current 0.5
-			}
-		}
-
-  }
-}
-
-material Gazebo/EpuckPlate
-{
-	technique
-	{
-		pass
-		{
-                        lighting off
-
-
-                        ambient 1 1 1 1
-			diffuse 1 1 1 1
-			specular 0 0 0 0
-			emissive 0 0 0
-
-
-			alpha_rejection greater 128
-			depth_write on
-
-			texture_unit
-			{
-				texture plate.png
-				tex_coord_set 0
-				colour_op modulate
-			}
-		}
-	}
-}
-
-material Gazebo/EpuckLogo
-{
-	technique
-	{
-		pass
-		{
-                        lighting off
-
-
-                        ambient 1 1 1 1
-			diffuse 1 1 1 1
-			specular 0 0 0 0
-			emissive 0 0 0
-
-			alpha_rejection greater 128
-			depth_write on
-
-			texture_unit
-			{
-				texture logo.png
-				tex_coord_set 0
-				colour_op modulate
-			}
-		}
-	}
-}
-
-material Gazebo/EpuckMagenta
-{
-  receive_shadows on
-  technique
-  {
-    pass
-    {
-      ambient 0.000000 0.000000 0.000000
-      diffuse 0.523613 0.500817 0.499183
-      specular 0.500000 0.500000 0.500000 50.000000
-      emissive 0.000000 0.000000 0.000000
-    }
-  }
-}
-
-material Gazebo/EpuckGold
-{
-
-  technique
-  {
-    pass
-    {
-   
-      
-                        lighting off
-
-
-                        ambient 1 1 1 1
-			diffuse 1 1 1 1
-			specular 0 0 0 0
-			emissive 0 0 0
-
-		
-			texture_unit
-			{
-			 colour_op_ex source1 src_manual src_current 1.000000 0.671000 0.000000
-                         alpha_op_ex source1 src_manual src_current 0.5
-			}
-    }
-  }
-}
-
-material PR2/White
-{
- technique
-  {
-    pass
-    {
-      ambient 1.0 1.0 1.0 1.0
-      diffuse 1.0 1.0 1.0 1.0
-      specular 0.1 0.1 0.1 1.0
-      emissive 0 0 0
-      shading phong
-    }
-  }
-}
-
-material PR2/Black
-{
- technique
-  {
-    pass
-    {
-      ambient 0.0 0.0 0.0 1.0
-      diffuse 0.0 0.0 0.0 1.0
-      specular 0.2 0.2 0.2 1.0
-      emissive 0.0 0.0 0.0
-      shading phong
-    }
-  }
-}
-
-material PR2/Grey0
-{
- technique
-  {
-    pass
-    {
-      ambient 0.85 0.85 0.85 1.0
-      diffuse 0.85 0.85 0.85 1.0
-      specular 0.0 0.0 0.0 1.0
-      emissive 0.0 0.0 0.0
-      shading phong
-    }
-  }
-}
-
-
-material PR2/Grey1
-{
- technique
-  {
-    pass
-    {
-      ambient 0.65 0.65 0.65 1.0
-      diffuse 0.65 0.65 0.65 1.0
-      specular 0.0 0.0 0.0 1.0
-      emissive 0.0 0.0 0.0
-      shading phong
-    }
-  }
-}
-
-material PR2/Grey2
-{
- technique
-  {
-    pass
-    {
-      ambient 0.58 0.6 0.612 1.0
-      diffuse 0.58 0.6 0.612 1.0
-      specular 1.0 1.0 1.0 1.0
-      emissive 0 0 0
-      shading phong
-    }
-  }
-}
-
-material PR2/Grey3
-{
- technique
-  {
-    pass
-    {
-      ambient 0.38 0.4 0.412 1.0
-      diffuse 0.38 0.4 0.412 1.0
-      specular 0.1 0.1 0.1 1.0
-      emissive 0 0 0
-      shading phong
-    }
-  }
-}
-
Index: Media/materials/scripts/CMakeLists.txt
===================================================================
--- Media/materials/scripts/CMakeLists.txt	(revision 8976)
+++ Media/materials/scripts/CMakeLists.txt	(working copy)
@@ -1,3 +1,9 @@
-SET (files Gazebo.material)
+SET (files Gazebo.material 
+           shadow_receiver.program 
+           shadow_caster.program
+           perpixel.program
+           blur.compositor
+           blur.material
+)
 
 INSTALL(FILES ${files} DESTINATION ${CMAKE_INSTALL_PREFIX}/share/gazebo/Media/materials/scripts/)
Index: Media/materials/programs/AmbientOneTexture.frag
===================================================================
--- Media/materials/programs/AmbientOneTexture.frag	(revision 8976)
+++ Media/materials/programs/AmbientOneTexture.frag	(working copy)
@@ -1,13 +0,0 @@
-// if you want to use more textures, don't forget to define them there
-uniform sampler2D diffuse_map;
-//uniform sampler2D diffuse_map2;
-//uniform sampler2D diffuse_map3;
-//uniform sampler2D diffuse_map4;
-
-varying float fogFactor;
-
-void main()
-{
-  vec4 color = texture2D( diffuse_map, gl_TexCoord[ 0 ].st ) * gl_Color;
-	gl_FragColor = mix(  vec4(gl_Fog.color), color, fogFactor);
-}
Index: Media/materials/programs/DepthMap.frag
===================================================================
--- Media/materials/programs/DepthMap.frag	(revision 8976)
+++ Media/materials/programs/DepthMap.frag	(working copy)
@@ -1,9 +0,0 @@
-varying float depth;
-
-void main()
-{
-  float f = depth;
-
-  //f = 0.0;
-  gl_FragColor = vec4(f, f, f, f);
-}
Index: Media/materials/programs/AmbientOneTexture.vert
===================================================================
--- Media/materials/programs/AmbientOneTexture.vert	(revision 8976)
+++ Media/materials/programs/AmbientOneTexture.vert	(working copy)
@@ -1,28 +0,0 @@
-varying float fogFactor;
-
-void main()
-{
-  vec4 ecPosition = gl_ModelViewMatrix * gl_Vertex;
-
-	gl_FrontColor = gl_LightModel.ambient * gl_FrontMaterial.ambient;
-	
-	// if you want to use more tex-coords, don't forget to assign them there
-	gl_TexCoord[ 0 ] = gl_MultiTexCoord0;
-	//gl_TexCoord[ 1 ] = gl_MultiTexCoord1;
-	//gl_TexCoord[ 2 ] = gl_MultiTexCoord2;
-	//gl_TexCoord[ 3 ] = gl_MultiTexCoord3;
-
-  // Compute the amount of fog to apply
-  if ( gl_Fog.end != 0.0)
-  {
-    fogFactor = clamp((gl_Fog.end - fabs(ecPosition.z)) * gl_Fog.scale,0,1);
-  }
-  else
-  {
-    fogFactor = 1.0;
-  }
-
-
-  
-	gl_Position = ftransform();
-}
Index: Media/materials/programs/DepthMap.vert
===================================================================
--- Media/materials/programs/DepthMap.vert	(revision 8976)
+++ Media/materials/programs/DepthMap.vert	(working copy)
@@ -1,14 +0,0 @@
-uniform vec4 texelOffsets;
-uniform float pNear;
-uniform float pFar;
-
-varying float depth;
-
-void main()
-{
-	gl_Position = ftransform();
-  gl_Position.xy += texelOffsets.zw * gl_Position.w;
-
-  //depth = gl_Position.z / (pFar - pNear);
-  depth = (gl_Position.z - pNear) / (pFar - pNear);
-}
Index: Media/materials/programs/SpotLight.frag
===================================================================
--- Media/materials/programs/SpotLight.frag	(revision 8976)
+++ Media/materials/programs/SpotLight.frag	(working copy)
@@ -1,49 +0,0 @@
-uniform vec4 lightAttenuation;
-uniform vec4 lightPositionOS;
-uniform vec4 cameraPositionOS;
-uniform vec4 spotParams;
-
-varying vec4 diffuse, specular;
-varying vec3 normal;
-varying vec4 position;
-
-void main()
-{
-  vec4 color = vec4 (0.0, 0.0, 0.0, 0.0);
-
-  vec3 n, halfV;
-  float NdotL, NdotHV;
-  float att, spotEffect;
-  float spotExponent = spotParams[2];
-
-  vec3 aux = vec3 (gl_ModelViewMatrix * lightPositionOS - position);
-  float toLightDist = length (aux);
-  vec3 lightDir = normalize (aux);
-  vec3 halfVector = normalize(vec3 (lightDir + normalize (vec3 (gl_ModelViewMatrix * cameraPositionOS - position))));
-
-  n = normalize (normal);
-
-  /* compute the dot product between normal and ldir */
-  NdotL = max (dot (n,lightDir),0.0);
-
-  if (gl_LightSource[0].spotCosCutoff >= 0.0 && NdotL > 0.0) {
-
-    spotEffect = dot(normalize(gl_LightSource[0].spotDirection), -lightDir);
-    if (spotEffect > gl_LightSource[0].spotCosCutoff)
-    {
-      spotEffect = pow(max(spotEffect, 0.0), spotExponent);
-
-      att = spotEffect / (lightAttenuation.y +
-          lightAttenuation.z * toLightDist +
-          lightAttenuation.w * toLightDist * toLightDist);
-
-      color += att * (diffuse * NdotL);
-
-
-      NdotHV = max (dot (n, halfVector), 0.0);
-      color += att * specular * pow (NdotHV,gl_FrontMaterial.shininess);
-    }
-  }   
-
-  gl_FragColor = color;
-} 
Index: Media/materials/programs/SpotLight.vert
===================================================================
--- Media/materials/programs/SpotLight.vert	(revision 8976)
+++ Media/materials/programs/SpotLight.vert	(working copy)
@@ -1,19 +0,0 @@
-uniform vec4 lightDiffuse;
-uniform vec4 lightSpecular;
-
-varying vec4 diffuse, specular;
-varying vec3 normal;
-varying vec4 position;
-
-void main()
-{   
-  /* first transform the normal into eye space and normalize the result */
-  normal = normalize (gl_NormalMatrix * gl_Normal);
-  position = gl_ModelViewMatrix * gl_Vertex;
-
-  /* Compute the diffuse, ambient and globalAmbient terms */
-  diffuse = gl_FrontMaterial.diffuse * lightDiffuse;
-  specular = gl_FrontMaterial.specular * lightSpecular;
-
-  gl_Position = ftransform();   
-} 
Index: Media/materials/programs/Ambient.frag
===================================================================
--- Media/materials/programs/Ambient.frag	(revision 8976)
+++ Media/materials/programs/Ambient.frag	(working copy)
@@ -1,4 +0,0 @@
-void main()
-{
-  gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
-}
Index: Media/materials/programs/Ambient.vert
===================================================================
--- Media/materials/programs/Ambient.vert	(revision 8976)
+++ Media/materials/programs/Ambient.vert	(working copy)
@@ -1,7 +0,0 @@
-
-void main()
-{
-	gl_Position = ftransform();
-	//gl_TexCoord[0] = gl_MultiTexCoord0;
-	gl_FrontColor = gl_Color;
-}
Index: Media/materials/programs/PointLight.frag
===================================================================
--- Media/materials/programs/PointLight.frag	(revision 8976)
+++ Media/materials/programs/PointLight.frag	(working copy)
@@ -1,34 +0,0 @@
-varying vec4 diffuse,ambientGlobal, ambient;
-varying vec3 normal,lightDir,halfVector;
-varying float dist;
-
-void main(void)
-{
-  /*vec4 color = ambientGlobal;
-
-  vec3 n,halfV,viewV,ldir;
-  float NdotL,NdotHV;
-  float att;
-
-  n = normalize(normal);
-
-  NdotL = max(dot(n,normalize(lightDir)),0.0);
-
-  if (NdotL > 0.0) {
-
-    att = 1.0 / (gl_LightSource[0].constantAttenuation +
-        gl_LightSource[0].linearAttenuation * dist +
-        gl_LightSource[0].quadraticAttenuation * dist * dist);
-    color += att * (diffuse * NdotL + ambient);
-
-
-    halfV = normalize(halfVector);
-    NdotHV = max(dot(n,halfV),0.0);
-    color += att * gl_FrontMaterial.specular * gl_LightSource[0].specular * 
-      pow(NdotHV,gl_FrontMaterial.shininess);
-  }
-
-  */
-  gl_FragColor = gl_Color;
-}
-
Index: Media/materials/programs/PointLight.vert
===================================================================
--- Media/materials/programs/PointLight.vert	(revision 8976)
+++ Media/materials/programs/PointLight.vert	(working copy)
@@ -1,31 +0,0 @@
-
-varying vec4 diffuse,ambientGlobal,ambient;
-varying vec3 normal,lightDir,halfVector;
-varying float dist;
-
-void main(void)
-{ 
-  /*vec4 ecPos;
-  vec3 aux;
-
-  normal = normalize(gl_NormalMatrix * gl_Normal);
-
-  ecPos = gl_ModelViewMatrix * gl_Vertex;
-  aux = vec3(gl_LightSource[0].position-ecPos);
-  lightDir = normalize(aux);
-  dist = length(aux);
-
-  halfVector = normalize(gl_LightSource[0].halfVector.xyz);
-
-  diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse;
-
-  ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient;
-  ambientGlobal = gl_LightModel.ambient * gl_FrontMaterial.ambient;
-
-  gl_FrontColor = vec4(1.0, 0.0, 0.0, 1.0);
-  gl_BackColor = vec4(1.0, 0.0, 0.0, 1.0);
-  */
-
-  gl_Position = ftransform();
-} 
-
Index: Media/materials/programs/DirectionalLight.frag
===================================================================
--- Media/materials/programs/DirectionalLight.frag	(revision 8976)
+++ Media/materials/programs/DirectionalLight.frag	(working copy)
@@ -1,28 +0,0 @@
-varying vec4 diffuse,ambient;
-varying vec3 normal,lightDir,halfVector;
-
-void main()
-{
-  vec3 n,halfV;
-  float NdotL,NdotHV;
-
-  /* The ambient term will always be present */
-  vec4 color = ambient;
-
-  /* a fragment shader can't write a varying variable, hence we need
-   *    a new variable to store the normalized interpolated normal */
-  n = normalize(normal);
-
-  /* compute the dot product between normal and ldir */
-  NdotL = max(dot(n,lightDir),0.0);
-
-  if (NdotL > 0.0) {
-    color += diffuse * NdotL;
-    halfV = normalize(halfVector);
-    NdotHV = max(dot(n,halfV),0.0);
-    color += gl_FrontMaterial.specular * 
-      gl_LightSource[1].specular * pow(NdotHV, gl_FrontMaterial.shininess);
-  }
-
-  gl_FragColor = color;
-}
Index: Media/materials/programs/DirectionalLight.vert
===================================================================
--- Media/materials/programs/DirectionalLight.vert	(revision 8976)
+++ Media/materials/programs/DirectionalLight.vert	(working copy)
@@ -1,18 +0,0 @@
-varying vec4 diffuse, ambient;
-varying vec3 normal, lightDir, halfVector;
-
-void main()
-{
-  // transform the normal into eye space
-  normal = gl_NormalMatrix * gl_Normal;
-
-  lightDir = normalize(vec3(gl_LightSource[1].position));
-
-  halfVector = normalize(gl_LightSource[1].halfVector.xyz);
-
-  diffuse = gl_FrontMaterial.diffuse * gl_LightSource[1].diffuse;
-  ambient = gl_FrontMaterial.ambient * gl_LightSource[1].ambient;
-  ambient += gl_LightModel.ambient * gl_FrontMaterial.ambient;
-
-  gl_Position = ftransform();
-}
Index: Media/materials/programs/CMakeLists.txt
===================================================================
--- Media/materials/programs/CMakeLists.txt	(revision 8976)
+++ Media/materials/programs/CMakeLists.txt	(working copy)
@@ -1,8 +1,17 @@
-SET (files PointLight.vert 
-           PointLight.frag 
-           DepthMap.frag 
-           DepthMap.vert 
-           )
+SET (files shadow_caster_fp.glsl
+           shadow_caster_vp.glsl
+           spot_shadow_receiver_fp.glsl
+           spot_shadow_receiver_vp.glsl
+           directional_shadow_receiver_fp.glsl
+           directional_shadow_receiver_vp.glsl
+           point_receiver_vp.glsl
+           point_receiver_fp.glsl
+           ambient_one_texture_vp.glsl
+           blur.glsl
+           perpixel_vp.glsl
+           perpixel_fp.glsl
+) 
 
 INSTALL(FILES ${files} DESTINATION ${CMAKE_INSTALL_PREFIX}/share/gazebo/Media/materials/programs/)
 
+

Property changes on: Media/models/pioneer2dx
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2dx:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2dx:r8807-8927


Property changes on: Media/models/pioneer2dx/wheel.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2dx/wheel.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2dx/wheel.mesh:r8807-8927


Property changes on: Media/models/pioneer2dx/pioneer3dx.blend
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2dx/pioneer3dx.blend:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2dx/pioneer3dx.blend:r8807-8927


Property changes on: Media/models/pioneer2dx/chassis.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2dx/chassis.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2dx/chassis.mesh:r8807-8927


Property changes on: Media/models/pioneer2dx/hub.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2dx/hub.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2dx/hub.mesh:r8807-8927


Property changes on: Media/models/pioneer2dx/sonarbank.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2dx/sonarbank.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2dx/sonarbank.mesh:r8807-8927


Property changes on: Media/models/pioneer2dx/Scene.material
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2dx/Scene.material:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2dx/Scene.material:r8807-8927


Property changes on: Media/models/pioneer2dx/chassis_top.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2dx/chassis_top.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2dx/chassis_top.mesh:r8807-8927


Property changes on: Media/models/pioneer2dx/CMakeLists.txt
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/branches/wx/Media/models/pioneer2dx/CMakeLists.txt:r8807-8927


Property changes on: Media/models/pioneer2dx/sonar.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2dx/sonar.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2dx/sonar.mesh:r8807-8927


Property changes on: Media/models/pioneer2dx/tire.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2dx/tire.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2dx/tire.mesh:r8807-8927


Property changes on: Media/models/pioneer2at
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2at:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at:r8807-8927


Property changes on: Media/models/pioneer2at/wheel.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2at/wheel.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at/wheel.mesh:r8807-8927


Property changes on: Media/models/pioneer2at/Cylinder.012.mesh.xml
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2at/Cylinder.012.mesh.xml:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at/Cylinder.012.mesh.xml:r8807-8927


Property changes on: Media/models/pioneer2at/OgreXMLConverter.log
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2at/OgreXMLConverter.log:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at/OgreXMLConverter.log:r8807-8927


Property changes on: Media/models/pioneer2at/chassis.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2at/chassis.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at/chassis.mesh:r8807-8927


Property changes on: Media/models/pioneer2at/hub.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2at/hub.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at/hub.mesh:r8807-8927


Property changes on: Media/models/pioneer2at/sonarbank.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2at/sonarbank.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at/sonarbank.mesh:r8807-8927


Property changes on: Media/models/pioneer2at/Scene.material
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2at/Scene.material:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at/Scene.material:r8807-8927


Property changes on: Media/models/pioneer2at/chassis_top.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2at/chassis_top.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at/chassis_top.mesh:r8807-8927


Property changes on: Media/models/pioneer2at/pioneer3at.blend
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2at/pioneer3at.blend:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at/pioneer3at.blend:r8807-8927


Property changes on: Media/models/pioneer2at/CMakeLists.txt
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at/CMakeLists.txt:r8807-8927


Property changes on: Media/models/pioneer2at/sonar.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2at/sonar.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at/sonar.mesh:r8807-8927


Property changes on: Media/models/pioneer2at/tire.mesh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/Media/models/pioneer2at/tire.mesh:r8900-8978
   Merged /code/gazebo/branches/wx/Media/models/pioneer2at/tire.mesh:r8807-8927

Index: cmake/SearchForStuff.cmake
===================================================================
--- cmake/SearchForStuff.cmake	(revision 8976)
+++ cmake/SearchForStuff.cmake	(working copy)
@@ -17,38 +17,70 @@
 set (bullet_lflags "" CACHE STRING "Bullet lflags Use this to override automatic detection.")
 set (bullet_cflags "-DBT_USE_DOUBLE_PRECISION -DBT_EULER_DEFAULT_ZYX" CACHE STRING "Bullet Dynamics C compile flags exported by rospack.")
 
+set (parallel_quickstep_include_dirs "" CACHE STRING "parallel_quickstep CUDA include paths. Use this to override automatic detection.")
+set (parallel_quickstep_library_dirs "" CACHE STRING "parallel_quickstep CUDA library paths. Use this to override automatic detection.")
+set (parallel_quickstep_lflags "" CACHE STRING "parallel_quickstep CUDA lflags Use this to override automatic detection.")
+set (parallel_quickstep_cflags "" CACHE STRING "parallel_quickstep CUDA cflags Use this to override automatic detection.")
+
 set (threadpool_include_dirs "" CACHE STRING "Threadpool include paths. Use this to override automatic detection.")
 
 SET (gazebo_lflags "" CACHE STRING "Linker flags such as rpath for gazebo executable.")
 
-set (FLTK_LIBRARIES "" CACHE STRING "Threadpool include paths. Use this to override automatic detection.")
-set (FLTK_INCLUDE_DIR "" CACHE STRING "Threadpool include paths. Use this to override automatic detection.")
+set (GTK2_LIBRARIES "" CACHE STRING "WX GTK2 include paths. Use this to override automatic detection.")
+set (GTK2_INCLUDE_DIRS "" CACHE STRING "WX GTK2 include paths. Use this to override automatic detection.")
 
 include (${gazebo_cmake_dir}/FindOS.cmake)
 include (FindPkgConfig)
+include (FindwxWidgets)
 include (${gazebo_cmake_dir}/FindFreeimage.cmake)
 
+include (FindOpenGL)
+if (NOT OPENGL_FOUND)
+  BUILD_ERROR ("Missing: OpenGL")
+else ()
+ APPEND_TO_CACHED_LIST(gazeboserver_include_dirs 
+                       ${gazeboserver_include_dirs_desc} 
+                       ${OPENGL_INCLUDE_DIR})
+ APPEND_TO_CACHED_LIST(gazeboserver_link_libs 
+                       ${gazeboserver_link_libs_desc} 
+                       ${OPENGL_LIBRARIES})
+endif ()
 
-set(FLTK_SKIP_FLUID TRUE)
-include (FindFLTK)
-if (FLTK_LIBRARIES AND FLTK_INCLUDE_DIR)
-  set (FLTK_FOUND ON BOOL FORCE)
-endif (FLTK_LIBRARIES AND FLTK_INCLUDE_DIR)
-if (NOT FLTK_FOUND)
-  BUILD_ERROR("FLTK libraries and development files not found. See the following website for installation instructions: http://fltk.org")
-endif (NOT FLTK_FOUND)
 
-
 ########################################
 # Find packages
 if (PKG_CONFIG_FOUND)
 
+  #################################################
+  # Find TBB
+  pkg_check_modules(TBB tbb)
+  IF (NOT TBB_FOUND)
+    BUILD_ERROR ("Missing: TBB - Threading Building Blocks")
+  ELSE (NOT TBB_FOUND)
+    APPEND_TO_CACHED_LIST(gazeboserver_include_dirs 
+                          ${gazeboserver_include_dirs_desc} 
+                          ${TBB_INCLUDE_DIRS})
+    APPEND_TO_CACHED_LIST(gazeboserver_link_dirs 
+                          ${gazeboserver_link_dirs_desc} 
+                          ${TBB_LIBRARY_DIRS})
+    APPEND_TO_CACHED_LIST(gazeboserver_link_libs 
+                          ${gazeboserver_link_libs_desc} 
+                          ${TBB_LINK_LIBS})
+    APPEND_TO_CACHED_LIST(gazeboserver_link_libs 
+                          ${gazeboserver_link_libs_desc} 
+                          ${TBB_LIBRARIES})
+    APPEND_TO_CACHED_LIST(gazeboserver_ldflags
+                          ${gazeboserver_ldflags_desc} 
+                          ${TBB_LDFLAGS})
+  ENDIF (NOT TBB_FOUND)
 
+
+
   #################################################
   # Find ODE
   pkg_check_modules(ODE ode>=${ODE_VERSION})
   IF (NOT ODE_FOUND)
-    BUILD_ERROR ("ODE and development files not found. See the following website: http://www.ode.org")
+    BUILD_ERROR ("Missing: ODE(http://www.ode.org)")
     SET (INCLUDE_ODE FALSE CACHE BOOL "Include support for ODE")
   ELSE (NOT ODE_FOUND)
     SET (INCLUDE_ODE TRUE CACHE BOOL "Include support for ODE")
@@ -100,7 +132,7 @@
 
     pkg_check_modules(OGRE OGRE>=${MIN_OGRE_VERSION})
     if (NOT OGRE_FOUND)
-      BUILD_ERROR("Ogre3d version >=${MIN_OGRE_VERSION} and development files not found. See the following website for installation instructions: http://www.orge3d.org")
+      BUILD_ERROR("Missing: Ogre3d version >=${MIN_OGRE_VERSION}(http://www.orge3d.org)")
     else (NOT OGRE_FOUND)
       set(ogre_ldflags ${OGRE_LDFLAGS})
       set(ogre_include_dirs ${OGRE_INCLUDE_DIRS})
@@ -134,10 +166,37 @@
                         ${ogre_cflags})
 
   #################################################
+  # Find GTK
+  pkg_check_modules(GTK2 gtk+-2.0)
+  IF (NOT GTK2_FOUND)
+    BUILD_ERROR("Missing: gtk+-2.0")
+  ELSE (NOT GTK2_FOUND)
+    APPEND_TO_CACHED_LIST(gazeboserver_include_dirs 
+                          ${gazeboserver_include_dirs_desc} 
+                          ${GTK2_INCLUDE_DIRS})
+    APPEND_TO_CACHED_LIST(gazeboserver_link_dirs 
+                          ${gazeboserver_link_dirs_desc} 
+                          ${GTK2_LIBRARY_DIRS})
+    APPEND_TO_CACHED_LIST(gazeboserver_link_libs 
+                          ${gazeboserver_link_libs_desc} 
+                          ${GTK2_LINK_LIBS})
+    APPEND_TO_CACHED_LIST(gazeboserver_link_libs 
+                          ${gazeboserver_link_libs_desc} 
+                          ${GTK2_LIBRARIES})
+    APPEND_TO_CACHED_LIST(gazeboserver_ldflags 
+                          ${gazeboserver_ldflags_desc} 
+                          ${GTK2_LDFLAGS})
+    APPEND_TO_CACHED_LIST(gazeboserver_cflags 
+                          ${gazeboserver_cflags_desc} 
+                          ${GTK2_CFLAGS})
+  ENDIF (NOT GTK2_FOUND)
+
+
+  #################################################
   # Find XML
   pkg_check_modules(XML libxml-2.0)
   IF (NOT XML_FOUND)
-    BUILD_ERROR("libxml2 and development files not found. See the following website: http://www.xmlsoft.org")
+    BUILD_ERROR("Missing: libxml2(http://www.xmlsoft.org)")
   ELSE (NOT XML_FOUND)
     APPEND_TO_CACHED_LIST(gazeboserver_include_dirs 
                           ${gazeboserver_include_dirs_desc} 
@@ -165,7 +224,7 @@
   # Find libXPM
   pkg_check_modules(XPM xpm)
   if (NOT XPM_FOUND)
-    BUILD_ERROR("libXpm and development files not found. See the following website: http://cgit.freedesktop.org/xorg/lib/libXpm")
+    BUILD_ERROR("Missing: libXpm(http://cgit.freedesktop.org/xorg/lib/libXpm)")
   else (NOT XPM_FOUND)
     APPEND_TO_CACHED_LIST(gazeboserver_include_dirs 
                           ${gazeboserver_include_dirs_desc} 
@@ -186,7 +245,7 @@
   # Find OpenAL
   pkg_check_modules(OAL openal)
   if (NOT OAL_FOUND)
-    message (STATUS "Warning: Openal and development files not found. Audio capabilities will be disabled. See the following website: http://connect.creativelabs.com/openal/default.aspx")
+    BUILD_WARNING ("Openal not found. Audio capabilities will be disabled.")
   else (NOT OAL_FOUND)
     set (HAVE_OPENAL TRUE)
     APPEND_TO_CACHED_LIST(gazeboserver_include_dirs 
@@ -207,7 +266,7 @@
   # Find AV format
   pkg_check_modules(AVF libavformat)
   if (NOT AVF_FOUND)
-    message (STATUS "Warning: libavformat and development files not found. Audio capabilities will be disabled.")
+    BUILD_WARNING ("libavformat not found. Audio capabilities will be disabled.")
   else (NOT AVF_FOUND)
     APPEND_TO_CACHED_LIST(gazeboserver_include_dirs 
                           ${gazeboserver_include_dirs_desc} 
@@ -227,7 +286,7 @@
   # Find avcodec
   pkg_check_modules(AVC libavcodec)
   if (NOT AVC_FOUND)
-    message (STATUS "Warning: libavcodec and development files not found. Audio capabilities will be disabled.")
+    BUILD_WARNING ("libavcodec not found. Audio capabilities will be disabled.")
   else (NOT AVC_FOUND)
     APPEND_TO_CACHED_LIST(gazeboserver_include_dirs 
                           ${gazeboserver_include_dirs_desc} 
@@ -252,7 +311,7 @@
   pkg_check_modules(PLAYER playercore>=3.0)
   if (NOT PLAYER_FOUND)
     set (INCLUDE_PLAYER OFF CACHE BOOL "Build gazebo plugin for player" FORCE)
-    message (STATUS "Warning: Player not found. The gazebo plugin for player will not be built. See the following website: http://playerstage.sourceforge.net")
+    BUILD_WARNING ("Player not found, gazebo plugin for player will not be built.")
   else (NOT PLAYER_FOUND)
     set (INCLUDE_PLAYER ON CACHE BOOL "Build gazebo plugin for player" FORCE)
     set (PLAYER_INCLUDE_DIRS ${PLAYER_INCLUDE_DIRS} CACHE INTERNAL
@@ -268,7 +327,7 @@
   pkg_check_modules(WEBSIM websim)
   if (NOT WEBSIM_FOUND)
     set (INCLUDE_WEBGAZEBO OFF CACHE BOOL "Build webgazebo" FORCE)
-    message (STATUS "Warning: Websim not found. Webgazebo will not be built")
+    BUILD_WARNING ("Websim not found. Webgazebo will not be built")
   else (NOT WEBSIM_FOUND)
     set (WEBSIM_INCLUDE_DIRS ${WEBSIM_INCLUDE_DIRS} CACHE INTERNAL
          "Websim include directory")
@@ -278,7 +337,6 @@
          "Websim libraries")
   endif (NOT WEBSIM_FOUND)
 
-
 else (PKG_CONFIG_FOUND)
   set (BUILD_GAZEBO OFF CACHE INTERNAL "Build Gazebo" FORCE)
   message (FATAL_ERROR "\nError: pkg-config not found")
@@ -286,6 +344,14 @@
 
 
 ########################################
+# Find wxWidgets
+find_package(wxWidgets)
+if (NOT wxWidgets_FOUND)
+    BUILD_ERROR ("Missing: wxWidgets(http://www.wxwidgets.org)")
+endif (NOT wxWidgets_FOUND)
+
+
+########################################
 # Find Boost, if not specified manually
 IF (NOT boost_include_dirs AND NOT boost_library_dirs AND NOT boost_libraries )
 
@@ -297,7 +363,7 @@
   SET(Boost_ADDITIONAL_VERSIONS "1.35" "1.35.0" "1.36" "1.36.1" "1.37.0" "1.39.0" CACHE INTERNAL "Boost Additional versions" FORCE)
   INCLUDE (FindBoost)
 
-  FIND_PACKAGE( Boost ${MIN_BOOST_VERSION} REQUIRED thread signals regex)
+  find_package( Boost ${MIN_BOOST_VERSION} REQUIRED thread signals regex)
 
   IF (NOT Boost_FOUND)
     SET (BUILD_GAZEBO OFF CACHE INTERNAL "Build Gazebo" FORCE)
@@ -323,10 +389,6 @@
 STRING(REGEX REPLACE " " ";" boost_libraries "${boost_libraries}")
 
 ########################################
-# For Threadpool
-message (STATUS "Threadpool Include Path: ${threadpool_include_dirs}")
-
-########################################
 # Find avformat and avcodec
 IF (HAVE_FFMPEG)
   SET (libavformat_search_path 
@@ -342,7 +404,7 @@
   FIND_PATH(LIBAVFORMAT_PATH avformat.h ${libavformat_search_path})
   IF (NOT LIBAVFORMAT_PATH)
     MESSAGE (STATUS "Looking for avformat.h - not found")
-    MESSAGE (STATUS "  Warning: audio/video will not be built")
+    BUILD_WARNING ("avformat.h not found. audio/video will not be built")
     SET (LIBAVFORMAT_PATH /usr/include)
   ELSE (NOT LIBAVFORMAT_PATH)
     MESSAGE (STATUS "Looking for avformat.h - found")
@@ -351,7 +413,7 @@
   FIND_PATH(LIBAVCODEC_PATH avcodec.h ${libavcodec_search_path})
   IF (NOT LIBAVCODEC_PATH)
     MESSAGE (STATUS "Looking for avcodec.h - not found")
-    MESSAGE (STATUS "  Warning: audio/video will not be built")
+    BUILD_WARNING ("avcodec.h not found. audio/video will not be built")
     SET (LIBAVCODEC_PATH /usr/include)
   ELSE (NOT LIBAVCODEC_PATH)
     MESSAGE (STATUS "Looking for avcodec.h - found")
@@ -368,7 +430,7 @@
 FIND_PATH(LIBEVENT_PATH event.h ${libevent_search_path})
 IF (NOT LIBEVENT_PATH)
   MESSAGE (STATUS "Looking for event.h - not found")
-  MESSAGE (STATUS "  Warning: webgazebo will not be built")
+  BUILD_WARNING ("event.h not found. webgazebo will not be built")
   SET (INCLUDE_WEBGAZEBO OFF CACHE BOOL "Found libevent" FORCE)
 ELSE (NOT LIBEVENT_PATH)
   MESSAGE (STATUS "Looking for event.h - found")
@@ -395,7 +457,7 @@
 FIND_PATH(libtool_include_dir ltdl.h /usr/include /usr/local/include)
 IF (NOT libtool_include_dir)
   MESSAGE (STATUS "Looking for ltdl.h - not found")
-  MESSAGE (STATUS "Warning: Unable to find libtool, plugins will not be supported.")
+  BUILD_WARNING ("ltdl.h not found, plugins will not be supported.")
   SET (libtool_include_dir /usr/include)
 ELSE (NOT libtool_include_dir)
   MESSAGE (STATUS "Looking for ltdl.h - found")
@@ -432,7 +494,7 @@
 endif ()
 
 if (NOT libyaml OR NOT yaml_include)
-  BUILD_ERROR("yaml libraries and development files not found. See the following website for installation instructions: http://www.yaml.org")
+  BUILD_ERROR("Missing: yaml(http://www.yaml.org)")
 endif (NOT libyaml OR NOT yaml_include)
 
 ########################################
@@ -440,7 +502,7 @@
 find_path(libdl_include_dir dlfcn.h /usr/include /usr/local/include)
 if (NOT libdl_include_dir)
   message (STATUS "Looking for dlfcn.h - not found")
-  message (STATUS "Warning: Unable to find libdl, plugins will not be supported.")
+  BUILD_WARNING ("dlfcn.h not found, plugins will not be supported.")
   set (libdl_include_dir /usr/include)
 else (NOT libdl_include_dir)
   message (STATUS "Looking for dlfcn.h - found")
@@ -449,7 +511,7 @@
 find_library(libdl_library dl /usr/lib /usr/local/lib)
 if (NOT libdl_library)
   message (STATUS "Looking for libdl - not found")
-  message (STATUS "Warning: Unable to find libdl, plugins will not be supported.")
+  BUILD_WARNING ("libdl not found, plugins will not be supported.")
 else (NOT libdl_library)
   message (STATUS "Looking for libdl - found")
 endif (NOT libdl_library)
@@ -467,8 +529,7 @@
   find_path(assimp_include_dir assimp/assimp.hpp ${assimp_include_dirs} ENV CPATH)
   
   if (NOT assimp_include_dir)
-    #BUILD_ERROR("assimp not found. See the following website for installation instructions: http://assimp.sourceforge.net")
-    message (STATUS "Looking for assimp/assimp.hpp - not found. Using built in version.")
+    message (STATUS "Looking for assimp/assimp.hpp - not found.")
     set (assimp_include_dirs /usr/include CACHE STRING
       "Assimp include paths. Use this to override automatic detection.")
   else (NOT assimp_include_dir)
@@ -487,7 +548,7 @@
   endif (assimp_library)
  
   if (NOT assimp_include_dir OR NOT assimp_library)
-    BUILD_ERROR("assimp not found. See the following website for installation instructions: http://assimp.sourceforge.net")
+    BUILD_ERROR("Missing: Assimp(http://assimp.sourceforge.net)")
   endif (NOT assimp_include_dir OR NOT assimp_library)
 
 endif (NOT assimp_include_dirs AND NOT assimp_library_dirs AND NOT assimp_libraries )
@@ -499,7 +560,6 @@
   find_path(bullet_include_dir btBulletDynamicsCommon.h ${bullet_include_dirs} ENV CPATH)
   
   if (NOT bullet_include_dir)
-    #BUILD_ERROR("bullet not found. See the following website for installation instructions: http://bullet.sourceforge.net")
     message (STATUS "Looking for btBulletDynamicsCommon.h - not found.")
     set (bullet_include_dirs /usr/include CACHE STRING
       "bullet include paths. Use this to override automatic detection.")
@@ -574,9 +634,14 @@
   set( CMAKE_REQUIRED_FLAGS)
 
   if (NOT BULLET_DOUBLE_PRECISION)
-    BUILD_ERROR("bullet was not compiled to use double precision.")
+    BUILD_ERROR("Dependency: bullet was not compiled to use double precision.")
     set (INCLUDE_BULLET OFF CACHE BOOL "Include Bullet" FORCE)
   endif (NOT BULLET_DOUBLE_PRECISION)
 endif (INCLUDE_BULLET)
 
-
+STRING(REPLACE " " ";" parallel_quickstep_include_dirs_split "${parallel_quickstep_include_dirs}")
+STRING(REPLACE " " ";" parallel_quickstep_library_dirs_split "${parallel_quickstep_library_dirs}")
+set( CMAKE_REQUIRED_INCLUDES ${parallel_quickstep_include_dirs_split} )
+set( CMAKE_REQUIRED_LIBRARIES parallel_quickstep )
+set( CMAKE_REQUIRED_FLAGS  ${parallel_quickstep_lflags} )
+ 

Property changes on: cmake/libgazebo_pkgconfig.cmake
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/branches/wx/cmake/libgazebo_pkgconfig.cmake:r8807-8927

Index: cmake/GazeboUtils.cmake
===================================================================
--- cmake/GazeboUtils.cmake	(revision 8976)
+++ cmake/GazeboUtils.cmake	(working copy)
@@ -76,12 +76,21 @@
 
 macro (BUILD_ERROR)
   foreach (str ${ARGN})
-    SET (msg "ERROR: ${str}" )
+    SET (msg "\t${str}" )
     MESSAGE (STATUS ${msg} )
     APPEND_TO_CACHED_LIST(build_errors "build errors" ${msg})
   endforeach (str ${ARGN})
 endmacro (BUILD_ERROR)
 
+macro (BUILD_WARNING)
+  foreach (str ${ARGN})
+    SET (msg "\t${str}" )
+    MESSAGE (STATUS ${msg} )
+    APPEND_TO_CACHED_LIST(build_warnings "build warning" ${msg})
+  endforeach (str ${ARGN})
+endmacro (BUILD_WARNING)
+
+
 ###############################################################################
 # Reset lists
 MACRO (GAZEBOSERVER_RESET_LISTS)
Index: libgazebo/gz.h
===================================================================
--- libgazebo/gz.h	(revision 8976)
+++ libgazebo/gz.h	(working copy)
@@ -432,7 +432,6 @@
                       SET_LINEAR_ACCEL,
                       SET_ANGULAR_VEL,
                       SET_ANGULAR_ACCEL,
-                      GO,
                       GET_ENTITY_TYPE,
                       GET_ENTITY_PARAM_COUNT,
                       GET_ENTITY_PARAM_KEY,
@@ -538,28 +537,6 @@
   /// \param id String name of the client
   public: virtual void Open(Client *client, std::string id);
 
-  /// \brief Tell gazebo to execute for a specified amount of time
-  /// \param ms Number of milliseconds to run
-  public: template<typename T>
-          void Go(unsigned int us,T subscriber)
-          {
-            // Send the go command to Gazebo
-            this->Lock(1);
-            SimulationRequestData *request = &(this->data->requests[this->data->requestCount++]);
-            request->type = SimulationRequestData::GO;
-            request->runTime = us;
-            this->Unlock();
-
-            {
-              if (this->currentConnection.connected())
-                this->currentConnection.disconnect();
-
-              // Connect the callback. This is signaled when the thread
-              // (below) finishes waiting 
-              this->currentConnection = this->goAckSignal.connect( subscriber );
-            }
-          }
-
   /// \brief Pause the simulation
   public: void Pause();
 
Index: libgazebo/Server.cc
===================================================================
--- libgazebo/Server.cc	(revision 8976)
+++ libgazebo/Server.cc	(working copy)
@@ -61,6 +61,7 @@
 // Destroy a server
 Server::~Server()
 {
+  this->Fini();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -182,6 +183,7 @@
   {
     std::ostringstream stream;
     stream << "error deleting pid file: " << strerror(errno);
+    std::cerr << stream.str();
     throw(stream.str());
   }
 
Index: libgazebo/CMakeLists.txt
===================================================================
--- libgazebo/CMakeLists.txt	(revision 8976)
+++ libgazebo/CMakeLists.txt	(working copy)
@@ -28,7 +28,7 @@
 endif (CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE})
 
 
-target_link_libraries( gazeboshm ${boost_libraries})
+target_link_libraries( gazeboshm ${boost_libraries} profiler)
 
 install (TARGETS gazeboshm DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)
 install (FILES ${headers} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/gazebo)
Index: TODO
===================================================================
--- TODO	(revision 8976)
+++ TODO	(working copy)
@@ -3,25 +3,18 @@
 ///////////////////////////////////////
 
 GUI
-- Hand of god
-  - Select models and get info
-  - Move models
-  -Implement in CameraSensor class.
-- Allow person to display and change XML parameters through the GUI.
-- Better fonts
-- Better camera movement. Translate is too slow over long distances
+-Set pose of object numerically
+-Model importer
+-Set joints
+-Set physics params, and other global params
+-Set Object parameters
+  - Apply materials, set friction, set visual & collision models, numerically set forces and torques
+- Orbit camera movement
 
 Rendering
-- FSAA: See OgreCreator::CreateWindow
-- Shadows draw on multiple surfaces(seem to pass through walls).
-- Removing the sky results in a black screen
 - Paging heightmaps. 
   - Positioning the current heightmap is a big hack
 - BSP loader and worlds
-- Fog
-- Anti Aliasing
-- Better lights
-  - GLSL per pixel lighting. Make this user selectable.
 - Dynamic textures
 
 
Index: server/Event.hh
===================================================================
--- server/Event.hh	(revision 8976)
+++ server/Event.hh	(working copy)
@@ -1,12 +0,0 @@
-#ifndef EVENT_HH
-#define EVENT_HH
-
-namespace gazebo
-{
-  class Event
-  {
-    public: int id;
-  };
-}
-
-#endif
Index: server/Vector3.hh
===================================================================
--- server/Vector3.hh	(revision 8976)
+++ server/Vector3.hh	(working copy)
@@ -63,6 +63,12 @@
   /// \brief Normalize the vector length
   public: void Normalize();
 
+  /// \brief Round to near whole number, return the result.
+  public: Vector3 Round();
+
+  /// \brief Get a rounded version of this vector
+  public: Vector3 GetRounded() const;
+
   /// \brief Set the contents of the vector
   public: void Set(double x = 0, double y =0 , double z = 0);
 
Index: server/sensors/camera/MonoCameraSensor.cc
===================================================================
--- server/sensors/camera/MonoCameraSensor.cc	(revision 8976)
+++ server/sensors/camera/MonoCameraSensor.cc	(working copy)
@@ -50,10 +50,11 @@
 //////////////////////////////////////////////////////////////////////////////
 // Constructor
 MonoCameraSensor::MonoCameraSensor(Body *body)
-    : Sensor(body), OgreCamera("Mono")
+    : Sensor(body)
 {
+  this->camera = new OgreCamera("Mono",0);
   this->typeName = "monocamera";
-  this->captureData = true;
+  this->camera->SetCaptureData(true);
 }
 
 
@@ -61,19 +62,26 @@
 // Destructor
 MonoCameraSensor::~MonoCameraSensor()
 {
+  delete this->camera;
+  this->camera = NULL;
 }
 
 //////////////////////////////////////////////////////////////////////////////
+/// Get the camera
+OgreCamera *MonoCameraSensor::GetCamera()
+{
+  return this->camera;
+}
+
+//////////////////////////////////////////////////////////////////////////////
 // Load the camera
 void MonoCameraSensor::LoadChild( XMLConfigNode *node )
 {
-  this->cameraName = this->cameraName+this->GetName();
-  this->LoadCam( node );
+  this->camera->Load( node );
 
-
   // Do some sanity checks
-  if (this->imageSizeP->GetValue().x == 0 || 
-      this->imageSizeP->GetValue().y == 0)
+  if (this->camera->GetImageWidth() == 0 || 
+      this->camera->GetImageHeight() == 0)
   {
     gzthrow("image has zero size");
   }
@@ -81,20 +89,8 @@
   if (Simulator::Instance()->GetRenderEngineEnabled())
   {
     this->ogreTextureName = this->GetName() + "_RttTex";
-    this->ogreMaterialName = this->GetName() + "_RttMat";
 
-    // Create the render texture
-    this->renderTexture = Ogre::TextureManager::getSingleton().createManual(
-                          this->ogreTextureName,
-                          "General",
-                          Ogre::TEX_TYPE_2D,
-                          this->imageSizeP->GetValue().x, 
-                          this->imageSizeP->GetValue().y,
-                          0,
-                          this->imageFormat,
-                          Ogre::TU_RENDERTARGET);
-
-    this->renderTarget = this->renderTexture->getBuffer()->getRenderTarget();
+    this->camera->CreateRenderTexture(this->ogreTextureName);
   }
 }
 
@@ -103,7 +99,7 @@
 void MonoCameraSensor::SaveChild(std::string &prefix, std::ostream &stream)
 {
   std::string p = prefix + "  ";
-  this->SaveCam(p, stream);
+  this->camera->Save(p, stream);
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -113,23 +109,8 @@
 
   if (Simulator::Instance()->GetRenderEngineEnabled())
   {
-    this->SetCameraSceneNode( this->GetVisualNode()->GetSceneNode() );
-    this->InitCam();
-    this->SetCamName(this->GetName());
-
-    /*Ogre::MaterialPtr mat = Ogre::MaterialManager::getSingleton().create(
-                              this->ogreMaterialName,
-                              Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
-
-     mat->getTechnique(0)->getPass(0)->createTextureUnitState(this->ogreTextureName);
-*/
-
-    Ogre::HardwarePixelBufferSharedPtr mBuffer;
-    // Get access to the buffer and make an image and write it to file
-    mBuffer = this->renderTexture->getBuffer(0, 0);
-
-    this->textureWidth = mBuffer->getWidth();
-    this->textureHeight = mBuffer->getHeight();
+    this->camera->SetSceneNode( this->GetVisualNode()->GetSceneNode() );
+    this->camera->Init();
   }
   
 }
@@ -138,7 +119,7 @@
 // Finalize the camera
 void MonoCameraSensor::FiniChild()
 {
-  this->FiniCam();
+  this->camera->Fini();
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -146,7 +127,7 @@
 void MonoCameraSensor::SetActive(bool value)
 {
   Sensor::SetActive(value);
-  this->SetRenderingEnabled(value);
+  this->camera->SetRenderingEnabled(value);
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -156,10 +137,9 @@
   if (!Simulator::Instance()->GetRenderEngineEnabled())
     return;
 
-  if (this->active || **this->alwaysActiveP || **this->saveFramesP)
-    this->UpdateCam();
+  //if (this->active || **this->alwaysActiveP)
+    //this->camera->Update();
 
-
   // Only continue if the controller has an active interface. Or frames need
   // to be saved
   /*if ( (this->controller && !this->controller->IsConnected()) &&
@@ -171,13 +151,3 @@
     this->UpdateCam();
     */
 }
-
-////////////////////////////////////////////////////////////////////////////////
-// Return the material the camera renders to
-std::string MonoCameraSensor::GetMaterialName() const
-{
-  if (!Simulator::Instance()->GetRenderEngineEnabled())
-    return NULL;
-  else
-    return this->ogreMaterialName;
-}
Index: server/sensors/camera/StereoCameraSensor.cc
===================================================================
--- server/sensors/camera/StereoCameraSensor.cc	(revision 8976)
+++ server/sensors/camera/StereoCameraSensor.cc	(working copy)
@@ -53,7 +53,7 @@
 //////////////////////////////////////////////////////////////////////////////
 // Constructor
 StereoCameraSensor::StereoCameraSensor(Body *body)
-    : Sensor(body), OgreCamera("Stereo")
+    : Sensor(body), OgreCamera("Stereo",0)
 {
   this->depthBuffer[0] = NULL;
   this->depthBuffer[1] = NULL;
@@ -209,7 +209,7 @@
   OgreAdaptor *adapt = OgreAdaptor::Instance();
   Ogre::RenderSystem *renderSys = adapt->root->getRenderSystem();
   Ogre::Viewport *vp = NULL;
-  Ogre::SceneManager *sceneMgr = adapt->sceneMgr;
+  Ogre::SceneManager *sceneMgr = adapt->GetSceneMgr(0);
   Ogre::Pass *pass;
   Ogre::SceneNode *gridNode = NULL;
   int i;
Index: server/sensors/camera/MonoCameraSensor.hh
===================================================================
--- server/sensors/camera/MonoCameraSensor.hh	(revision 8976)
+++ server/sensors/camera/MonoCameraSensor.hh	(working copy)
@@ -45,7 +45,7 @@
 /// This sensor is used for simulating standard monocular cameras; is
 /// is used by both camera models (e.g., SonyVID30) and user interface
 /// models (e.g., ObserverCam).
-class MonoCameraSensor : public Sensor, public OgreCamera
+class MonoCameraSensor : public Sensor
 {
   /// \brief Constructor
   public: MonoCameraSensor(Body *body);
@@ -53,6 +53,9 @@
   /// \brief Destructor
   public: virtual ~MonoCameraSensor();
 
+  /// \brief Get the camera
+  public: OgreCamera *GetCamera();
+
   /// \brief Load the camera using parameter from an XMLConfig node
   /// \param node The XMLConfig node
   protected: virtual void LoadChild( XMLConfigNode *node );
@@ -72,11 +75,11 @@
   /// \brief Set whether the sensor is active or not
   public: virtual void SetActive(bool value);
 
-  /// \brief Return the material the camera renders to
-  public: virtual std::string GetMaterialName() const;
-
   public: virtual std::string GetName() const { return Sensor::GetName(); }
 
+  private: OgreCamera *camera;
+
+  protected: std::string ogreTextureName;
 };
 
 /// \}
Index: server/sensors/camera/CMakeLists.txt
===================================================================
--- server/sensors/camera/CMakeLists.txt	(revision 8976)
+++ server/sensors/camera/CMakeLists.txt	(working copy)
@@ -1,12 +1,8 @@
 include (${gazebo_cmake_dir}/GazeboUtils.cmake)
 
-set (sources MonoCameraSensor.cc
-             StereoCameraSensor.cc
-)
+set (sources MonoCameraSensor.cc)
 
-set (headers MonoCameraSensor.hh
-             StereoCameraSensor.hh
-)
+set (headers MonoCameraSensor.hh)
 
 
 APPEND_TO_SERVER_SOURCES(${sources})
Index: server/sensors/SensorManager.cc
===================================================================
--- server/sensors/SensorManager.cc	(revision 8976)
+++ server/sensors/SensorManager.cc	(working copy)
@@ -50,7 +50,6 @@
   std::list<Sensor*>::iterator iter;
   for (iter = this->sensors.begin(); iter != this->sensors.end(); iter++)
     (*iter)->Update();
-    
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: server/sensors/ray/RaySensor.cc
===================================================================
--- server/sensors/ray/RaySensor.cc	(revision 8976)
+++ server/sensors/ray/RaySensor.cc	(working copy)
@@ -66,7 +66,7 @@
     gzthrow("Null body in the ray sensor");
 
   this->laserGeom = World::Instance()->GetPhysicsEngine()->CreateGeom(
-      Shape::MULTIRAY, this->body);
+      "multiray", this->body);
   this->laserGeom->SetName("Ray Sensor Geom");
 
   this->laserShape = (MultiRayShape*)(this->laserGeom->GetShape());
Index: server/sensors/ir/IRSensor.cc
===================================================================
--- server/sensors/ir/IRSensor.cc	(revision 8976)
+++ server/sensors/ir/IRSensor.cc	(working copy)
@@ -81,7 +81,7 @@
   while (iNode)
   {
     laserGeom = World::Instance()->GetPhysicsEngine()->CreateGeom(
-                     Shape::MULTIRAY, this->body);
+                     "multiray", this->body);
     laserGeom->SetName("IR Sensor Geom");
 
     laserShape = (MultiRayShape*)(laserGeom->GetShape());
Index: server/Time.hh
===================================================================
--- server/Time.hh	(revision 8976)
+++ server/Time.hh	(working copy)
@@ -204,7 +204,20 @@
   public: int32_t nsec;
 
   /// Correct the time
-  private: void Correct();
+  private: inline void Correct()
+           {
+             // Make any corrections
+             if (this->nsec > 1e9)
+             {
+               this->sec++;
+               this->nsec = (int32_t)(this->nsec - 1e9);
+             }
+             else if (this->nsec < 0)
+             {
+               this->sec--;
+               this->nsec = (int32_t)(this->nsec + 1e9);
+             }
+           }
 };
 /// \}
 
Index: server/Model.hh
===================================================================
--- server/Model.hh	(revision 8976)
+++ server/Model.hh	(working copy)
@@ -35,6 +35,7 @@
 #include <vector>
 
 #include "Param.hh"
+#include "Contact.hh"
 #include "Pose3d.hh"
 #include "Joint.hh"
 #include "Entity.hh"
@@ -226,13 +227,15 @@
     /// \brief Get the list of interfaces e.g "pioneer2dx_model1::laser::laser_iface0->laser"
     public: void GetModelInterfaceNames(std::vector<std::string>& list) const;
 
-    /// \brief Connect a boost::slot the the model's update  signal
-    public: template<typename T>
-            void ConnectUpdateSignal( T subscriber )
-            {
-              updateSignal.connect(subscriber);
-            }
+    /// \brief Add an occurance of a contact to this geom
+    public: void StoreContact(const Geom *geom, const Contact &contact);
 
+    /// \brief Get the number of contacts for a geom
+    public: unsigned int GetContactCount(const Geom *geom) const;
+
+    /// \brief Retreive a contact
+    public: Contact RetrieveContact(const Geom *geom, unsigned int i) const;
+
     /// \brief Load a body helper function
     /// \param node XML Configuration node
     private: void LoadBody(XMLConfigNode *node);
@@ -286,14 +289,17 @@
     private: ParamT<float> *laserRetroP;
     private: ParamT<std::string> *collideP;
 
+    private: Body *canonicalBody;
+    private: std::vector<Body*> bodies;
 
+    /// All the contacts for every geom
+    public: std::map< std::string, std::vector<Contact> > contacts;
+
     // Name of a light (if the model is renderable:light)
     private: Light *light;
 
     private: GraphicsIfaceHandler *graphicsHandler;
 
-    private: boost::signal<void ()> updateSignal;
-
   /*  private: PyObject *pName;
       private: PyObject *pModule;
       private: PyObject *pFuncUpdate;
Index: server/Entity.cc
===================================================================
--- server/Entity.cc	(revision 8976)
+++ server/Entity.cc	(working copy)
@@ -39,33 +39,30 @@
 
 using namespace gazebo;
 
-
 ////////////////////////////////////////////////////////////////////////////////
 // Constructor
-Entity::Entity(Entity *parent)
-: Common(), parent(parent), visualNode(0)
+Entity::Entity(Common *parent)
+: Common(parent), visualNode(0)
 {
-  this->type = DEFAULT;
+  this->AddType(ENTITY);
 
   Param::Begin(&this->parameters);
   this->staticP = new ParamT<bool>("static",false,0);
+  this->staticP->Callback( &Entity::SetStatic, this );
   Param::End();
  
-  this->selected = false;
-
   std::ostringstream visname;
   visname << "Entity_" << this->GetId() << "_VISUAL";
 
-  if (this->parent)
+  if (this->parent && this->parent->HasType(ENTITY))
   {
-    this->parent->AddChild(this);
-
+    Entity *ep = (Entity*)(this->parent);
     if (Simulator::Instance()->GetRenderEngineEnabled())
     {
       this->visualNode = OgreCreator::Instance()->CreateVisual(
-          visname.str(), this->parent->GetVisualNode(), this);
+          visname.str(), ep->GetVisualNode(), this);
     }
-    this->SetStatic(parent->IsStatic());
+    this->SetStatic(ep->IsStatic());
   }
   else
   {
@@ -77,45 +74,46 @@
   }
 }
 
+void Entity::SetName(const std::string &name)
+{
+  Common::SetName(name);
+  std::ostringstream visname;
+  visname << name << "_VISUAL";
+  this->visualNode->SetName(visname.str());
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // Destructor
 Entity::~Entity()
 {
-  // remove self as a child of the parent
-  if (this->parent)
-    this->parent->RemoveChild(this);
-
   // remove all connected joints for a Body before delteing it
    /*gazebo::Model* parent_model = dynamic_cast<gazebo::Model*>(this->parent);
    if (parent_model)
      parent_model->DeleteConnectedJoints(this);
      */
 
-  this->SetParent(NULL);
-
   delete this->staticP;
 
-  std::vector<Entity*>::iterator iter;
+  std::vector<Common*>::iterator iter;
 
   World::Instance()->GetPhysicsEngine()->RemoveEntity(this);
 
-  for (iter = this->children.begin(); iter != this->children.end(); iter++)
+  /*for (iter = this->children.begin(); iter != this->children.end(); iter++)
   {
-    if (*iter)
+    if (*iter && (*iter)->HasType(ENTITY))
     {
-      (*iter)->SetParent(NULL);
+      Entity *child = (Entity*)(*iter);
+      child->SetParent(NULL);
+      World::Instance()->GetPhysicsEngine()->RemoveEntity(child);
 
-      World::Instance()->GetPhysicsEngine()->RemoveEntity(*iter);
-
-      if (*iter && (*iter)->GetType() == Entity::MODEL)
+      if (child->HasType(MODEL))
       {
-        Model *m = (Model*)*iter;
+        Model *m = (Model*)child;
         m->Detach();
       }
-
-      delete *iter;
+      //delete *iter;
     }
-  }
+  }*/
 
   if (Simulator::Instance()->GetRenderEngineEnabled())
   {
@@ -129,85 +127,6 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// Return the ID of the parent
-int Entity::GetParentId() const
-{
-  return this->parent == NULL ? 0 : this->parent->GetId();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Set the parent
-void Entity::SetParent(Entity *parent)
-{
-  this->parent = parent;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Get the parent
-Entity *Entity::GetParent() const
-{
-  return this->parent;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Add a child to this entity
-void Entity::AddChild(Entity *child)
-{
-  if (child == NULL)
-    gzthrow("Cannot add a null child to an entity");
-
-  // Add this child to our list
-  this->children.push_back(child);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Remove a child from this entity
-void Entity::RemoveChild(Entity *child)
-{
-  std::vector<Entity*>::iterator iter;
-  for (iter = this->children.begin(); iter != this->children.end(); iter++)
-  {
-    if ((*iter)->GetName() == child->GetName())
-    {
-      this->children.erase(iter);
-      break;
-    }
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Get all children
-const std::vector< Entity* > &Entity::GetChildren() const
-{
-  return this->children;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-///  Get the number of children
-unsigned int Entity::GetChildCount() const
-{
-  return this->children.size();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get a child by index
-Entity *Entity::GetChild(unsigned int i)
-{
-  if (i < this->children.size())
-    return this->children[i];
-  
-  return NULL;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get a child by name
-Entity *Entity::GetChild(const std::string &name )
-{
-  std::string fullName = this->GetCompleteScopedName() + "::" + name;
-  return World::Instance()->GetEntityByName(fullName);
-}
- 
-////////////////////////////////////////////////////////////////////////////////
 // Return this entitie's sceneNode
 OgreVisual *Entity::GetVisualNode() const
 {
@@ -225,20 +144,24 @@
 // Set whether this entity is static: immovable
 void Entity::SetStatic(const bool &s)
 {
-  std::vector< Entity *>::iterator iter;
+  std::vector< Common *>::iterator iter;
   Body *body = NULL;
 
   this->staticP->SetValue( s );
 
   for (iter = this->children.begin(); iter != this->children.end(); iter++)
   {
-    if ( (*iter)->IsStatic())
+    if (! (*iter)->HasType(ENTITY))
       continue;
 
-    (*iter)->SetStatic(s);
-    if (*iter && (*iter)->GetType() == Entity::BODY)
+    Entity *ent = (Entity*)(*iter);
+    if (!ent || ent->IsStatic())
+      continue;
+
+    ent->SetStatic(s);
+    if (ent->HasType(BODY))
     {
-      body = (Body*)*iter;
+      body = (Body*)ent;
       body->SetEnabled(!s);
     }
   }
@@ -253,88 +176,16 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Set whether this entity has been selected by the user through the gui
-bool Entity::SetSelected( bool s )
-{
-  std::vector< Entity *>::iterator iter;
-
-  this->selected = s;
-
-  for (iter = this->children.begin(); iter != this->children.end(); iter++)
-    (*iter)->SetSelected(s);
-
-  return true;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// True if the entity is selected by the user
-bool Entity::IsSelected() const
-{
-  return this->selected;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Returns true if the entities are the same. Checks only the name
-bool Entity::operator==(const Entity &ent) const 
-{
-  return ent.GetName() == this->GetName();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Return the name of this entity with the model scope
-/// model1::...::modelN::entityName
-std::string Entity::GetScopedName() const
-{
-  Entity *p = this->parent;
-  std::string scopedName = this->GetName();
-
-  while (p)
-  {
-    if (p && p->GetType() == Entity::MODEL)
-    {
-      Model *m = (Model*)p;
-      scopedName.insert(0, m->GetName()+"::");
-    }
-    p = p->GetParent();
-  }
-
-  return scopedName;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Return the name of this entity with the model scope
-/// model1::...::modelN::entityName
-std::string Entity::GetCompleteScopedName() const
-{
-  Entity *p = this->parent;
-  std::string scopedName = this->GetName();
-
-  while (p)
-  {
-    scopedName.insert(0, p->GetName()+"::");
-    p = p->GetParent();
-  }
-
-  return scopedName;
-}
-
-////////////////////////////////////////////////////////////////////////////////
 /// Get the absolute pose of the entity
 Pose3d Entity::GetWorldPose() const
 {
-  if (this->parent)
+  if (this->parent && this->parent->HasType(ENTITY))
   {
-    //std::cout << " GetWorldPose for model " << this->GetName()
-    //          << " relative " << this->GetRelativePose()
-    //          << " parent-abs " << this->parent->GetWorldPose() << std::endl;
-    return this->GetRelativePose() + this->parent->GetWorldPose();
+    Entity *ent = (Entity*)this->parent;
+    return this->GetRelativePose() + ent->GetWorldPose();
   }
   else
-  {
-    //std::cout << " GetWorldPose for model " << this->GetName()
-    //          << " relative " << this->GetRelativePose() << std::endl;
     return this->GetRelativePose();
-  }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -357,22 +208,23 @@
 /// Get the pose relative to the model this entity belongs to
 Pose3d Entity::GetModelRelativePose() const
 {
-  if (this->type == MODEL || !this->parent)
+  if (this->HasType(MODEL) || !this->parent)
     return Pose3d();
 
-  return this->GetRelativePose() + this->parent->GetModelRelativePose();
+  return this->GetRelativePose() + 
+         ((Entity*)this->parent)->GetModelRelativePose();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Set the abs pose of the entity
 void Entity::SetWorldPose(const Pose3d &pose, bool notify)
 {
-  if (this->parent)
+  if (this->parent && this->parent->HasType(ENTITY))
   {
     // if this is the canonical body of a model, then
     // we want to SetWorldPose of the parent model
     // by doing some backwards transform
-    if (this->parent->type == MODEL &&
+    if (this->parent->HasType(MODEL) && 
         ((Model*)this->parent)->GetCanonicalBody() == (Body*)this)
     {
       // abs pose of the model + relative pose of cb = abs pose of cb 
@@ -391,7 +243,7 @@
       //model_abs_pose.pos = pose.pos - this->GetRelativePose().pos;
       // set abs pose of parent model without propagating
       // changes to children
-      this->parent->SetWorldPose(model_abs_pose,false);
+      ((Entity*)this->parent)->SetWorldPose(model_abs_pose,false);
       // that should be all, as relative pose of a canonical model
       // should not change
     }
@@ -399,7 +251,7 @@
     {
       // this is not a canonical Body of a model
       // simply update it's own RelativePose
-      Pose3d relative_pose = pose - this->parent->GetWorldPose();
+      Pose3d relative_pose = pose - ((Entity*)this->parent)->GetWorldPose();
       // relative pose is the pose relative to the parent
       // if this is called from MoveCallback, notify is false
       // FIXME: if this is called by user, and notify is true
@@ -409,7 +261,7 @@
       this->SetRelativePose(relative_pose, notify);
     }
   }
-  else if (this->type == MODEL)
+  else if (this->HasType(MODEL))
   {
     // race condition with MoveCallback from canonical body calling SetWorldPose
     // we need to stop canonicalBody from calling SetWorldPose in MoveCallback
@@ -460,54 +312,11 @@
   {
     this->OnPoseChange();
 
-    std::vector<Entity*>::iterator iter;
+    std::vector<Common*>::iterator iter;
     for  (iter = this->children.begin(); iter != this->children.end(); iter++)
-      (*iter)->OnPoseChange();
+    {
+      if ((*iter)->HasType(ENTITY))
+        ((Entity*)*iter)->OnPoseChange();
+    }
   }
 }
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the parent model, if one exists
-Model *Entity::GetParentModel() const
-{
-  Entity *p = this->parent;
-
-  while (p && p->type != MODEL)
-    p = p->GetParent();
-
-  return (Model*)p;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Set the type of this entity
-void Entity::SetType(Entity::Type type)
-{
-  this->type = type;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the type of this entity
-Entity::Type Entity::GetType() const
-{
-  return this->type;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the type as a string
-std::string Entity::GetTypeString() const
-{
-  static std::string typenames[] = {"default", "model", "body", "geom", "light"};
-  return typenames[this->type];
-}
-
-
-////////////////////////////////////////////////////////////////////////////////
-void Entity::Print(std::string prefix)
-{
-  std::vector<Entity*>::iterator iter;
-  std::cout << prefix << this->GetName() << "\n";
-
-  prefix += "  ";
-  for (iter = this->children.begin(); iter != this->children.end(); iter++)
-    (*iter)->Print(prefix);
-}
Index: server/Simulator.cc
===================================================================
--- server/Simulator.cc	(revision 8976)
+++ server/Simulator.cc	(working copy)
@@ -30,6 +30,7 @@
 #include <boost/bind.hpp>
 #include <boost/thread/recursive_mutex.hpp>
 
+#include "RenderState.hh"
 #include "gazebo_config.h"
 #include "Plugin.hh"
 #include "Timer.hh"
@@ -40,12 +41,13 @@
 #include "OgreVisual.hh"
 #include "World.hh"
 #include "XMLConfig.hh"
-#include "Gui.hh"
+#include "SimulationApp.hh"
 #include "GazeboConfig.hh"
 #include "gz.h"
 #include "PhysicsEngine.hh"
 #include "OgreAdaptor.hh"
 #include "GazeboMessage.hh"
+#include "GazeboError.hh"
 #include "Global.hh"
 
 #include "Simulator.hh"
@@ -71,8 +73,8 @@
     <pos>0 0</pos>\
   </rendering:gui>\
   <rendering:ogre>\
-    <ambient>1 1 1 1</ambient>\
-    <shadowTechnique>stencilModulative</shadowTechnique>\
+    <ambient>.1 .1 .1 1</ambient>\
+    <shadows>true</shadows>\
     <grid>false</grid>\
   </rendering:ogre>\
    <model:physical name=\"plane1_model\">\
@@ -83,7 +85,7 @@
       <geom:plane name=\"plane1_geom\">\
         <normal>0 0 1</normal>\
         <size>100 100</size>\
-        <segments>10 10</segments>\
+        <segments>1 1</segments>\
         <uvTile>100 100</uvTile>\
         <material>Gazebo/GrayGrid</material>\
         <mu1>109999.0</mu1>\
@@ -91,13 +93,25 @@
       </geom:plane>\
     </body:plane>\
   </model:physical>\
+  <model:renderable name='directional_light'>\
+    <xyz>0.0 0 10</xyz>\
+    <static>true</static>\
+    <light>\
+      <type>directional</type>\
+      <diffuseColor>0.6 0.6 0.6 1.0</diffuseColor>\
+      <specularColor>.1 .1 .1 1.0</specularColor>\
+      <attenuation>.2 0.1 0.0</attenuation>\
+      <range>100</range>\
+      <direction>-.4 0 -0.6</direction>\
+      <castShadows>true</castShadows>\
+    </light>\
+  </model:renderable>\
 </gazebo:world>";
 
 ////////////////////////////////////////////////////////////////////////////////
 // Constructor
 Simulator::Simulator()
-: xmlFile(NULL),
-  gui(NULL),
+: gui(NULL),
   renderEngine(NULL),
   gazeboConfig(NULL),
   loaded(false),
@@ -110,6 +124,7 @@
   renderUpdates(0),
   stepInc(false),
   userQuit(false),
+  physicsQuit(false),
   guiEnabled(true),
   renderEngineEnabled(true),
   physicsEnabled(true),
@@ -132,12 +147,6 @@
     this->gazeboConfig = NULL;
   }
 
-  if (this->xmlFile)
-  {
-    delete this->xmlFile;
-    this->xmlFile = NULL;
-  }
-
   if (this->render_mutex)
   {
     delete this->render_mutex;
@@ -165,13 +174,6 @@
   if (!this->loaded)
     return;
 
-  if (this->gui)
-  {
-    delete this->gui;
-    this->gui = NULL;
-  }
-
-
   gazebo::World::Instance()->Close();
 
   if (this->renderEngineEnabled)
@@ -192,14 +194,14 @@
   }
 
   // Load the world file
-  this->xmlFile=new gazebo::XMLConfig();
+  XMLConfig *xmlFile=new gazebo::XMLConfig();
 
   try
   {
     if (worldFileName.size())
-      this->xmlFile->Load(worldFileName);
+      xmlFile->Load(worldFileName);
     else
-      this->xmlFile->LoadString(defaultWorld);
+      xmlFile->LoadString(defaultWorld);
   }
   catch (GazeboError e)
   {
@@ -248,12 +250,10 @@
       }
 
         // Create the GUI
-      if (childNode || !rootNode)
+      if (!this->gui && (childNode || !rootNode))
       {
-        this->gui = new Gui(x, y, width, height, "Gazebo");
-
-        this->gui->Load(childNode);
-        this->gui->CreateCameras();
+        this->gui = new SimulationApp();
+        this->gui->Load();
       }
     }
     catch (GazeboError e)
@@ -305,8 +305,6 @@
   }
 
   this->loaded=true;
-
-  //OgreAdaptor::Instance()->PrintSceneGraph();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -315,6 +313,8 @@
 {
   this->state = INIT;
 
+  RenderState::Init();
+
   //Initialize the world
   try
   {
@@ -400,8 +400,33 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+// Stop the physics engine
+void Simulator::StopPhysics()
+{
+  this->physicsQuit = true;
+  if (this->physicsThread)
+  {
+    this->physicsThread->join();
+    delete this->physicsThread;
+    this->physicsThread = NULL;
+  }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Start the physics engine
+void Simulator::StartPhysics()
+{
+  if (this->physicsThread)
+    this->StopPhysics();
+
+  this->physicsQuit = false;
+  this->physicsThread = new boost::thread( 
+      boost::bind(&Simulator::PhysicsLoop, this));
+}
+
+////////////////////////////////////////////////////////////////////////////////
 /// Main simulation loop, when this loop ends the simulation finish
-void Simulator::MainLoop()
+void Simulator::Run()
 {
   this->state = RUN;
 
@@ -412,39 +437,63 @@
   struct timespec timeSpec;
   double freq = 80.0; //FIXME: HARDCODED Rendering Loop Rate
 
-  this->physicsThread = new boost::thread( 
-                         boost::bind(&Simulator::PhysicsLoop, this));
+  this->StartPhysics();
 
-  // Update the gui
-  while (!this->userQuit)
+  if (this->gui)
+    this->gui->Run();
+  else
   {
-    DIAGNOSTICTIMER(timer("GUI LOOP",6));
-
-    currTime = this->GetWallTime();
-    if ( currTime - lastTime > 1.0/freq)
+    while (!this->userQuit)
     {
-      lastTime = this->GetWallTime();
+      currTime = this->GetWallTime();
+      if ( currTime - lastTime > 1.0/freq)
+      {
+        lastTime = this->GetWallTime();
 
-      if (this->gui && (currTime - lastGuiTime > 1.0/this->gui->GetUpdateRate()))
+        this->GraphicsUpdate();
+        currTime = this->GetWallTime();
+        if (currTime - lastTime < 1/freq)
+        {
+          Time sleepTime = ( Time(1.0/freq) - (currTime - lastTime));
+          timeSpec.tv_sec = sleepTime.sec;
+          timeSpec.tv_nsec = sleepTime.nsec;
+
+          nanosleep(&timeSpec, NULL);
+        }
+      }
+      else
       {
-        lastGuiTime = this->GetWallTime();
-        DIAGNOSTICTIMER(timer1("GUI update",6));
-        this->gui->Update();
+        Time sleepTime = ( Time(1.0/freq) - (currTime - lastTime));
+        timeSpec.tv_sec = sleepTime.sec;
+        timeSpec.tv_nsec = sleepTime.nsec;
+        nanosleep(&timeSpec, NULL);
       }
+    }
+  }
 
+  this->StopPhysics();
+}
+
+void Simulator::GraphicsUpdate()
+{
+  // Update the gui
+  //while (!this->userQuit)
+  //{
+    //currTime = this->GetWallTime();
+    //if ( currTime - lastTime > 1.0/freq)
+    //{
+      //lastTime = this->GetWallTime();
+
+      if (this->gui)
+        this->gui->Update();
+
       if (this->renderEngineEnabled)
       {
-        {
-          DIAGNOSTICTIMER(timer1("GUI Camera update",6));
-          OgreAdaptor::Instance()->UpdateCameras();
-        }
-        {
-          DIAGNOSTICTIMER(timer1("GUI Graphics update",6));
-          World::Instance()->GraphicsUpdate();
-        }
+        OgreAdaptor::Instance()->UpdateScenes();
+        World::Instance()->GraphicsUpdate();
       }
 
-      currTime = this->GetWallTime();
+      //currTime = this->GetWallTime();
 
       {
         DIAGNOSTICTIMER(timer1("GUI Process Entities to Load",6));
@@ -455,7 +504,7 @@
         World::Instance()->ProcessEntitiesToDelete();
       }
 
-      if (currTime - lastTime < 1/freq)
+      /*if (currTime - lastTime < 1/freq)
       {
         Time sleepTime = ( Time(1.0/freq) - (currTime - lastTime));
         timeSpec.tv_sec = sleepTime.sec;
@@ -463,7 +512,6 @@
 
         nanosleep(&timeSpec, NULL);
       }
-
     }
     else
     {
@@ -472,9 +520,9 @@
       timeSpec.tv_nsec = sleepTime.nsec;
       nanosleep(&timeSpec, NULL);
     }
-  }
+    */
+  //}
 
-  this->physicsThread->join();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -602,13 +650,6 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Return true if the gui is enabled
-bool Simulator::GetRenderEngineEnabled() const
-{
-  return this->renderEngineEnabled;
-}
-
-////////////////////////////////////////////////////////////////////////////////
 /// Set the length of time the simulation should run.
 void Simulator::SetTimeout(double time)
 {
@@ -623,13 +664,6 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// Get the physics enabled/disabled
-bool Simulator::GetPhysicsEnabled() const
-{
-  return this->physicsEnabled;
-}
-
-////////////////////////////////////////////////////////////////////////////////
 /// Get the model that contains the entity
 Model *Simulator::GetParentModel( Entity *entity ) const
 {
@@ -640,10 +674,10 @@
 
   do 
   {
-    if (entity && entity->GetType() == Entity::MODEL)
+    if (entity && entity->HasType(MODEL))
       model = (Model*)entity;
 
-    entity = entity->GetParent();
+    entity = dynamic_cast<Entity*>(entity->GetParent());
   } while (model == NULL);
 
   return model;
@@ -660,9 +694,9 @@
 
   do 
   {
-    if (entity && entity->GetType() == Entity::BODY)
+    if (entity && entity->HasType(BODY))
       body = (Body*)(entity);
-    entity = entity->GetParent();
+    entity = dynamic_cast<Entity*>(entity->GetParent());
   } while (body == NULL);
 
   return body;
@@ -685,10 +719,9 @@
   // hack for ROS, since ROS uses t=0 for special purpose
   this->simTime = world->GetPhysicsEngine()->GetStepTime();
 
-  while (!this->userQuit)
+  while (!this->physicsQuit)
   {
     DIAGNOSTICTIMER(timer("PHYSICS LOOP ",6));
-
     {
       DIAGNOSTICTIMER(timer1("PHYSICS MR MD Mutex and world->Update() ",6));
       boost::recursive_mutex::scoped_lock model_render_lock(*this->GetMRMutex());
@@ -742,7 +775,7 @@
       req.tv_nsec = diffTime.nsec;
     }
 
-    nanosleep(&req, &rem);
+    //nanosleep(&req, &rem);
 
     {
       DIAGNOSTICTIMER(timer1("PHYSICS UpdateSimIfaces ",6));
Index: server/main.cc
===================================================================
--- server/main.cc	(revision 8976)
+++ server/main.cc	(working copy)
@@ -111,6 +111,7 @@
 #include "GazeboError.hh"
 #include "Global.hh"
 
+
 // Command line options
 std::string worldFileName = "";
 const char *optLogFileName = NULL;
@@ -124,6 +125,9 @@
 bool optPhysicsEnabled  = true;
 bool optPaused = false;
 
+int global_argc;
+char **global_argv;
+
 ////////////////////////////////////////////////////////////////////////////////
 // TODO: Implement these options
 void PrintUsage()
@@ -247,8 +251,6 @@
 // Main function
 int main(int argc, char **argv)
 {
-
-
   // force a cpu affinity for CPU 0, this slow down sim by about 4X
   // cpu_set_t cpuSet;
   // CPU_ZERO(&cpuSet);
@@ -289,8 +291,8 @@
   // Initialize the simulator
   try
   {
+    gazebo::Simulator::Instance()->SetPaused(optPaused);
     gazebo::Simulator::Instance()->Init();
-    gazebo::Simulator::Instance()->SetPaused(optPaused);
   }
   catch (gazebo::GazeboError e)
   {
@@ -303,7 +305,7 @@
   // Main loop of the simulator
   try
   {
-    gazebo::Simulator::Instance()->MainLoop();
+    gazebo::Simulator::Instance()->Run();
   }
   catch (gazebo::GazeboError e)
   {
@@ -326,5 +328,7 @@
   }
 
   printf("Gazebo done.\n");
+
+  delete [] global_argv;
   return 0;
 }
Index: server/Param.cc
===================================================================
--- server/Param.cc	(revision 8976)
+++ server/Param.cc	(working copy)
@@ -26,6 +26,10 @@
 
 #include "GazeboError.hh"
 #include "Param.hh"
+#include "Quatern.hh"
+#include "Pose3d.hh"
+#include "Vector3.hh"
+#include "Vector4.hh"
 
 using namespace gazebo;
 
@@ -78,3 +82,55 @@
 {
   return this->typeName;
 }
+
+bool Param::IsBool() const
+{
+  return this->GetTypename() == typeid(bool).name();
+}
+
+bool Param::IsInt() const
+{
+  return this->GetTypename() == typeid(int).name();
+}
+
+bool Param::IsUInt() const
+{
+  return this->GetTypename() == typeid(unsigned int).name();
+}
+
+bool Param::IsFloat() const
+{
+  return this->GetTypename() == typeid(float).name();
+}
+
+bool Param::IsDouble() const
+{
+  return this->GetTypename() == typeid(double).name();
+}
+
+bool Param::IsChar() const
+{
+  return this->GetTypename() == typeid(char).name();
+}
+
+bool Param::IsStr() const
+{
+  return this->GetTypename() == typeid(std::string).name();
+}
+
+bool Param::IsVector3() const
+{
+  return this->GetTypename() == typeid(Vector3).name();
+}
+bool Param::IsVector4() const
+{
+  return this->GetTypename() == typeid(Vector4).name();
+}
+bool Param::IsQuatern() const
+{
+  return this->GetTypename() == typeid(Quatern).name();
+}
+bool Param::IsPose3d() const
+{
+  return this->GetTypename() == typeid(Pose3d).name();
+}
Index: server/gui/SpotLightMaker.cc
===================================================================
--- server/gui/SpotLightMaker.cc	(revision 8976)
+++ server/gui/SpotLightMaker.cc	(working copy)
@@ -1,105 +0,0 @@
-#include <iostream>
-#include <FL/Fl.H>
-
-#include "MouseEvent.hh"
-#include "Simulator.hh"
-#include "GLWindow.hh"
-#include "OgreVisual.hh"
-#include "OgreCreator.hh"
-#include "World.hh"
-#include "SpotLightMaker.hh"
-
-using namespace gazebo;
-
-SpotLightMaker::SpotLightMaker()
-  : EntityMaker()
-{
-  this->state = 0;
-  this->lightName = "";
-  this->index = 0;
-}
-
-SpotLightMaker::~SpotLightMaker()
-{
-}
-
-void SpotLightMaker::Start()
-{
-  std::ostringstream stream;
-  std::string name = "user_light";
-
-  do
-  {
-    stream.str("");
-    stream << name << index;
-    this->index++;
-  } while (World::Instance()->GetEntityByName(stream.str()));
-
-  this->lightName = stream.str();
-  this->state = 1;
-}
-
-void SpotLightMaker::Stop()
-{
-  this->state = 0;
-}
-
-bool SpotLightMaker::IsActive() const
-{
-  return this->state > 0;
-}
-
-void SpotLightMaker::MousePushCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  this->mousePushPos = event.pressPos;
-}
-
-void SpotLightMaker::MouseReleaseCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  this->state++;
-
-  this->CreateTheEntity();
-  this->Start();
-}
-
-void SpotLightMaker::MouseDragCB(const MouseEvent & /*event*/)
-{
-}
-
-void SpotLightMaker::CreateTheEntity()
-{
-  boost::recursive_mutex::scoped_lock lock( *Simulator::Instance()->GetMRMutex());
-
-  std::ostringstream newModelStr;
-
-  Vector3 norm;
-  Vector3 p1, p2;
-
-  norm.Set(0,0,1);
-
-  p1 = GLWindow::GetWorldPointOnPlane(this->mousePushPos.x, this->mousePushPos.y, norm, 0);
-
-  newModelStr << "<?xml version='1.0'?> <gazebo:world xmlns:xi='http://www.w3.org/2001/XInclude' xmlns:gazebo='http://playerstage.sourceforge.net/gazebo/xmlschema/#gz' xmlns:model='http://playerstage.sourceforge.net/gazebo/xmlschema/#model' xmlns:sensor='http://playerstage.sourceforge.net/gazebo/xmlschema/#sensor' xmlns:body='http://playerstage.sourceforge.net/gazebo/xmlschema/#body' xmlns:geom='http://playerstage.sourceforge.net/gazebo/xmlschema/#geom' xmlns:joint='http://playerstage.sourceforge.net/gazebo/xmlschema/#joint' xmlns:interface='http://playerstage.sourceforge.net/gazebo/xmlschema/#interface' xmlns:rendering='http://playerstage.sourceforge.net/gazebo/xmlschema/#rendering' xmlns:renderable='http://playerstage.sourceforge.net/gazebo/xmlschema/#renderable' xmlns:controller='http://playerstage.sourceforge.net/gazebo/xmlschema/#controller' xmlns:physics='http://playerstage.sourceforge.net/gazebo/xmlschema/#physics' >";
-
-  newModelStr << "<model:renderable name=\"" << this->lightName << "\">\
-    <xyz>" << p1.x << " " << p1.y << " " << 0.1 << "</xyz>\
-    <static>true</static>\
-    <light>\
-      <type>spot</type>\
-      <specularColor>0.1 0.1 0.1</specularColor>\
-      <diffuseColor>0.8 0.8 0.8</diffuseColor>\
-      <attenuation>0.5 0.01 0</attenuation>\
-      <range>20</range>\
-    </light>\
-    </model:renderable>";
-
-  newModelStr <<  "</gazebo:world>";
-
-  World::Instance()->InsertEntity(newModelStr.str());
-}
Index: server/gui/PointLightMaker.cc
===================================================================
--- server/gui/PointLightMaker.cc	(revision 8976)
+++ server/gui/PointLightMaker.cc	(working copy)
@@ -1,105 +0,0 @@
-#include <iostream>
-#include <FL/Fl.H>
-
-#include "MouseEvent.hh"
-#include "Simulator.hh"
-#include "GLWindow.hh"
-#include "OgreVisual.hh"
-#include "OgreCreator.hh"
-#include "World.hh"
-#include "PointLightMaker.hh"
-
-using namespace gazebo;
-
-PointLightMaker::PointLightMaker()
-  : EntityMaker()
-{
-  this->state = 0;
-  this->lightName = "";
-  this->index = 0;
-}
-
-PointLightMaker::~PointLightMaker()
-{
-}
-
-void PointLightMaker::Start()
-{
-  std::ostringstream stream;
-  std::string name = "user_light";
-
-  do
-  {
-    stream.str("");
-    stream << name << index;
-    this->index++;
-  } while (World::Instance()->GetEntityByName(stream.str()));
-
-  this->lightName = stream.str();
-  this->state = 1;
-}
-
-void PointLightMaker::Stop()
-{
-  this->state = 0;
-}
-
-bool PointLightMaker::IsActive() const
-{
-  return this->state > 0;
-}
-
-void PointLightMaker::MousePushCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  this->mousePushPos = event.pressPos;
-}
-
-void PointLightMaker::MouseReleaseCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  this->state++;
-
-  this->CreateTheEntity();
-  this->Start();
-}
-
-void PointLightMaker::MouseDragCB(const MouseEvent & /*event*/)
-{
-}
-
-void PointLightMaker::CreateTheEntity()
-{
-  boost::recursive_mutex::scoped_lock lock( *Simulator::Instance()->GetMRMutex());
-
-  std::ostringstream newModelStr;
-
-  Vector3 norm;
-  Vector3 p1, p2;
-
-  norm.Set(0,0,1);
-
-  p1 = GLWindow::GetWorldPointOnPlane(this->mousePushPos.x, this->mousePushPos.y, norm, 0);
-
-  newModelStr << "<?xml version='1.0'?> <gazebo:world xmlns:xi='http://www.w3.org/2001/XInclude' xmlns:gazebo='http://playerstage.sourceforge.net/gazebo/xmlschema/#gz' xmlns:model='http://playerstage.sourceforge.net/gazebo/xmlschema/#model' xmlns:sensor='http://playerstage.sourceforge.net/gazebo/xmlschema/#sensor' xmlns:body='http://playerstage.sourceforge.net/gazebo/xmlschema/#body' xmlns:geom='http://playerstage.sourceforge.net/gazebo/xmlschema/#geom' xmlns:joint='http://playerstage.sourceforge.net/gazebo/xmlschema/#joint' xmlns:interface='http://playerstage.sourceforge.net/gazebo/xmlschema/#interface' xmlns:rendering='http://playerstage.sourceforge.net/gazebo/xmlschema/#rendering' xmlns:renderable='http://playerstage.sourceforge.net/gazebo/xmlschema/#renderable' xmlns:controller='http://playerstage.sourceforge.net/gazebo/xmlschema/#controller' xmlns:physics='http://playerstage.sourceforge.net/gazebo/xmlschema/#physics' >";
-
-  newModelStr << "<model:renderable name=\"" << this->lightName << "\">\
-    <xyz>" << p1.x << " " << p1.y << " " << 0.2 << "</xyz>\
-    <static>true</static>\
-    <light>\
-      <type>point</type>\
-      <specularColor>0.1 0.1 0.1</specularColor>\
-      <diffuseColor>0.5 0.5 0.5</diffuseColor>\
-      <attenuation>0.5 0.01 0.001</attenuation>\
-      <range>20</range>\
-    </light>\
-    </model:renderable>";
-
-  newModelStr <<  "</gazebo:world>";
-
-  World::Instance()->InsertEntity(newModelStr.str());
-}
Index: server/gui/gazebo_logo.svg
===================================================================
--- server/gui/gazebo_logo.svg	(revision 8976)
+++ server/gui/gazebo_logo.svg	(working copy)
@@ -1,386 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="744.09448819"
-   height="1052.3622047"
-   id="svg2"
-   sodipodi:version="0.32"
-   inkscape:version="0.46"
-   sodipodi:docname="gazebo_logo.svg"
-   inkscape:output_extension="org.inkscape.output.svg.inkscape">
-  <defs
-     id="defs4">
-    <linearGradient
-       id="linearGradient3230">
-      <stop
-         style="stop-color:#787878;stop-opacity:1;"
-         offset="0"
-         id="stop3232" />
-      <stop
-         id="stop3238"
-         offset="0.94999999"
-         style="stop-color:#787878;stop-opacity:1;" />
-      <stop
-         style="stop-color:#ffffff;stop-opacity:1;"
-         offset="1"
-         id="stop3234" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient3222">
-      <stop
-         id="stop3224"
-         offset="0"
-         style="stop-color:#ffffff;stop-opacity:1;" />
-      <stop
-         style="stop-color:#ffffff;stop-opacity:1;"
-         offset="0.86726522"
-         id="stop3228" />
-      <stop
-         id="stop3226"
-         offset="1"
-         style="stop-color:#000000;stop-opacity:1;" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient3212">
-      <stop
-         style="stop-color:#000000;stop-opacity:1;"
-         offset="0"
-         id="stop3214" />
-      <stop
-         style="stop-color:#000000;stop-opacity:0;"
-         offset="1"
-         id="stop3216" />
-    </linearGradient>
-    <inkscape:perspective
-       sodipodi:type="inkscape:persp3d"
-       inkscape:vp_x="0 : 526.18109 : 1"
-       inkscape:vp_y="0 : 1000 : 0"
-       inkscape:vp_z="744.09448 : 526.18109 : 1"
-       inkscape:persp3d-origin="372.04724 : 350.78739 : 1"
-       id="perspective10" />
-  </defs>
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     gridtolerance="10000"
-     guidetolerance="10"
-     objecttolerance="10"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="2"
-     inkscape:cx="470.8547"
-     inkscape:cy="763.87292"
-     inkscape:document-units="px"
-     inkscape:current-layer="layer1"
-     showgrid="false"
-     showguides="true"
-     inkscape:guide-bbox="true"
-     inkscape:window-width="2550"
-     inkscape:window-height="1379"
-     inkscape:window-x="0"
-     inkscape:window-y="25" />
-  <metadata
-     id="metadata7">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1">
-    <g
-       id="g3485"
-       transform="translate(-445.16531,338.56519)">
-      <path
-         id="path3402"
-         d="M 605.9852,65.691719 C 591.91611,65.492869 578.94959,74.805949 575.07895,89.00422 C 570.49155,105.8318 580.40761,123.19806 597.2352,127.78547 C 614.06277,132.37287 631.46029,122.42555 636.0477,105.59797 C 640.6351,88.77038 630.68776,71.404119 613.8602,66.816719 C 611.23089,66.099939 608.59059,65.728539 605.9852,65.691719 z M 589.6727,81.50422 C 590.62321,81.50425 591.54248,81.58498 592.45395,81.75422 C 593.36539,81.9105 594.17528,82.10581 594.89145,82.37922 C 595.60757,82.65269 596.28987,82.98342 596.95395,83.34797 C 597.63101,83.69956 598.22216,84.08238 598.70395,84.47297 C 599.1857,84.8506 599.63622,85.22039 600.07895,85.59797 C 600.52163,85.9756 600.881,86.33498 601.14145,86.66047 C 601.40184,86.98602 601.63881,87.25684 601.8602,87.50422 C 602.08152,87.73862 602.22736,87.91309 602.26645,88.00422 L 599.7977,89.84797 C 599.44611,89.40529 599.17528,89.0459 598.95395,88.78547 C 598.73257,88.52508 598.26903,88.08497 597.57895,87.47297 C 596.90184,86.86102 596.21174,86.36883 595.5477,86.00422 C 594.88362,85.62664 594.02163,85.2855 592.95395,84.97297 C 591.89924,84.6605 590.81852,84.50425 589.6727,84.50422 C 588.01904,84.50425 586.42008,84.81675 584.9227,85.44172 C 583.4253,86.06675 582.15967,86.91831 581.07895,87.97297 C 579.99822,89.02768 579.12321,90.28288 578.4852,91.75422 C 577.86019,93.21258 577.54769,94.73341 577.5477,96.34798 C 577.54769,97.94956 577.86019,99.48338 578.4852,100.94172 C 579.12321,102.40006 579.97999,103.65527 581.0477,104.72297 C 582.12842,105.77766 583.42529,106.62922 584.9227,107.25422 C 586.4331,107.87922 588.01904,108.19172 589.6727,108.19172 C 592.73258,108.19172 595.3758,107.20214 597.64145,105.22297 C 599.92006,103.23079 601.26382,100.77766 601.64145,97.84798 L 588.95395,97.84798 L 588.95395,94.81673 L 612.6102,94.81673 L 594.82895,120.97297 L 612.64145,120.97297 L 611.64145,123.97297 L 589.07895,123.97297 L 601.89145,105.09797 C 601.42713,105.72269 600.92087,106.30865 600.3602,106.84797 C 599.00601,108.16308 597.39142,109.22298 595.51645,110.00422 C 593.65445,110.78548 591.71696,111.16047 589.6727,111.16047 C 587.6154,111.16047 585.6232,110.78548 583.7352,110.00422 C 581.86019,109.22298 580.25863,108.16308 578.89145,106.84797 C 577.53728,105.53287 576.44873,103.95215 575.64145,102.12922 C 574.83415,100.29329 574.4227,98.36621 574.4227,96.34798 C 574.4227,94.32977 574.83415,92.40267 575.64145,90.56672 C 576.44873,88.73081 577.53728,87.14487 578.89145,85.81672 C 580.25863,84.48862 581.86019,83.44175 583.7352,82.66047 C 585.6232,81.87925 587.6154,81.50425 589.6727,81.50422 z M 604.7352,97.81673 C 604.58594,99.30718 604.21983,100.74275 603.6102,102.12922 C 603.29336,102.85638 602.92445,103.54537 602.51645,104.19172 L 606.82895,97.81673 L 604.7352,97.81673 z"
-         style="fill:#941515;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-    </g>
-    <g
-       id="g3253"
-       transform="translate(-161.69682,172.32361)">
-      <path
-         transform="matrix(0.9026008,0,0,0.9026008,-149.63385,-8.6861134)"
-         d="M 459.04156,114.376 A 35.006859,35.006859 0 1 1 389.02784,114.376 A 35.006859,35.006859 0 1 1 459.04156,114.376 z"
-         sodipodi:ry="35.006859"
-         sodipodi:rx="35.006859"
-         sodipodi:cy="114.376"
-         sodipodi:cx="424.0347"
-         id="path3194"
-         style="opacity:1;fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:5.53954744;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
-         sodipodi:type="arc" />
-      <path
-         sodipodi:nodetypes="cccsscccscscccccccccsssccscsssssssccsssscscccccsc"
-         id="text3181"
-         d="M 218.96334,79.919423 C 216.90604,79.919453 214.91384,80.294452 213.02584,81.075673 C 211.15083,81.856951 209.54927,82.903824 208.18209,84.231923 C 206.82792,85.560071 205.73937,87.146008 204.93209,88.981923 C 204.12479,90.817879 203.71334,92.744961 203.71334,94.763173 C 203.71334,96.781413 204.12479,98.708503 204.93209,100.54442 C 205.73937,102.36735 206.82792,103.94807 208.18209,105.26317 C 209.54927,106.57828 211.15083,107.63818 213.02584,108.41942 C 214.91384,109.20068 216.90604,109.57567 218.96334,109.57567 C 221.0076,109.57567 222.94509,109.20068 224.80709,108.41942 C 226.68206,107.63818 228.29665,106.57828 229.65084,105.26317 C 230.21151,104.72385 230.71777,104.13789 231.18209,103.51317 L 218.36959,122.38817 L 240.93209,122.38817 L 241.93209,119.38817 L 224.11959,119.38817 L 241.90084,93.231923 L 218.24459,93.231923 L 218.24459,96.263173 L 230.93209,96.263173 C 230.55446,99.192873 229.2107,101.64599 226.93209,103.63817 C 224.66644,105.61734 222.02322,106.60692 218.96334,106.60692 C 217.30968,106.60692 215.72374,106.29442 214.21334,105.66942 C 212.71593,105.04442 211.41906,104.19286 210.33834,103.13817 C 209.27063,102.07047 208.41385,100.81526 207.77584,99.356923 C 207.15083,97.898593 206.83833,96.364753 206.83834,94.763173 C 206.83833,93.148606 207.15083,91.627774 207.77584,90.169423 C 208.41385,88.69809 209.28886,87.442882 210.36959,86.388173 C 211.45031,85.333509 212.71594,84.481948 214.21334,83.856923 C 215.71072,83.231949 217.30968,82.919449 218.96334,82.919423 C 220.10916,82.919449 221.18988,83.075699 222.24459,83.388173 C 223.31227,83.700698 224.17426,84.041844 224.83834,84.419423 C 225.50238,84.784031 226.19248,85.276218 226.86959,85.888173 C 227.55967,86.500175 228.02321,86.940279 228.24459,87.200673 C 228.46592,87.461112 228.73675,87.820486 229.08834,88.263173 L 231.55709,86.419423 C 231.518,86.328301 231.37216,86.153821 231.15084,85.919423 C 230.92945,85.672051 230.69248,85.401218 230.43209,85.075673 C 230.17164,84.750177 229.81227,84.390802 229.36959,84.013173 C 228.92686,83.635594 228.47634,83.265803 227.99459,82.888173 C 227.5128,82.497575 226.92165,82.114763 226.24459,81.763173 C 225.58051,81.398618 224.89821,81.067888 224.18209,80.794423 C 223.46592,80.521014 222.65603,80.325702 221.74459,80.169423 C 220.83312,80.000182 219.91385,79.919453 218.96334,79.919423 z M 234.02584,96.231923 L 236.11959,96.231923 L 231.80709,102.60692 C 232.21509,101.96057 232.584,101.27158 232.90084,100.54442 C 233.51047,99.157963 233.87658,97.722373 234.02584,96.231923 z"
-         style="font-size:40px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;font-family:Interstate;-inkscape-font-specification:Sans" />
-    </g>
-    <g
-       id="g3450"
-       transform="translate(-233.08836,324.11331)">
-      <path
-         transform="matrix(0.8708221,0.2373968,-0.2373968,0.8708221,-37.61454,-105.71587)"
-         d="M 459.04156,114.376 A 35.006859,35.006859 0 1 1 389.02784,114.376 A 35.006859,35.006859 0 1 1 459.04156,114.376 z"
-         sodipodi:ry="35.006859"
-         sodipodi:rx="35.006859"
-         sodipodi:cy="114.376"
-         sodipodi:cx="424.0347"
-         id="path3202"
-         style="fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:3.32372808;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
-         sodipodi:type="arc" />
-      <path
-         sodipodi:nodetypes="cccsscccscscccccccccsssccscsssssssccsssscscccccsc"
-         id="path3204"
-         d="M 289.5079,78.296112 C 287.4506,78.296142 285.4584,78.671142 283.5704,79.452362 C 281.69539,80.233642 280.09383,81.280512 278.72665,82.608612 C 277.37248,83.936762 276.28393,85.522702 275.47665,87.358612 C 274.66935,89.194572 274.2579,91.121652 274.2579,93.139862 C 274.2579,95.158102 274.66935,97.085192 275.47665,98.921117 C 276.28393,100.74405 277.37248,102.32477 278.72665,103.63987 C 280.09383,104.95498 281.69539,106.01488 283.5704,106.79612 C 285.4584,107.57738 287.4506,107.95237 289.5079,107.95237 C 291.55216,107.95237 293.48965,107.57738 295.35165,106.79612 C 297.22662,106.01488 298.84121,104.95498 300.1954,103.63987 C 300.75607,103.10055 301.26233,102.51459 301.72665,101.88987 L 288.91415,120.76487 L 311.47665,120.76487 L 312.47665,117.76487 L 294.66415,117.76487 L 312.4454,91.608612 L 288.78915,91.608612 L 288.78915,94.639862 L 301.47665,94.639862 C 301.09902,97.569562 299.75526,100.02269 297.47665,102.01487 C 295.211,103.99404 292.56778,104.98362 289.5079,104.98362 C 287.85424,104.98362 286.2683,104.67112 284.7579,104.04612 C 283.26049,103.42112 281.96362,102.56956 280.8829,101.51487 C 279.81519,100.44717 278.95841,99.191957 278.3204,97.733612 C 277.69539,96.275282 277.38289,94.741442 277.3829,93.139862 C 277.38289,91.525302 277.69539,90.004462 278.3204,88.546112 C 278.95841,87.074782 279.83342,85.819572 280.91415,84.764862 C 281.99487,83.710202 283.2605,82.858642 284.7579,82.233612 C 286.25528,81.608642 287.85424,81.296142 289.5079,81.296112 C 290.65372,81.296142 291.73444,81.452392 292.78915,81.764862 C 293.85683,82.077392 294.71882,82.418532 295.3829,82.796112 C 296.04694,83.160722 296.73704,83.652912 297.41415,84.264862 C 298.10423,84.876872 298.56777,85.316972 298.78915,85.577362 C 299.01048,85.837802 299.28131,86.197182 299.6329,86.639862 L 302.10165,84.796112 C 302.06256,84.704992 301.91672,84.530512 301.6954,84.296112 C 301.47401,84.048742 301.23704,83.777912 300.97665,83.452362 C 300.7162,83.126872 300.35683,82.767492 299.91415,82.389862 C 299.47142,82.012282 299.0209,81.642492 298.53915,81.264862 C 298.05736,80.874272 297.46621,80.491452 296.78915,80.139862 C 296.12507,79.775312 295.44277,79.444582 294.72665,79.171112 C 294.01048,78.897702 293.20059,78.702392 292.28915,78.546112 C 291.37768,78.376872 290.45841,78.296142 289.5079,78.296112 z M 304.5704,94.608612 L 306.66415,94.608612 L 302.35165,100.98362 C 302.75965,100.33727 303.12856,99.648277 303.4454,98.921117 C 304.05503,97.534652 304.42114,96.099062 304.5704,94.608612 z"
-         style="font-size:40px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;fill:#225090;fill-opacity:1;stroke:#edaf00;stroke-width:0.5;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;font-family:Interstate;-inkscape-font-specification:Sans" />
-    </g>
-    <g
-       id="g3458"
-       transform="translate(-308.28474,473.11291)">
-      <path
-         id="path3247"
-         d="M 411.82737,103.3113 C 406.99099,121.05217 388.66743,131.52537 370.92658,126.68899 C 353.18571,121.85262 342.71251,103.52907 347.54889,85.788205 C 352.38526,68.047343 370.70881,57.574137 388.44967,62.410513 C 406.19053,67.246886 416.66374,85.57044 411.82737,103.3113 z"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:3.16281843;stroke-miterlimit:4;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         id="path3240"
-         d="M 380.11113,62.945434 C 366.04204,62.746584 353.07552,72.059664 349.20488,86.257934 C 344.61748,103.08552 354.53354,120.45178 371.36113,125.03919 C 388.1887,129.62659 405.58622,119.67927 410.17363,102.85169 C 414.76103,86.024094 404.81369,68.657834 387.98613,64.070434 C 385.35682,63.353654 382.71652,62.982254 380.11113,62.945434 z M 363.79863,78.757934 C 364.74914,78.757964 365.66841,78.838694 366.57988,79.007934 C 367.49132,79.164214 368.30121,79.359524 369.01738,79.632934 C 369.7335,79.906404 370.4158,80.237134 371.07988,80.601684 C 371.75694,80.953274 372.34809,81.336094 372.82988,81.726684 C 373.31163,82.104314 373.76215,82.474104 374.20488,82.851684 C 374.64756,83.229314 375.00693,83.588694 375.26738,83.914184 C 375.52777,84.239734 375.76474,84.510554 375.98613,84.757934 C 376.20745,84.992334 376.35329,85.166804 376.39238,85.257934 L 373.92363,87.101684 C 373.57204,86.659004 373.30121,86.299614 373.07988,86.039184 C 372.8585,85.778794 372.39496,85.338684 371.70488,84.726684 C 371.02777,84.114734 370.33767,83.622544 369.67363,83.257934 C 369.00955,82.880354 368.14756,82.539214 367.07988,82.226684 C 366.02517,81.914214 364.94445,81.757964 363.79863,81.757934 C 362.14497,81.757964 360.54601,82.070464 359.04863,82.695434 C 357.55123,83.320464 356.2856,84.172024 355.20488,85.226684 C 354.12415,86.281394 353.24914,87.536594 352.61113,89.007934 C 351.98612,90.466287 351.67362,91.987117 351.67363,93.601687 C 351.67362,95.203267 351.98612,96.737097 352.61113,98.195437 C 353.24914,99.653777 354.10592,100.90899 355.17363,101.97669 C 356.25435,103.03138 357.55122,103.88294 359.04863,104.50794 C 360.55903,105.13294 362.14497,105.44544 363.79863,105.44544 C 366.85851,105.44544 369.50173,104.45586 371.76738,102.47669 C 374.04599,100.48451 375.38975,98.031377 375.76738,95.101687 L 363.07988,95.101687 L 363.07988,92.070437 L 386.73613,92.070437 L 368.95488,118.22669 L 386.76738,118.22669 L 385.76738,121.22669 L 363.20488,121.22669 L 376.01738,102.35169 C 375.55306,102.97641 375.0468,103.56237 374.48613,104.10169 C 373.13194,105.4168 371.51735,106.4767 369.64238,107.25794 C 367.78038,108.0392 365.84289,108.41419 363.79863,108.41419 C 361.74133,108.41419 359.74913,108.0392 357.86113,107.25794 C 355.98612,106.4767 354.38456,105.4168 353.01738,104.10169 C 351.66321,102.78659 350.57466,101.20587 349.76738,99.382937 C 348.96008,97.547007 348.54863,95.619917 348.54863,93.601687 C 348.54863,91.583477 348.96008,89.656384 349.76738,87.820434 C 350.57466,85.984524 351.66321,84.398584 353.01738,83.070434 C 354.38456,81.742334 355.98612,80.695464 357.86113,79.914184 C 359.74913,79.132964 361.74133,78.757964 363.79863,78.757934 z M 378.86113,95.070437 C 378.71187,96.560887 378.34576,97.996467 377.73613,99.382937 C 377.41929,100.1101 377.05038,100.79909 376.64238,101.44544 L 380.95488,95.070437 L 378.86113,95.070437 z"
-         style="fill:#225090;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-    </g>
-    <g
-       id="g3480"
-       transform="translate(-371.66536,260.55443)">
-      <path
-         id="path3350"
-         d="M 532.22925,63.39484 C 531.99066,63.393791 531.75255,63.395275 531.51157,63.401996 L 531.51157,63.401996 C 529.45913,63.459237 527.42394,63.726051 525.44907,64.151996 C 520.67277,72.133159 512.77947,77.665589 503.85532,79.589496 C 502.32398,82.145316 501.11456,84.950147 500.29282,87.964496 C 495.45644,105.70536 505.92694,124.03438 523.66782,128.87074 C 530.60797,130.76271 537.64164,130.30811 543.91782,127.99574 C 542.83014,122.94848 542.90441,117.568 544.35532,112.24574 C 547.29971,101.44503 555.24417,93.344402 565.01157,89.745746 C 564.56483,87.672692 563.92232,85.654887 563.09907,83.718649"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:3.16281843;stroke-miterlimit:4;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         id="path3312"
-         d="M 563.44768,83.141912 C 559.5941,74.07847 551.78028,66.802289 541.54768,64.012759 C 538.77567,63.257076 535.98197,62.864082 533.23518,62.825259 C 533.01395,62.822132 532.7957,62.819062 532.57786,62.818103"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         id="path3314"
-         d="M 532.86603,65.12709 C 518.79694,64.92824 505.83042,74.24132 501.95978,88.43959 C 497.37238,105.26717 507.28844,122.63343 524.11603,127.22084 C 540.9436,131.80824 558.34112,121.86092 562.92853,105.03334 C 567.51593,88.20575 557.56859,70.83949 540.74103,66.25209 C 538.11172,65.53531 535.47142,65.16391 532.86603,65.12709 z M 516.55353,80.93959 C 517.50404,80.93962 518.42331,81.02035 519.33478,81.18959 C 520.24622,81.34587 521.05611,81.54118 521.77228,81.81459 C 522.4884,82.08806 523.1707,82.41879 523.83478,82.78334 C 524.51184,83.13493 525.10299,83.51775 525.58478,83.90834 C 526.06653,84.28597 526.51705,84.65576 526.95978,85.03334 C 527.40246,85.41097 527.76183,85.77035 528.02228,86.09584 C 528.28267,86.42139 528.51964,86.69221 528.74103,86.93959 C 528.96235,87.17399 529.10819,87.34846 529.14728,87.43959 L 526.67853,89.28334 C 526.32694,88.84066 526.05611,88.48127 525.83478,88.22084 C 525.6134,87.96045 525.14986,87.52034 524.45978,86.90834 C 523.78267,86.29639 523.09257,85.8042 522.42853,85.43959 C 521.76445,85.06201 520.90246,84.72087 519.83478,84.40834 C 518.78007,84.09587 517.69935,83.93962 516.55353,83.93959 C 514.89987,83.93962 513.30091,84.25212 511.80353,84.87709 C 510.30613,85.50212 509.0405,86.35368 507.95978,87.40834 C 506.87905,88.46305 506.00404,89.71825 505.36603,91.18959 C 504.74102,92.64795 504.42852,94.16878 504.42853,95.78335 C 504.42852,97.384933 504.74102,98.918753 505.36603,100.37709 C 506.00404,101.83543 506.86082,103.09064 507.92853,104.15834 C 509.00925,105.21303 510.30612,106.06459 511.80353,106.68959 C 513.31393,107.31459 514.89987,107.62709 516.55353,107.62709 C 519.61341,107.62709 522.25663,106.63751 524.52228,104.65834 C 526.80089,102.66616 528.14465,100.21303 528.52228,97.283353 L 515.83478,97.283353 L 515.83478,94.2521 L 539.49103,94.2521 L 521.70978,120.40834 L 539.52228,120.40834 L 538.52228,123.40834 L 515.95978,123.40834 L 528.77228,104.53334 C 528.30796,105.15806 527.8017,105.74402 527.24103,106.28334 C 525.88684,107.59845 524.27225,108.65835 522.39728,109.43959 C 520.53528,110.22085 518.59779,110.59584 516.55353,110.59584 C 514.49623,110.59584 512.50403,110.22085 510.61603,109.43959 C 508.74102,108.65835 507.13946,107.59845 505.77228,106.28334 C 504.41811,104.96824 503.32956,103.38752 502.52228,101.56459 C 501.71498,99.728663 501.30353,97.801583 501.30353,95.78335 C 501.30353,93.76514 501.71498,91.83804 502.52228,90.00209 C 503.32956,88.16618 504.41811,86.58024 505.77228,85.25209 C 507.13946,83.92399 508.74102,82.87712 510.61603,82.09584 C 512.50403,81.31462 514.49623,80.93962 516.55353,80.93959 z M 531.61603,97.252103 C 531.46677,98.742553 531.10066,100.17812 530.49103,101.56459 C 530.17419,102.29175 529.80528,102.98074 529.39728,103.62709 L 533.70978,97.252103 L 531.61603,97.252103 z"
-         style="fill:#225090;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-    </g>
-    <g
-       id="g3475"
-       transform="translate(-379.38629,99.806596)">
-      <path
-         id="path3352"
-         d="M 539.95018,145.55765 C 539.71159,145.5566 539.47348,145.55808 539.2325,145.56481 L 539.2325,145.56481 C 537.18006,145.62205 535.14487,145.88886 533.17,146.31481 C 528.3937,154.29597 520.5004,159.8284 511.57625,161.75231 C 510.04491,164.30813 508.83549,167.11296 508.01375,170.12731 C 503.17737,187.86819 513.64787,206.19721 531.38875,211.03357 C 538.3289,212.92554 545.36257,212.47094 551.63875,210.15857 C 550.55107,205.11131 550.62534,199.73083 552.07625,194.40857 C 555.02064,183.60786 562.9651,175.50721 572.7325,171.90856 C 572.28576,169.8355 571.64325,167.8177 570.82,165.88146"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:3.16281843;stroke-miterlimit:4;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         sodipodi:nodetypes="cc"
-         id="path3354"
-         d="M 570.07893,166.7284 C 564.87646,154.41715 553.49589,146.59217 539.93701,146.62348"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:1;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         id="path3356"
-         d="M 540.58696,147.2899 C 526.51787,147.09105 513.55135,156.40413 509.68071,170.6024 C 505.09331,187.43 515.00937,204.79626 531.83696,209.38367 C 548.66453,213.97107 566.06205,204.02375 570.64946,187.19617 C 575.23686,170.36856 565.28952,153.0023 548.46196,148.4149 C 545.83265,147.69812 543.19235,147.32672 540.58696,147.2899 z M 524.27446,163.1024 C 525.22497,163.10243 526.14424,163.18316 527.05571,163.3524 C 527.96715,163.50868 528.77704,163.70399 529.49321,163.9774 C 530.20933,164.25087 530.89163,164.5816 531.55571,164.94615 C 532.23277,165.29774 532.82392,165.68056 533.30571,166.07115 C 533.78746,166.44878 534.23798,166.81857 534.68071,167.19615 C 535.12339,167.57378 535.48276,167.93316 535.74321,168.25865 C 536.0036,168.5842 536.24057,168.85502 536.46196,169.1024 C 536.68328,169.3368 536.82912,169.51127 536.86821,169.6024 L 534.39946,171.44615 C 534.04787,171.00347 533.77704,170.64408 533.55571,170.38365 C 533.33433,170.12326 532.87079,169.68315 532.18071,169.07115 C 531.5036,168.4592 530.8135,167.96701 530.14946,167.6024 C 529.48538,167.22482 528.62339,166.88368 527.55571,166.57115 C 526.501,166.25868 525.42028,166.10243 524.27446,166.1024 C 522.6208,166.10243 521.02184,166.41493 519.52446,167.0399 C 518.02706,167.66493 516.76143,168.51649 515.68071,169.57115 C 514.59998,170.62586 513.72497,171.88106 513.08696,173.3524 C 512.46195,174.81076 512.14945,176.33159 512.14946,177.94616 C 512.14945,179.54774 512.46195,181.08157 513.08696,182.53991 C 513.72497,183.99826 514.58175,185.25347 515.64946,186.32117 C 516.73018,187.37586 518.02705,188.22742 519.52446,188.85242 C 521.03486,189.47742 522.6208,189.78992 524.27446,189.78992 C 527.33434,189.78992 529.97756,188.80034 532.24321,186.82117 C 534.52182,184.82899 535.86558,182.37585 536.24321,179.44616 L 523.55571,179.44616 L 523.55571,176.41491 L 547.21196,176.41491 L 529.43071,202.57117 L 547.24321,202.57117 L 546.24321,205.57117 L 523.68071,205.57117 L 536.49321,186.69617 C 536.02889,187.32089 535.52263,187.90685 534.96196,188.44617 C 533.60777,189.76128 531.99318,190.82118 530.11821,191.60242 C 528.25621,192.38368 526.31872,192.75867 524.27446,192.75867 C 522.21716,192.75867 520.22496,192.38368 518.33696,191.60242 C 516.46195,190.82118 514.86039,189.76128 513.49321,188.44617 C 512.13904,187.13107 511.05049,185.55035 510.24321,183.72742 C 509.43591,181.89148 509.02446,179.96439 509.02446,177.94616 C 509.02446,175.92795 509.43591,174.00085 510.24321,172.1649 C 511.05049,170.32899 512.13904,168.74305 513.49321,167.4149 C 514.86039,166.0868 516.46195,165.03993 518.33696,164.25865 C 520.22496,163.47743 522.21716,163.10243 524.27446,163.1024 z M 539.33696,179.41491 C 539.1877,180.90536 538.82159,182.34094 538.21196,183.72742 C 537.89512,184.45458 537.52621,185.14357 537.11821,185.78992 L 541.43071,179.41491 L 539.33696,179.41491 z"
-         style="fill:#941515;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-    </g>
-    <g
-       id="g3466"
-       transform="translate(-291.8558,26.48363)">
-      <path
-         sodipodi:nodetypes="ccccssccc"
-         id="path3360"
-         d="M 452.99767,61.71058 C 452.75908,61.70953 452.52097,61.71101 452.27999,61.71773 L 452.27999,61.71773 C 440.47736,63.454776 440.02589,73.243643 424.62374,77.90523 C 423.0924,80.46105 421.88298,83.26588 421.06124,86.28023 C 416.22486,104.0211 426.69536,122.35012 444.43624,127.18648 C 451.37639,129.07845 458.41006,128.62385 464.68624,126.31148 C 463.59856,121.26422 463.67283,115.88374 465.12374,110.56148 C 467.908,92.111465 488.82415,94.331223 483.86749,82.03438"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:3.16281843;stroke-miterlimit:4;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         id="path3362"
-         d="M 484.2161,81.45765 C 480.36252,72.39421 472.5487,65.11802 462.3161,62.32849 C 459.54409,61.57281 456.75039,61.17982 454.0036,61.14099 C 453.78237,61.13787 453.56412,61.1348 453.34628,61.13384"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         id="path3364"
-         d="M 453.63445,63.44283 C 439.56536,63.24398 426.59884,72.55706 422.7282,86.75533 C 418.1408,103.58291 428.05686,120.94917 444.88445,125.53658 C 461.71202,130.12398 479.10954,120.17666 483.69695,103.34908 C 488.28435,86.52149 478.33701,69.15523 461.50945,64.56783 C 458.88014,63.85105 456.23984,63.47965 453.63445,63.44283 z M 437.32195,79.25533 C 438.27246,79.25536 439.19173,79.33609 440.1032,79.50533 C 441.01464,79.66161 441.82453,79.85692 442.5407,80.13033 C 443.25682,80.4038 443.93912,80.73453 444.6032,81.09908 C 445.28026,81.45067 445.87141,81.83349 446.3532,82.22408 C 446.83495,82.60171 447.28547,82.9715 447.7282,83.34908 C 448.17088,83.72671 448.53025,84.08609 448.7907,84.41158 C 449.05109,84.73713 449.28806,85.00795 449.50945,85.25533 C 449.73077,85.48973 449.87661,85.6642 449.9157,85.75533 L 447.44695,87.59908 C 447.09536,87.1564 446.82453,86.79701 446.6032,86.53658 C 446.38182,86.27619 445.91828,85.83608 445.2282,85.22408 C 444.55109,84.61213 443.86099,84.11994 443.19695,83.75533 C 442.53287,83.37775 441.67088,83.03661 440.6032,82.72408 C 439.54849,82.41161 438.46777,82.25536 437.32195,82.25533 C 435.66829,82.25536 434.06933,82.56786 432.57195,83.19283 C 431.07455,83.81786 429.80892,84.66942 428.7282,85.72408 C 427.64747,86.77879 426.77246,88.03399 426.13445,89.50533 C 425.50944,90.96369 425.19694,92.48452 425.19695,94.09909 C 425.19694,95.70067 425.50944,97.23449 426.13445,98.69283 C 426.77246,100.15117 427.62924,101.40638 428.69695,102.47408 C 429.77767,103.52877 431.07454,104.38033 432.57195,105.00533 C 434.08235,105.63033 435.66829,105.94283 437.32195,105.94283 C 440.38183,105.94283 443.02505,104.95325 445.2907,102.97408 C 447.56931,100.9819 448.91307,98.52877 449.2907,95.59909 L 436.6032,95.59909 L 436.6032,92.56784 L 460.25945,92.56784 L 442.4782,118.72408 L 460.2907,118.72408 L 459.2907,121.72408 L 436.7282,121.72408 L 449.5407,102.84908 C 449.07638,103.4738 448.57012,104.05976 448.00945,104.59908 C 446.65526,105.91419 445.04067,106.97409 443.1657,107.75533 C 441.3037,108.53659 439.36621,108.91158 437.32195,108.91158 C 435.26465,108.91158 433.27245,108.53659 431.38445,107.75533 C 429.50944,106.97409 427.90788,105.91419 426.5407,104.59908 C 425.18653,103.28398 424.09798,101.70326 423.2907,99.88033 C 422.4834,98.0444 422.07195,96.11732 422.07195,94.09909 C 422.07195,92.08088 422.4834,90.15378 423.2907,88.31783 C 424.09798,86.48192 425.18653,84.89598 426.5407,83.56783 C 427.90788,82.23973 429.50944,81.19286 431.38445,80.41158 C 433.27245,79.63036 435.26465,79.25536 437.32195,79.25533 z M 452.38445,95.56784 C 452.23519,97.05829 451.86908,98.49386 451.25945,99.88033 C 450.94261,100.60749 450.5737,101.29648 450.1657,101.94283 L 454.4782,95.56784 L 452.38445,95.56784 z"
-         style="fill:#225090;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-    </g>
-    <g
-       id="g3444"
-       transform="translate(-160.65821,167.37478)">
-      <path
-         transform="matrix(1.0655738,0,0,1.0765027,-22.432343,73.091491)"
-         d="M 260.29293,96.307938 A 25.831675,25.831675 0 1 1 208.62958,96.307938 A 25.831675,25.831675 0 1 1 260.29293,96.307938 z"
-         sodipodi:ry="25.831675"
-         sodipodi:rx="25.831675"
-         sodipodi:cy="96.307938"
-         sodipodi:cx="234.46126"
-         id="path3404"
-         style="opacity:1;fill:#941515;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
-         sodipodi:type="arc" />
-      <path
-         sodipodi:nodetypes="cssccc"
-         id="path3372"
-         d="M 204.43266,156.95297 C 202.90132,159.50879 201.6919,162.31362 200.87016,165.32797 C 196.03378,183.06884 206.50428,201.39786 224.24516,206.23422 C 231.18531,208.12619 238.21898,207.67159 244.49516,205.35922 C 243.40748,200.31196 243.48175,194.93148 244.93266,189.60922 C 247.71692,171.15921 268.63307,173.37897 263.67641,161.08212"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:3.16281843;stroke-miterlimit:4;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         id="path3376"
-         d="M 233.44337,142.49057 C 219.37428,142.29172 206.40776,151.6048 202.53712,165.80307 C 197.94972,182.63065 207.86578,199.99691 224.69337,204.58432 C 241.52094,209.17172 258.91846,199.2244 263.50587,182.39682 C 268.09327,165.56923 258.14593,148.20297 241.31837,143.61557 C 238.68906,142.89879 236.04876,142.52739 233.44337,142.49057 z M 217.13087,158.30307 C 218.08138,158.3031 219.00065,158.38383 219.91212,158.55307 C 220.82356,158.70935 221.63345,158.90466 222.34962,159.17807 C 223.06574,159.45154 223.74804,159.78227 224.41212,160.14682 C 225.08918,160.49841 225.68033,160.88123 226.16212,161.27182 C 226.64387,161.64945 227.09439,162.01924 227.53712,162.39682 C 227.9798,162.77445 228.33917,163.13383 228.59962,163.45932 C 228.86001,163.78487 229.09698,164.05569 229.31837,164.30307 C 229.53969,164.53747 229.68553,164.71194 229.72462,164.80307 L 227.25587,166.64682 C 226.90428,166.20414 226.63345,165.84475 226.41212,165.58432 C 226.19074,165.32393 225.7272,164.88382 225.03712,164.27182 C 224.36001,163.65987 223.66991,163.16768 223.00587,162.80307 C 222.34179,162.42549 221.4798,162.08435 220.41212,161.77182 C 219.35741,161.45935 218.27669,161.3031 217.13087,161.30307 C 215.47721,161.3031 213.87825,161.6156 212.38087,162.24057 C 210.88347,162.8656 209.61784,163.71716 208.53712,164.77182 C 207.45639,165.82653 206.58138,167.08173 205.94337,168.55307 C 205.31836,170.01143 205.00586,171.53226 205.00587,173.14683 C 205.00586,174.74841 205.31836,176.28223 205.94337,177.74057 C 206.58138,179.19891 207.43816,180.45412 208.50587,181.52182 C 209.58659,182.57651 210.88346,183.42807 212.38087,184.05307 C 213.89127,184.67807 215.47721,184.99057 217.13087,184.99057 C 220.19075,184.99057 222.83397,184.00099 225.09962,182.02182 C 227.37823,180.02964 228.72199,177.57651 229.09962,174.64683 L 216.41212,174.64683 L 216.41212,171.61558 L 240.06837,171.61558 L 222.28712,197.77182 L 240.09962,197.77182 L 239.09962,200.77182 L 216.53712,200.77182 L 229.34962,181.89682 C 228.8853,182.52154 228.37904,183.1075 227.81837,183.64682 C 226.46418,184.96193 224.84959,186.02183 222.97462,186.80307 C 221.11262,187.58433 219.17513,187.95932 217.13087,187.95932 C 215.07357,187.95932 213.08137,187.58433 211.19337,186.80307 C 209.31836,186.02183 207.7168,184.96193 206.34962,183.64682 C 204.99545,182.33172 203.9069,180.751 203.09962,178.92807 C 202.29232,177.09214 201.88087,175.16506 201.88087,173.14683 C 201.88087,171.12862 202.29232,169.20152 203.09962,167.36557 C 203.9069,165.52966 204.99545,163.94372 206.34962,162.61557 C 207.7168,161.28747 209.31836,160.2406 211.19337,159.45932 C 213.08137,158.6781 215.07357,158.3031 217.13087,158.30307 z M 232.19337,174.61558 C 232.04411,176.10603 231.678,177.5416 231.06837,178.92807 C 230.75153,179.65523 230.38262,180.34422 229.97462,180.99057 L 234.28712,174.61558 L 232.19337,174.61558 z"
-         style="fill:#225090;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         id="path3374"
-         d="M 264.02502,160.50539 C 260.17144,151.44195 252.35762,144.16576 242.12502,141.37623 C 239.35301,140.62055 236.55931,140.22756 233.81252,140.18873 C 233.59129,140.18561 233.37304,140.18254 233.1552,140.18158"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:2;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-    </g>
-    <g
-       id="g3454"
-       transform="translate(-236.31258,313.65642)">
-      <path
-         sodipodi:nodetypes="csscc"
-         id="path3378"
-         d="M 280.65727,161.4675 C 279.12593,164.02332 277.91651,166.82815 277.09477,169.8425 C 272.25839,187.58337 282.72889,205.91239 300.46977,210.74875 C 307.40992,212.64072 314.44359,212.18612 320.71977,209.87375 C 319.63209,204.82649 319.70636,199.44601 321.15727,194.12375"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:3.16281843;stroke-miterlimit:4;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         id="path3382"
-         d="M 309.66798,147.0051 C 295.59889,146.80625 282.63237,156.11933 278.76173,170.3176 C 274.17433,187.14518 284.09039,204.51144 300.91798,209.09885 C 317.74555,213.68625 335.14307,203.73893 339.73048,186.91135 C 344.31788,170.08376 334.37054,152.7175 317.54298,148.1301 C 314.91367,147.41332 312.27337,147.04192 309.66798,147.0051 z M 293.35548,162.8176 C 294.30599,162.81763 295.22526,162.89836 296.13673,163.0676 C 297.04817,163.22388 297.85806,163.41919 298.57423,163.6926 C 299.29035,163.96607 299.97265,164.2968 300.63673,164.66135 C 301.31379,165.01294 301.90494,165.39576 302.38673,165.78635 C 302.86848,166.16398 303.319,166.53377 303.76173,166.91135 C 304.20441,167.28898 304.56378,167.64836 304.82423,167.97385 C 305.08462,168.2994 305.32159,168.57022 305.54298,168.8176 C 305.7643,169.052 305.91014,169.22647 305.94923,169.3176 L 303.48048,171.16135 C 303.12889,170.71867 302.85806,170.35928 302.63673,170.09885 C 302.41535,169.83846 301.95181,169.39835 301.26173,168.78635 C 300.58462,168.1744 299.89452,167.68221 299.23048,167.3176 C 298.5664,166.94002 297.70441,166.59888 296.63673,166.28635 C 295.58202,165.97388 294.5013,165.81763 293.35548,165.8176 C 291.70182,165.81763 290.10286,166.13013 288.60548,166.7551 C 287.10808,167.38013 285.84245,168.23169 284.76173,169.28635 C 283.681,170.34106 282.80599,171.59626 282.16798,173.0676 C 281.54297,174.52596 281.23047,176.04679 281.23048,177.66136 C 281.23047,179.26294 281.54297,180.79676 282.16798,182.2551 C 282.80599,183.71344 283.66277,184.96865 284.73048,186.03635 C 285.8112,187.09104 287.10807,187.9426 288.60548,188.5676 C 290.11588,189.1926 291.70182,189.5051 293.35548,189.5051 C 296.41536,189.5051 299.05858,188.51552 301.32423,186.53635 C 303.60284,184.54417 304.9466,182.09104 305.32423,179.16136 L 292.63673,179.16136 L 292.63673,176.13011 L 316.29298,176.13011 L 298.51173,202.28635 L 316.32423,202.28635 L 315.32423,205.28635 L 292.76173,205.28635 L 305.57423,186.41135 C 305.10991,187.03607 304.60365,187.62203 304.04298,188.16135 C 302.68879,189.47646 301.0742,190.53636 299.19923,191.3176 C 297.33723,192.09886 295.39974,192.47385 293.35548,192.47385 C 291.29818,192.47385 289.30598,192.09886 287.41798,191.3176 C 285.54297,190.53636 283.94141,189.47646 282.57423,188.16135 C 281.22006,186.84625 280.13151,185.26553 279.32423,183.4426 C 278.51693,181.60667 278.10548,179.67959 278.10548,177.66136 C 278.10548,175.64315 278.51693,173.71605 279.32423,171.8801 C 280.13151,170.04419 281.22006,168.45825 282.57423,167.1301 C 283.94141,165.802 285.54297,164.75513 287.41798,163.97385 C 289.30598,163.19263 291.29818,162.81763 293.35548,162.8176 z M 308.41798,179.13011 C 308.26872,180.62056 307.90261,182.05613 307.29298,183.4426 C 306.97614,184.16976 306.60723,184.85875 306.19923,185.5051 L 310.51173,179.13011 L 308.41798,179.13011 z"
-         style="fill:#941515;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-    </g>
-    <g
-       id="g3462"
-       transform="translate(-226.08743,-139.33873)">
-      <path
-         sodipodi:nodetypes="csscc"
-         id="path3386"
-         d="M 359.4283,163.60965 C 357.89696,166.16547 356.68754,168.9703 355.8658,171.98465 C 351.02942,189.72552 361.49992,208.05454 379.2408,212.8909 C 386.18095,214.78287 393.21462,214.32827 399.4908,212.0159 C 398.40312,206.96864 398.47739,201.58816 399.9283,196.2659"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#40794f;stroke-width:3.16281843;stroke-miterlimit:4;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         id="path3388"
-         d="M 387.125,149.15625 C 373.5699,149.53516 361.28093,158.71418 357.53125,172.46875 C 352.94386,189.29633 362.85991,206.66259 379.6875,211.25 C 396.51508,215.8374 413.91259,205.89008 418.5,189.0625 C 419.84698,184.1215 419.93425,179.13425 418.96875,174.4375 C 418.57574,174.34541 418.17382,174.23202 417.78125,174.125 C 405.65211,170.81846 396.95175,161.20154 394.1875,149.78125 C 392.26602,149.3935 390.33963,149.18313 388.4375,149.15625 C 387.99784,149.15004 387.56226,149.14403 387.125,149.15625 z M 372.125,164.96875 C 373.07552,164.96878 373.99478,165.04951 374.90625,165.21875 C 375.8177,165.37503 376.62758,165.57034 377.34375,165.84375 C 378.05988,166.11722 378.74217,166.44795 379.40625,166.8125 C 380.08332,167.16409 380.67446,167.54691 381.15625,167.9375 C 381.63801,168.31513 382.08852,168.68492 382.53125,169.0625 C 382.97394,169.44013 383.3333,169.79951 383.59375,170.125 C 383.85415,170.45055 384.09111,170.72137 384.3125,170.96875 C 384.53383,171.20315 384.67966,171.37762 384.71875,171.46875 L 382.25,173.3125 C 381.89842,172.86982 381.62758,172.51043 381.40625,172.25 C 381.18488,171.98961 380.72133,171.5495 380.03125,170.9375 C 379.35415,170.32555 378.66404,169.83336 378,169.46875 C 377.33593,169.09117 376.47393,168.75003 375.40625,168.4375 C 374.35155,168.12503 373.27082,167.96878 372.125,167.96875 C 370.47135,167.96878 368.87238,168.28128 367.375,168.90625 C 365.87761,169.53128 364.61197,170.38284 363.53125,171.4375 C 362.45053,172.49221 361.57551,173.74741 360.9375,175.21875 C 360.3125,176.67711 359.99999,178.19793 360,179.8125 C 360,181.41408 360.31249,182.94791 360.9375,184.40625 C 361.57552,185.86459 362.43229,187.1198 363.5,188.1875 C 364.58073,189.24219 365.87759,190.09375 367.375,190.71875 C 368.88541,191.34375 370.47134,191.65625 372.125,191.65625 C 375.18489,191.65625 377.8281,190.66667 380.09375,188.6875 C 382.37237,186.69532 383.71612,184.24218 384.09375,181.3125 L 371.40625,181.3125 L 371.40625,178.28125 L 395.0625,178.28125 L 377.28125,204.4375 L 395.09375,204.4375 L 394.09375,207.4375 L 371.53125,207.4375 L 384.34375,188.5625 C 383.87944,189.18722 383.37317,189.77318 382.8125,190.3125 C 381.45832,191.62761 379.84372,192.68751 377.96875,193.46875 C 376.10676,194.25001 374.16926,194.625 372.125,194.625 C 370.06771,194.625 368.0755,194.25001 366.1875,193.46875 C 364.3125,192.68751 362.71093,191.62761 361.34375,190.3125 C 359.98959,188.9974 358.90103,187.41668 358.09375,185.59375 C 357.28646,183.75782 356.875,181.83073 356.875,179.8125 C 356.87501,177.79429 357.28645,175.8672 358.09375,174.03125 C 358.90104,172.19534 359.98958,170.6094 361.34375,169.28125 C 362.71094,167.95315 364.31249,166.90628 366.1875,166.125 C 368.07551,165.34378 370.0677,164.96878 372.125,164.96875 z M 387.1875,181.28125 C 387.03825,182.7717 386.67213,184.20728 386.0625,185.59375 C 385.74567,186.32091 385.37675,187.0099 384.96875,187.65625 L 389.28125,181.28125 L 387.1875,181.28125 z"
-         style="fill:#9cb3d5;fill-opacity:1;fill-rule:nonzero;stroke:#2e4a35;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-    </g>
-    <g
-       id="g3471"
-       transform="translate(-303.17177,19.154184)">
-      <path
-         sodipodi:nodetypes="csscc"
-         id="path3394"
-         d="M 436.50923,162.28762 C 434.97789,164.84344 433.76847,167.64827 432.94673,170.66262 C 428.11035,188.40349 438.58085,206.73251 456.32173,211.56887 C 463.26188,213.46084 470.29555,213.00624 476.57173,210.69387 C 475.48405,205.64661 475.55832,200.26613 477.00923,194.94387"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:3.16281843;stroke-miterlimit:4;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         id="path3396"
-         d="M 464.21573,147.83247 C 450.66063,148.21137 438.37166,157.3904 434.62198,171.14497 C 430.03459,187.97255 439.95064,205.33881 456.77823,209.92622 C 465.79513,212.38433 474.96136,210.66825 482.24698,205.95747 C 483.96172,197.4512 488.96614,189.84538 496.21573,184.92622 C 499.04257,169.0174 489.29435,153.28959 473.40323,148.95747 C 470.77393,148.24069 468.13362,147.86929 465.52823,147.83247 C 465.08857,147.82626 464.65299,147.82025 464.21573,147.83247 z M 449.21573,163.64497 C 450.16625,163.645 451.08551,163.72573 451.99698,163.89497 C 452.90843,164.05125 453.71831,164.24656 454.43448,164.51997 C 455.15061,164.79344 455.8329,165.12417 456.49698,165.48872 C 457.17405,165.84031 457.76519,166.22313 458.24698,166.61372 C 458.72874,166.99135 459.17925,167.36114 459.62198,167.73872 C 460.06467,168.11635 460.42403,168.47573 460.68448,168.80122 C 460.94488,169.12677 461.18184,169.39759 461.40323,169.64497 C 461.62456,169.87937 461.77039,170.05384 461.80948,170.14497 L 459.34073,171.98872 C 458.98915,171.54604 458.71831,171.18665 458.49698,170.92622 C 458.27561,170.66583 457.81206,170.22572 457.12198,169.61372 C 456.44488,169.00177 455.75477,168.50958 455.09073,168.14497 C 454.42666,167.76739 453.56466,167.42625 452.49698,167.11372 C 451.44228,166.80125 450.36155,166.645 449.21573,166.64497 C 447.56208,166.645 445.96311,166.9575 444.46573,167.58247 C 442.96834,168.2075 441.7027,169.05906 440.62198,170.11372 C 439.54126,171.16843 438.66624,172.42363 438.02823,173.89497 C 437.40323,175.35333 437.09072,176.87415 437.09073,178.48872 C 437.09073,180.09029 437.40322,181.62413 438.02823,183.08247 C 438.66625,184.54081 439.52302,185.79602 440.59073,186.86372 C 441.67146,187.91841 442.96832,188.76997 444.46573,189.39497 C 445.97614,190.01997 447.56207,190.33247 449.21573,190.33247 C 452.27562,190.33247 454.91883,189.34289 457.18448,187.36372 C 459.4631,185.37154 460.80685,182.9184 461.18448,179.98872 L 448.49698,179.98872 L 448.49698,176.95747 L 472.15323,176.95747 L 454.37198,203.11372 L 472.18448,203.11372 L 471.18448,206.11372 L 448.62198,206.11372 L 461.43448,187.23872 C 460.97017,187.86344 460.4639,188.4494 459.90323,188.98872 C 458.54905,190.30383 456.93445,191.36373 455.05948,192.14497 C 453.19749,192.92623 451.25999,193.30122 449.21573,193.30122 C 447.15844,193.30122 445.16623,192.92623 443.27823,192.14497 C 441.40323,191.36373 439.80166,190.30383 438.43448,188.98872 C 437.08032,187.67362 435.99176,186.0929 435.18448,184.26997 C 434.37719,182.43404 433.96573,180.50695 433.96573,178.48872 C 433.96574,176.4705 434.37718,174.54342 435.18448,172.70747 C 435.99177,170.87156 437.08031,169.28562 438.43448,167.95747 C 439.80167,166.62937 441.40322,165.5825 443.27823,164.80122 C 445.16624,164.02 447.15843,163.645 449.21573,163.64497 z M 464.27823,179.95747 C 464.12898,181.44791 463.76286,182.8835 463.15323,184.26997 C 462.8364,184.99713 462.46748,185.68612 462.05948,186.33247 L 466.37198,179.95747 L 464.27823,179.95747 z"
-         style="fill:#941515;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-    </g>
-    <g
-       id="g3520"
-       inkscape:export-filename="/wg/stor5/nkoenig/Downloads/icon.png"
-       inkscape:export-xdpi="43.139999"
-       inkscape:export-ydpi="43.139999">
-      <path
-         transform="translate(0.3839309,-150.76312)"
-         d="M 104.31479,190.53003 A 31.689676,31.689676 0 1 1 40.935438,190.53003 A 31.689676,31.689676 0 1 1 104.31479,190.53003 z"
-         sodipodi:ry="31.689676"
-         sodipodi:rx="31.689676"
-         sodipodi:cy="190.53003"
-         sodipodi:cx="72.625114"
-         id="path3510"
-         style="fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:0.50000000000000000;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
-         sodipodi:type="arc" />
-      <g
-         transform="translate(0.3783905,7.6293945e-6)"
-         id="g3432">
-        <path
-           style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:3.16281843;stroke-miterlimit:4;stroke-dashoffset:0;stroke-opacity:1"
-           d="M 43.965901,22.73527 C 42.434561,25.29109 41.225141,28.09592 40.403401,31.11027 C 35.567021,48.85114 46.037521,67.18016 63.778401,72.01652 C 70.718551,73.90849 77.752221,73.45389 84.028401,71.14152 C 82.940721,66.09426 83.014991,60.71378 84.465901,55.39152"
-           id="path3406"
-           sodipodi:nodetypes="csscc" />
-        <path
-           style="fill:#941515;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
-           d="M 71.665631,8.2612601 C 58.110531,8.6401601 45.821561,17.81919 42.071881,31.57376 C 37.484491,48.40134 47.400541,65.7676 64.228131,70.35501 C 81.055711,74.94241 98.453221,64.99509 103.04063,48.16751 C 105.93849,37.53752 103.03202,26.71412 96.259381,19.01126 C 94.969421,19.22333 93.634081,18.85343 92.634381,17.94876 L 82.915631,25.26126 C 82.998991,25.47678 83.039371,25.69412 83.071881,25.91751 C 83.082441,25.97232 83.095661,26.01874 83.103131,26.07376 C 83.107901,26.12453 83.100921,26.17919 83.103131,26.23001 C 83.116861,26.39799 83.117041,26.56343 83.103131,26.73001 C 83.089781,26.88985 83.047241,27.04324 83.009381,27.19876 C 82.881261,27.725 82.645191,28.23392 82.259381,28.63626 L 88.353131,39.13626 C 90.294061,38.4601 92.502621,39.2615 93.571881,41.10501 C 94.783861,43.19457 94.067711,45.86179 91.978131,47.07376 C 89.888581,48.28573 87.221381,47.56957 86.009381,45.48001 C 84.940121,43.6365 85.364991,41.32901 86.915631,39.98001 L 80.790631,29.48001 C 79.486521,29.81268 78.092721,29.26381 77.384381,28.04251 C 77.220801,27.76049 77.107681,27.46916 77.040631,27.16751 C 77.035671,27.14821 77.045201,27.12437 77.040631,27.10501 C 77.015371,26.97994 76.987561,26.8558 76.978131,26.73001 C 76.864671,25.68295 77.292221,24.59799 78.196881,23.91751 C 79.320991,23.07199 80.813671,23.11175 81.884381,23.91751 L 91.603131,16.60501 C 91.259931,15.90264 91.143651,15.13551 91.196881,14.38626 C 88.164031,12.16624 84.693791,10.43327 80.853131,9.3862601 C 78.223831,8.6694801 75.583521,8.2980801 72.978131,8.2612601 C 72.538471,8.2550501 72.102891,8.2490401 71.665631,8.2612601 z M 56.665631,24.07376 C 57.616151,24.07379 58.535411,24.15452 59.446881,24.32376 C 60.358331,24.48004 61.168211,24.67535 61.884381,24.94876 C 62.600511,25.22223 63.282801,25.55296 63.946881,25.91751 C 64.623951,26.2691 65.215091,26.65192 65.696881,27.04251 C 66.178641,27.42014 66.629151,27.78993 67.071881,28.16751 C 67.514571,28.54514 67.873931,28.90452 68.134381,29.23001 C 68.394781,29.55556 68.631741,29.82638 68.853131,30.07376 C 69.074461,30.30816 69.220291,30.48263 69.259381,30.57376 L 66.790631,32.41751 C 66.439051,31.97483 66.168211,31.61544 65.946881,31.35501 C 65.725511,31.09462 65.261961,30.65451 64.571881,30.04251 C 63.894781,29.43056 63.204671,28.93837 62.540631,28.57376 C 61.876561,28.19618 61.014561,27.85504 59.946881,27.54251 C 58.892181,27.23004 57.811451,27.07379 56.665631,27.07376 C 55.011981,27.07379 53.413011,27.38629 51.915631,28.01126 C 50.418241,28.63629 49.152601,29.48785 48.071881,30.54251 C 46.991161,31.59722 46.116141,32.85242 45.478131,34.32376 C 44.853131,35.78212 44.540621,37.30294 44.540631,38.91751 C 44.540631,40.51908 44.853121,42.05292 45.478131,43.51126 C 46.116151,44.9696 46.972921,46.22481 48.040631,47.29251 C 49.121361,48.3472 50.418221,49.19876 51.915631,49.82376 C 53.426041,50.44876 55.011971,50.76126 56.665631,50.76126 C 59.725521,50.76126 62.368731,49.77168 64.634381,47.79251 C 66.913001,45.80033 68.256751,43.34719 68.634381,40.41751 L 55.946881,40.41751 L 55.946881,37.38626 L 79.603131,37.38626 L 61.821881,63.54251 L 79.634381,63.54251 L 78.634381,66.54251 L 56.071881,66.54251 L 68.884381,47.66751 C 68.420071,48.29223 67.913801,48.87819 67.353131,49.41751 C 65.998951,50.73262 64.384351,51.79252 62.509381,52.57376 C 60.647391,53.35502 58.709891,53.73001 56.665631,53.73001 C 54.608341,53.73001 52.616131,53.35502 50.728131,52.57376 C 48.853131,51.79252 47.251561,50.73262 45.884381,49.41751 C 44.530221,48.10241 43.441661,46.52169 42.634381,44.69876 C 41.827091,42.86283 41.415631,40.93574 41.415631,38.91751 C 41.415641,36.89929 41.827081,34.97221 42.634381,33.13626 C 43.441671,31.30035 44.530211,29.71441 45.884381,28.38626 C 47.251571,27.05816 48.853121,26.01129 50.728131,25.23001 C 52.616141,24.44879 54.608331,24.07379 56.665631,24.07376 z M 71.728131,40.38626 C 71.578881,41.8767 71.212761,43.31229 70.603131,44.69876 C 70.286301,45.42592 69.917381,46.11491 69.509381,46.76126 L 73.821881,40.38626 L 71.728131,40.38626 z"
-           id="path3408" />
-      </g>
-    </g>
-    <g
-       id="g3436"
-       transform="translate(0.3787815,-1.1165924)">
-      <path
-         sodipodi:nodetypes="csscc"
-         id="path3424"
-         d="M 43.965511,99.249978 C 42.434171,101.8058 41.224749,104.61063 40.403009,107.62498 C 35.566629,125.36585 46.037131,143.69487 63.778011,148.53123 C 70.718161,150.4232 77.751831,149.9686 84.028011,147.65623 C 82.940331,142.60897 83.014601,137.22849 84.465511,131.90623"
-         style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:3.16281843;stroke-miterlimit:4;stroke-dashoffset:0;stroke-opacity:1" />
-      <path
-         id="path3426"
-         d="M 71.665241,84.775968 C 58.110141,85.154868 45.821171,94.333898 42.071491,108.08847 C 37.484099,124.91605 47.400151,142.28231 64.227741,146.86972 C 81.055321,151.45712 98.452831,141.5098 103.04024,124.68222 C 105.9381,114.05223 103.03163,103.22883 96.258991,95.525968 C 94.969031,95.738038 93.633691,95.368138 92.633991,94.463468 L 82.915241,101.77597 C 82.998601,101.99149 83.038981,102.20883 83.071491,102.43222 C 83.082051,102.48703 83.095271,102.53345 83.102741,102.58847 C 83.107511,102.63924 83.100531,102.6939 83.102741,102.74472 C 83.116471,102.9127 83.116651,103.07814 83.102741,103.24472 C 83.089391,103.40456 83.046851,103.55795 83.008991,103.71347 C 82.880871,104.23971 82.644801,104.74863 82.258991,105.15097 L 88.352741,115.65097 C 90.293671,114.97481 92.502231,115.77621 93.571491,117.61972 C 94.783471,119.70928 94.067321,122.3765 91.977741,123.58847 C 89.888191,124.80044 87.220991,124.08428 86.008991,121.99472 C 84.939731,120.15121 85.364601,117.84372 86.915241,116.49472 L 80.790241,105.99472 C 79.486131,106.32739 78.092331,105.77852 77.383991,104.55722 C 77.220411,104.2752 77.107291,103.98387 77.040241,103.68222 C 77.035281,103.66292 77.044811,103.63908 77.040241,103.61972 C 77.014981,103.49465 76.987171,103.37051 76.977741,103.24472 C 76.864281,102.19766 77.291831,101.1127 78.196491,100.43222 C 79.320601,99.586698 80.813281,99.626458 81.883991,100.43222 L 91.602741,93.119718 C 91.259541,92.417348 91.143261,91.650218 91.196491,90.900968 C 88.163641,88.680948 84.693401,86.947978 80.852741,85.900968 C 78.223441,85.184188 75.583131,84.812788 72.977741,84.775968 C 72.538081,84.769758 72.102501,84.763748 71.665241,84.775968 z M 56.665241,100.58847 C 57.615761,100.5885 58.535021,100.66923 59.446491,100.83847 C 60.357941,100.99475 61.167821,101.19006 61.883991,101.46347 C 62.600121,101.73694 63.282411,102.06767 63.946491,102.43222 C 64.623561,102.78381 65.214701,103.16663 65.696491,103.55722 C 66.178251,103.93485 66.628761,104.30464 67.071491,104.68222 C 67.514181,105.05985 67.873541,105.41923 68.133991,105.74472 C 68.394391,106.07027 68.631351,106.34109 68.852741,106.58847 C 69.074071,106.82287 69.219901,106.99734 69.258991,107.08847 L 66.790241,108.93222 C 66.438661,108.48954 66.167821,108.13015 65.946491,107.86972 C 65.725121,107.60933 65.261571,107.16922 64.571491,106.55722 C 63.894391,105.94527 63.204281,105.45308 62.540241,105.08847 C 61.876171,104.71089 61.014171,104.36975 59.946491,104.05722 C 58.891791,103.74475 57.811061,103.5885 56.665241,103.58847 C 55.011591,103.5885 53.412621,103.901 51.915241,104.52597 C 50.417851,105.151 49.152211,106.00256 48.071491,107.05722 C 46.990771,108.11193 46.115751,109.36713 45.477741,110.83847 C 44.852741,112.29683 44.540231,113.81765 44.540241,115.43222 C 44.540241,117.03379 44.852731,118.56763 45.477741,120.02597 C 46.115761,121.48431 46.972531,122.73952 48.040241,123.80722 C 49.120971,124.86191 50.417831,125.71347 51.915241,126.33847 C 53.425651,126.96347 55.011581,127.27597 56.665241,127.27597 C 59.725131,127.27597 62.368341,126.28639 64.633991,124.30722 C 66.912611,122.31504 68.256361,119.8619 68.633991,116.93222 L 55.946491,116.93222 L 55.946491,113.90097 L 79.602741,113.90097 L 61.821491,140.05722 L 79.633991,140.05722 L 78.633991,143.05722 L 56.071491,143.05722 L 68.883991,124.18222 C 68.419681,124.80694 67.913411,125.3929 67.352741,125.93222 C 65.998561,127.24733 64.383961,128.30723 62.508991,129.08847 C 60.647001,129.86973 58.709501,130.24472 56.665241,130.24472 C 54.607951,130.24472 52.615741,129.86973 50.727741,129.08847 C 48.852741,128.30723 47.251171,127.24733 45.883991,125.93222 C 44.529831,124.61712 43.441271,123.0364 42.633991,121.21347 C 41.826701,119.37754 41.415239,117.45045 41.415239,115.43222 C 41.415249,113.414 41.826691,111.48692 42.633991,109.65097 C 43.441281,107.81506 44.529821,106.22912 45.883991,104.90097 C 47.251181,103.57287 48.852731,102.526 50.727741,101.74472 C 52.615751,100.9635 54.607941,100.5885 56.665241,100.58847 z M 71.727741,116.90097 C 71.578491,118.39141 71.212371,119.827 70.602741,121.21347 C 70.285911,121.94063 69.916991,122.62962 69.508991,123.27597 L 73.821491,116.90097 L 71.727741,116.90097 z"
-         style="fill:#225090;fill-opacity:1;fill-rule:nonzero;stroke:#edaf00;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
-    </g>
-    <path
-       style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#3f784e;stroke-width:3.16281843;stroke-miterlimit:4;stroke-dashoffset:0;stroke-opacity:1"
-       d="M 44.344295,173.53152 C 42.812955,176.08734 41.603533,178.89217 40.781792,181.90652 C 35.945412,199.64739 46.415915,217.97641 64.15679,222.81277 C 71.09694,224.70474 78.13061,224.25014 84.40679,221.93777 C 83.31911,216.89051 83.39338,211.51003 84.84429,206.18777"
-       id="path3428"
-       sodipodi:nodetypes="csscc" />
-    <path
-       style="fill:#9cb3d5;fill-opacity:1;fill-rule:nonzero;stroke:#3f784e;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
-       d="M 72.04402,159.05751 C 58.48892,159.43641 46.199955,168.61544 42.450275,182.37001 C 37.862882,199.19759 47.778935,216.56385 64.60652,221.15126 C 81.4341,225.73866 98.83161,215.79134 103.41902,198.96376 C 106.31688,188.33377 103.41041,177.51037 96.63777,169.80751 C 95.34781,170.01958 94.01247,169.64968 93.01277,168.74501 L 83.29402,176.05751 C 83.37738,176.27303 83.41776,176.49037 83.45027,176.71376 C 83.46083,176.76857 83.47405,176.81499 83.48152,176.87001 C 83.48629,176.92078 83.47931,176.97544 83.48152,177.02626 C 83.49525,177.19424 83.49543,177.35968 83.48152,177.52626 C 83.46817,177.6861 83.42563,177.83949 83.38777,177.99501 C 83.25965,178.52125 83.02358,179.03017 82.63777,179.43251 L 88.73152,189.93251 C 90.67245,189.25635 92.88101,190.05775 93.95027,191.90126 C 95.16225,193.99082 94.4461,196.65804 92.35652,197.87001 C 90.26697,199.08198 87.59977,198.36582 86.38777,196.27626 C 85.31851,194.43275 85.74338,192.12526 87.29402,190.77626 L 81.16902,180.27626 C 79.86491,180.60893 78.47111,180.06006 77.76277,178.83876 C 77.59919,178.55674 77.48607,178.26541 77.41902,177.96376 C 77.41406,177.94446 77.42359,177.92062 77.41902,177.90126 C 77.39376,177.77619 77.36595,177.65205 77.35652,177.52626 C 77.24306,176.4792 77.67061,175.39424 78.57527,174.71376 C 79.69938,173.86824 81.19206,173.908 82.26277,174.71376 L 91.98152,167.40126 C 91.63832,166.69889 91.52204,165.93176 91.57527,165.18251 C 88.54242,162.96249 85.07218,161.22952 81.23152,160.18251 C 78.60222,159.46573 75.96191,159.09433 73.35652,159.05751 C 72.91686,159.0513 72.48128,159.04529 72.04402,159.05751 z M 57.04402,174.87001 C 57.99454,174.87004 58.9138,174.95077 59.82527,175.12001 C 60.73672,175.27629 61.5466,175.4716 62.26277,175.74501 C 62.9789,176.01848 63.66119,176.34921 64.32527,176.71376 C 65.00234,177.06535 65.59348,177.44817 66.07527,177.83876 C 66.55703,178.21639 67.00754,178.58618 67.45027,178.96376 C 67.89296,179.34139 68.25232,179.70077 68.51277,180.02626 C 68.77317,180.35181 69.01013,180.62263 69.23152,180.87001 C 69.45285,181.10441 69.59868,181.27888 69.63777,181.37001 L 67.16902,183.21376 C 66.81744,182.77108 66.5466,182.41169 66.32527,182.15126 C 66.1039,181.89087 65.64035,181.45076 64.95027,180.83876 C 64.27317,180.22681 63.58306,179.73462 62.91902,179.37001 C 62.25495,178.99243 61.39295,178.65129 60.32527,178.33876 C 59.27057,178.02629 58.18984,177.87004 57.04402,177.87001 C 55.39037,177.87004 53.7914,178.18254 52.29402,178.80751 C 50.79663,179.43254 49.530995,180.2841 48.450275,181.33876 C 47.369555,182.39347 46.494535,183.64867 45.856525,185.12001 C 45.231525,186.57837 44.919015,188.09919 44.919025,189.71376 C 44.919025,191.31533 45.231515,192.84917 45.856525,194.30751 C 46.494545,195.76585 47.351315,197.02106 48.419025,198.08876 C 49.499755,199.14345 50.79661,199.99501 52.29402,200.62001 C 53.80443,201.24501 55.39036,201.55751 57.04402,201.55751 C 60.10391,201.55751 62.74712,200.56793 65.01277,198.58876 C 67.29139,196.59658 68.63514,194.14344 69.01277,191.21376 L 56.32527,191.21376 L 56.32527,188.18251 L 79.98152,188.18251 L 62.20027,214.33876 L 80.01277,214.33876 L 79.01277,217.33876 L 56.45027,217.33876 L 69.26277,198.46376 C 68.79846,199.08848 68.29219,199.67444 67.73152,200.21376 C 66.37734,201.52887 64.76274,202.58877 62.88777,203.37001 C 61.02578,204.15127 59.08828,204.52626 57.04402,204.52626 C 54.98673,204.52626 52.99452,204.15127 51.10652,203.37001 C 49.231525,202.58877 47.629955,201.52887 46.262775,200.21376 C 44.908615,198.89866 43.820055,197.31794 43.012775,195.49501 C 42.205485,193.65908 41.794023,191.73199 41.794023,189.71376 C 41.794033,187.69554 42.205475,185.76846 43.012775,183.93251 C 43.820065,182.0966 44.908605,180.51066 46.262775,179.18251 C 47.629965,177.85441 49.231515,176.80754 51.10652,176.02626 C 52.99453,175.24504 54.98672,174.87004 57.04402,174.87001 z M 72.10652,191.18251 C 71.95727,192.67295 71.59115,194.10854 70.98152,195.49501 C 70.66469,196.22217 70.29577,196.91116 69.88777,197.55751 L 74.20027,191.18251 L 72.10652,191.18251 z"
-       id="path3430" />
-    <path
-       sodipodi:type="arc"
-       style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:5.53954744;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
-       id="path3528"
-       sodipodi:cx="424.0347"
-       sodipodi:cy="114.376"
-       sodipodi:rx="35.006859"
-       sodipodi:ry="35.006859"
-       d="M 459.04156,114.376 A 35.006859,35.006859 0 1 1 389.02784,114.376 A 35.006859,35.006859 0 1 1 459.04156,114.376 z"
-       transform="matrix(0.9026008,0,0,0.9026008,-137.9277,-62.432833)" />
-    <path
-       style="font-size:40px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;font-family:Interstate;-inkscape-font-specification:Sans"
-       d="M 238.25254,13.498924 C 235.66188,13.498962 233.15319,13.971181 230.77572,14.954938 C 228.4146,15.938766 226.39783,17.257045 224.6762,18.92946 C 222.97096,20.601937 221.6002,22.599035 220.58363,24.91092 C 219.56703,27.222856 219.04891,29.649543 219.04891,32.190986 C 219.04891,34.732464 219.56703,37.159161 220.58363,39.471048 C 221.6002,41.766582 222.97096,43.757111 224.6762,45.413157 C 226.39783,47.069215 228.4146,48.403899 230.77572,49.387679 C 233.15319,50.371484 235.66188,50.843692 238.25254,50.843692 C 240.82679,50.843692 243.26658,50.371484 245.61131,49.387679 C 247.97238,48.403899 250.00556,47.069215 251.71083,45.413157 C 252.41685,44.734015 253.05436,43.996142 253.63906,43.209461 L 237.50486,66.977893 L 265.9168,66.977893 L 267.17605,63.200129 L 244.74558,63.200129 L 267.1367,30.262752 L 237.34745,30.262752 L 237.34745,34.079868 L 253.32425,34.079868 C 252.84872,37.769107 251.15658,40.858206 248.28723,43.366868 C 245.4342,45.859147 242.10571,47.10528 238.25254,47.10528 C 236.17016,47.10528 234.17306,46.711763 232.27108,45.924729 C 230.38546,45.137695 228.75237,44.065364 227.39147,42.73724 C 226.04695,41.392734 224.96805,39.812105 224.16463,37.975687 C 223.37759,36.139278 222.98407,34.207783 222.98408,32.190986 C 222.98407,30.157835 223.37759,28.24272 224.16463,26.406285 C 224.96805,24.553502 226.06991,22.972875 227.43082,21.644728 C 228.79173,20.316638 230.38548,19.244305 232.27108,18.45724 C 234.15667,17.670238 236.17016,17.276721 238.25254,17.276688 C 239.69542,17.276721 241.05632,17.47348 242.38447,17.866964 C 243.72895,18.260513 244.81442,18.690102 245.65067,19.16557 C 246.48686,19.624705 247.35587,20.244494 248.20853,21.015101 C 249.07751,21.785767 249.66123,22.33997 249.94,22.667873 C 250.21871,22.995832 250.55976,23.448375 251.0025,24.005831 L 254.11128,21.68408 C 254.06206,21.569334 253.87841,21.349619 253.59971,21.054453 C 253.32092,20.742948 253.02252,20.4019 252.69462,19.991956 C 252.36665,19.582074 251.91411,19.129529 251.35666,18.653998 C 250.79915,18.17853 250.23183,17.712869 249.62519,17.237337 C 249.01849,16.745474 248.27408,16.263417 247.42149,15.820675 C 246.58525,15.361608 245.72606,14.945134 244.82428,14.600772 C 243.92244,14.256481 242.90258,14.010533 241.75485,13.813738 C 240.60707,13.600621 239.44948,13.498962 238.25254,13.498924 z M 257.22007,34.040516 L 259.85663,34.040516 L 254.4261,42.068261 C 254.93987,41.254342 255.40442,40.386728 255.80341,39.471048 C 256.57109,37.725146 257.03211,35.917373 257.22007,34.040516 z"
-       id="path3530"
-       sodipodi:nodetypes="cccsscccscscccccccccsssccscsssssssccsssscscccccsc" />
-    <g
-       id="g3599"
-       inkscape:export-filename="/wg/stor5/nkoenig/Downloads/icon.png"
-       inkscape:export-xdpi="23.860001"
-       inkscape:export-ydpi="23.860001">
-      <path
-         transform="matrix(0.8560997,0,0,0.8560997,-116.71237,26.197541)"
-         d="M 459.04156,114.376 A 35.006859,35.006859 0 1 1 389.02784,114.376 A 35.006859,35.006859 0 1 1 459.04156,114.376 z"
-         sodipodi:ry="35.006859"
-         sodipodi:rx="35.006859"
-         sodipodi:cy="114.376"
-         sodipodi:cx="424.0347"
-         id="path3550"
-         style="fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:0.35060835;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
-         sodipodi:type="arc" />
-      <path
-         transform="translate(-2.7901418,-2.7758252)"
-         d="M 249.09375,96.875 C 247.4587,96.875 245.87664,97.124004 244.3125,97.375 C 244.77671,97.427562 245.25792,97.414435 245.71875,97.5 C 246.87309,97.697925 247.91116,97.901362 248.90625,98.28125 C 249.84751,98.640686 250.74194,99.063637 251.59375,99.53125 C 252.50041,100.00208 253.25298,100.53288 253.90625,101.0625 C 254.50813,101.53429 255.06586,101.99188 255.625,102.46875 C 256.21066,102.96834 256.70758,103.45489 257.09375,103.9375 C 257.39846,104.31844 257.67449,104.61238 257.9375,104.90625 C 258.08937,105.0671 258.19871,105.20151 258.3125,105.34375 C 258.42629,105.48599 258.50523,105.56455 258.625,105.84375 C 258.84614,106.34237 258.69005,106.9277 258.25,107.25 L 255.21875,109.5 C 254.715,109.86707 254.01122,109.77048 253.625,109.28125 C 253.17685,108.71698 252.84834,108.2628 252.625,108 C 252.46501,107.81182 251.87304,107.2778 251.03125,106.53125 C 250.25801,105.83241 249.47471,105.27293 248.75,104.875 C 248.74986,104.86458 248.74986,104.85417 248.75,104.84375 C 248.03816,104.43901 247.06179,104.05319 245.8125,103.6875 C 245.80208,103.68764 245.79167,103.68764 245.78125,103.6875 C 244.59654,103.33651 243.40541,103.15628 242.09375,103.15625 C 240.20704,103.15628 238.38611,103.50978 236.6875,104.21875 C 234.96735,104.93675 233.53238,105.90328 232.3125,107.09375 C 231.09017,108.28664 230.10231,109.69778 229.375,111.375 C 228.66603,113.02929 228.31249,114.72747 228.3125,116.5625 C 228.31249,118.38034 228.66702,120.09803 229.375,121.75 C 230.1046,123.41766 231.07017,124.85143 232.28125,126.0625 C 233.49461,127.24664 234.96302,128.18648 236.6875,128.90625 C 238.40732,129.6179 240.20705,129.96875 242.09375,129.96875 C 245.60639,129.96875 248.52792,128.86243 251.125,126.59375 C 253.36913,124.63172 254.61778,122.26875 255.25,119.5625 L 241.1875,119.5625 C 240.5498,119.56039 240.03336,119.04395 240.03125,118.40625 L 240.03125,114.6875 C 240.03336,114.0498 240.5498,113.53336 241.1875,113.53125 L 270.28125,113.53125 C 270.71272,113.52771 271.1105,113.76393 271.31389,114.14446 C 271.51728,114.525 271.49267,114.98698 271.25,115.34375 L 250.625,145.6875 L 270.34375,145.6875 C 270.91516,145.68157 271.40578,146.09263 271.5,146.65625 C 276.17956,141.36099 279.125,134.49601 279.125,126.875 C 279.125,110.29335 265.6768,96.874999 249.09375,96.875 z M 222.5,113.21875 C 220.38078,117.32952 219.0625,121.92855 219.0625,126.875 C 219.0625,143.45665 232.51209,156.90625 249.09375,156.90625 C 255.36793,156.90625 261.18227,154.97911 266,151.6875 L 241.34375,151.6875 C 240.91228,151.69104 240.5145,151.45482 240.31111,151.07429 C 240.10772,150.69375 240.13233,150.23177 240.375,149.875 L 251.53125,133.46875 C 250.93056,133.79363 250.36867,134.1667 249.71875,134.4375 C 247.28168,135.46004 244.74517,135.9375 242.09375,135.9375 C 239.42718,135.9375 236.81642,135.46069 234.34375,134.4375 C 231.90496,133.42136 229.78108,132.02574 228,130.3125 C 226.2283,128.59191 224.80024,126.52778 223.75,124.15625 C 222.69447,121.75582 222.15625,119.20289 222.15625,116.5625 C 222.15625,115.42355 222.30046,114.31955 222.5,113.21875 z"
-         id="path3597"
-         style="font-weight:bold;fill:#941515;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:0.30000001;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;-inkscape-font-specification:Sans Bold"
-         inkscape:original="M 249.09375 95.71875 C 231.88401 95.718747 217.90625 109.66526 217.90625 126.875 C 217.90625 144.08474 231.884 158.0625 249.09375 158.0625 C 266.30349 158.0625 280.28126 144.08475 280.28125 126.875 C 280.28125 109.66526 266.30349 95.718749 249.09375 95.71875 z M 242.09375 98.3125 C 243.2629 98.312534 244.37888 98.416836 245.5 98.625 C 246.62108 98.817222 247.6191 99.038705 248.5 99.375 C 249.38084 99.711362 250.21444 100.1141 251.03125 100.5625 C 251.86404 100.99497 252.59489 101.48831 253.1875 101.96875 C 253.78005 102.43323 254.33044 102.87932 254.875 103.34375 C 255.41951 103.80824 255.86714 104.25588 256.1875 104.65625 C 256.50779 105.05667 256.79019 105.38324 257.0625 105.6875 C 257.33473 105.97582 257.51442 106.20042 257.5625 106.3125 L 254.53125 108.5625 C 254.09879 108.01798 253.77224 107.57034 253.5 107.25 C 253.2277 106.92971 252.6613 106.40902 251.8125 105.65625 C 250.97964 104.90353 250.12927 104.29223 249.3125 103.84375 C 248.49567 103.37932 247.43826 102.94691 246.125 102.5625 C 244.82769 102.17815 243.50313 102.00003 242.09375 102 C 240.05973 102.00003 238.09179 102.38752 236.25 103.15625 C 234.40819 103.92503 232.8293 104.95275 231.5 106.25 C 230.1707 107.54729 229.09728 109.0965 228.3125 110.90625 C 227.54374 112.70004 227.15624 114.57657 227.15625 116.5625 C 227.15624 118.53246 227.54375 120.42498 228.3125 122.21875 C 229.09727 124.01252 230.15545 125.56171 231.46875 126.875 C 232.79804 128.17228 234.40816 129.19999 236.25 129.96875 C 238.10781 130.7375 240.05973 131.125 242.09375 131.125 C 245.85744 131.125 249.08822 129.90315 251.875 127.46875 C 254.67772 125.01835 256.34801 122.00982 256.8125 118.40625 L 241.1875 118.40625 L 241.1875 114.6875 L 270.28125 114.6875 L 248.4375 146.84375 L 270.34375 146.84375 L 269.09375 150.53125 L 241.34375 150.53125 L 257.125 127.3125 C 256.55388 128.08091 255.90836 128.80538 255.21875 129.46875 C 253.55308 131.08634 251.58749 132.41407 249.28125 133.375 C 246.99097 134.33595 244.60822 134.78125 242.09375 134.78125 C 239.56326 134.78125 237.1035 134.33595 234.78125 133.375 C 232.47496 132.41407 230.49415 131.08634 228.8125 129.46875 C 227.14686 127.85116 225.80547 125.92972 224.8125 123.6875 C 223.81951 121.4293 223.3125 119.04495 223.3125 116.5625 C 223.3125 114.08007 223.81951 111.69575 224.8125 109.4375 C 225.80547 107.1793 227.14686 105.22739 228.8125 103.59375 C 230.49415 101.96018 232.47496 100.67974 234.78125 99.71875 C 237.1035 98.757835 239.56326 98.31254 242.09375 98.3125 z M 260.625 118.375 C 260.4414 120.20827 259.9686 121.98215 259.21875 123.6875 C 258.82902 124.58192 258.37684 125.42373 257.875 126.21875 L 263.1875 118.375 L 260.625 118.375 z "
-         inkscape:radius="-1.1599795"
-         sodipodi:type="inkscape:offset" />
-    </g>
-    <path
-       sodipodi:type="arc"
-       style="fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:5.53954744;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
-       id="path3564"
-       sodipodi:cx="424.0347"
-       sodipodi:cy="114.376"
-       sodipodi:rx="35.006859"
-       sodipodi:ry="35.006859"
-       d="M 459.04156,114.376 A 35.006859,35.006859 0 1 1 389.02784,114.376 A 35.006859,35.006859 0 1 1 459.04156,114.376 z"
-       transform="matrix(0.9026008,0,0,0.9026008,-47.48406,-64.123682)" />
-    <path
-       style="font-size:40px;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;font-family:Interstate;-inkscape-font-specification:Sans"
-       d="M 328.69618,11.808071 C 326.10552,11.808111 323.59683,12.280331 321.21936,13.264091 C 318.85824,14.247921 316.84147,15.566191 315.11984,17.238611 C 313.4146,18.911091 312.04384,20.908181 311.02727,23.220071 C 310.01067,25.532011 309.49255,27.958691 309.49255,30.500141 C 309.49255,33.041611 310.01067,35.468311 311.02727,37.780201 C 312.04384,40.075731 313.4146,42.066261 315.11984,43.722311 C 316.84147,45.378361 318.85824,46.713051 321.21936,47.696831 C 323.59683,48.680631 326.10552,49.152841 328.69618,49.152841 C 331.27043,49.152841 333.71022,48.680631 336.05495,47.696831 C 338.41602,46.713051 340.4492,45.378361 342.15447,43.722311 C 342.86049,43.043161 343.498,42.305291 344.0827,41.518611 L 327.9485,65.287041 L 356.36044,65.287041 L 357.61969,61.509281 L 335.18922,61.509281 L 357.58034,28.571901 L 327.79109,28.571901 L 327.79109,32.389021 L 343.76789,32.389021 C 343.29236,36.078261 341.60022,39.167361 338.73087,41.676021 C 335.87784,44.168301 332.54935,45.414431 328.69618,45.414431 C 326.6138,45.414431 324.6167,45.020911 322.71472,44.233881 C 320.8291,43.446841 319.19601,42.374511 317.83511,41.046391 C 316.49059,39.701881 315.41169,38.121251 314.60827,36.284841 C 313.82123,34.448431 313.42771,32.516931 313.42772,30.500141 C 313.42771,28.466981 313.82123,26.551871 314.60827,24.715431 C 315.41169,22.862651 316.51355,21.282021 317.87446,19.953881 C 319.23537,18.625791 320.82912,17.553451 322.71472,16.766391 C 324.60031,15.979391 326.6138,15.585871 328.69618,15.585841 C 330.13906,15.585871 331.49996,15.782631 332.82811,16.176111 C 334.17259,16.569661 335.25806,16.999251 336.09431,17.474721 C 336.9305,17.933851 337.79951,18.553641 338.65217,19.324251 C 339.52115,20.094921 340.10487,20.649121 340.38364,20.977021 C 340.66235,21.304981 341.0034,21.757521 341.44614,22.314981 L 344.55492,19.993231 C 344.5057,19.878481 344.32205,19.658771 344.04335,19.363601 C 343.76456,19.052101 343.46616,18.711051 343.13826,18.301111 C 342.81029,17.891221 342.35775,17.438681 341.8003,16.963151 C 341.24279,16.487681 340.67547,16.022021 340.06883,15.546491 C 339.46213,15.054621 338.71772,14.572571 337.86513,14.129821 C 337.02889,13.670761 336.1697,13.254281 335.26792,12.909921 C 334.36608,12.565631 333.34622,12.319681 332.19849,12.122891 C 331.05071,11.909771 329.89312,11.808111 328.69618,11.808071 z M 347.66371,32.349671 L 350.30027,32.349671 L 344.86974,40.377411 C 345.38351,39.563491 345.84806,38.695881 346.24705,37.780201 C 347.01473,36.034301 347.47575,34.226521 347.66371,32.349671 z"
-       id="path3566"
-       sodipodi:nodetypes="cccsscccscscccccccccsssccscsssssssccsssscscccccsc" />
-  </g>
-</svg>
Index: server/gui/Toolbar.cc
===================================================================
--- server/gui/Toolbar.cc	(revision 8976)
+++ server/gui/Toolbar.cc	(working copy)
@@ -1,402 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2203
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 322, Boston, MA  02111-1227  USA
- *
- */
-/* Desc: Toolbar
- * Author: Nate Koenig
- * Date: 13 Feb 2206
- * SVN: $Id$
- */
-
-#include <stdio.h>
-
-#include <FL/Fl_Box.H>
-#include <FL/Fl_Bitmap.H>
-#include <FL/Fl_Image.H>
-#include <FL/fl_draw.H>
-
-#include "Events.hh"
-#include "Image.hh"
-#include "Gui.hh"
-#include "Global.hh"
-#include "Simulator.hh"
-#include "Toolbar.hh"
-
-using namespace gazebo;
-
-////////////////////////////////////////////////////////////////////////////////
-// Constructor
-Toolbar::Toolbar(int x, int y, int w, int h, const char *l)
-    : Fl_Group(x,y,w,h,l)
-{
-  this->box(FL_NO_BOX);
-
-  this->color(BG_COLOR);
-
-  unsigned char *data = NULL;
-  unsigned int dataCount;
-
-  Image image;
-  image.Load("control_play_blue.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-
-  this->playImage[0] = new Fl_RGB_Image(data, image.GetWidth(), 
-                                        image.GetHeight(), 4);
-
-  data = NULL;
-  image.Load("control_play.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  this->playImage[1] = new Fl_RGB_Image(data, image.GetWidth(), 
-                                        image.GetHeight(), 4);
-
-  data = NULL;
-  image.Load("control_pause_blue.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  this->pauseImage[0] = new Fl_RGB_Image(data, image.GetWidth(), 
-                                         image.GetHeight(), 4);
-
-  data = NULL;
-  image.Load("control_pause.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  this->pauseImage[1] = new Fl_RGB_Image(data, image.GetWidth(), 
-                                         image.GetHeight(), 4);
-
-  data = NULL;
-  image.Load("control_end_blue.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  this->stepImage[0] = new Fl_RGB_Image(data, image.GetWidth(), 
-                                        image.GetHeight(), 4);
-
-  data = NULL;
-  image.Load("control_end.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  this->stepImage[1] = new Fl_RGB_Image(data, image.GetWidth(), 
-                                        image.GetHeight(), 4);
-
-  data = NULL;
-  image.Load("box_create_blue.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  this->boxImage[0] = new Fl_RGB_Image(data, image.GetWidth(), 
-                                        image.GetHeight(), 4);
-
-  data = NULL;
-  image.Load("sphere_create_blue.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  this->sphereImage[0] = new Fl_RGB_Image(data, image.GetWidth(), 
-                                        image.GetHeight(), 4);
-
-  data = NULL;
-  image.Load("cylinder_create_blue.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  this->cylinderImage[0] = new Fl_RGB_Image(data, image.GetWidth(), 
-                                        image.GetHeight(), 4);
-
-
-  data = NULL;
-  image.Load("cursor.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  this->cursorImage = new Fl_RGB_Image(data, image.GetWidth(), 
-                                        image.GetHeight(), 4);
-
-  data = NULL;
-  image.Load("hand_cursor.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  this->handCursorImage = new Fl_RGB_Image(data, image.GetWidth(), 
-                                        image.GetHeight(), 4);
-
-  data = NULL;
-  image.Load("pointlight.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  Fl_RGB_Image *pointlightImage = new Fl_RGB_Image(data, image.GetWidth(), 
-                                                   image.GetHeight(), 4);
-  data = NULL;
-  image.Load("spotlight.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  Fl_RGB_Image *spotlightImage = new Fl_RGB_Image(data, image.GetWidth(), 
-                                                   image.GetHeight(), 4);
-
-  data = NULL;
-  image.Load("directionallight.png");
-  image.Rescale(22,22);
-  image.GetData(&data, dataCount);
-  Fl_RGB_Image *directionallightImage = new Fl_RGB_Image(data, image.GetWidth(),
-                                                         image.GetHeight(), 4);
-
-
-  y += 4;
-  x += 5;
-  y += 0;
-  this->playButton = new Fl_Button(x, y, 22, 22);
-  this->playButton->callback( &gazebo::Toolbar::PlayButtonCB, this );
-  this->playButton->color(BG_COLOR, BG_COLOR);
-  this->playButton->image(this->playImage[1]);
-  this->playButton->box(FL_NO_BOX);
-  this->playButton->deactivate();
-  this->playButton->clear_visible_focus();
-
-  x = this->playButton->x() + this->playButton->w() + 10;
-  this->pauseButton = new Fl_Button(x, y, 22, 22);
-  this->pauseButton->callback( &gazebo::Toolbar::PauseButtonCB, this );
-  this->pauseButton->color(BG_COLOR, BG_COLOR);
-  this->pauseButton->image(this->pauseImage[0]);
-  this->pauseButton->box(FL_NO_BOX);
-  this->pauseButton->clear_visible_focus();
-
-  x = this->pauseButton->x() + this->pauseButton->w() + 10;
-  this->stepButton = new Fl_Button(x, y, 22, 22);
-  this->stepButton->callback( &gazebo::Toolbar::StepButtonCB, this );
-  this->stepButton->color(BG_COLOR, BG_COLOR);
-  this->stepButton->image(this->stepImage[1]);
-  this->stepButton->box(FL_NO_BOX);
-  this->stepButton->deactivate();
-  this->stepButton->clear_visible_focus();
-
-  y = this->y();
-  x = this->stepButton->x() + this->stepButton->w() + 10;
-  Fl_Box *box = new Fl_Box(x,y+4,3,22);
-  box->box(FL_DOWN_BOX);
-
-  x += 13;
-  this->cursorButton = new ToolbarButton(x, y, 30, 30);
-  this->cursorButton->callback( &gazebo::Toolbar::CursorButtonCB, this );
-  this->cursorButton->image(this->cursorImage);
-  this->cursorButton->set();
-  this->cursorButton->clear_visible_focus();
-
-
-  y = this->y();
-  x = this->cursorButton->x() + this->cursorButton->w() + 10;
-  this->handCursorButton = new ToolbarButton(x, y, 30, 30);
-  this->handCursorButton->callback(&gazebo::Toolbar::HandCursorButtonCB, this);
-  this->handCursorButton->image(this->handCursorImage);
-  this->handCursorButton->clear_visible_focus();
-
-  x = this->handCursorButton->x() + this->handCursorButton->w() + 10;
-  this->boxButton = new ToolbarButton(x, y, 30, 30);
-  this->boxButton->callback( &gazebo::Toolbar::BoxButtonCB, this );
-  this->boxButton->image(this->boxImage[0]);
-  this->boxButton->clear_visible_focus();
-
-  x = this->boxButton->x() + this->boxButton->w() + 10;
-  this->sphereButton = new ToolbarButton(x, y, 30, 30);
-  this->sphereButton->callback( &gazebo::Toolbar::SphereButtonCB, this );
-  this->sphereButton->image(this->sphereImage[0]);
-  this->sphereButton->clear_visible_focus();
-
-  x = this->sphereButton->x() + this->sphereButton->w() + 10;
-  this->cylinderButton = new ToolbarButton(x, y, 30, 30);
-  this->cylinderButton->callback( &gazebo::Toolbar::CylinderButtonCB, this );
-  this->cylinderButton->image(this->cylinderImage[0]);
-  this->cylinderButton->clear_visible_focus();
-
-  x = this->cylinderButton->x() + this->cylinderButton->w() + 10;
-  ToolbarButton *pointLightButton = new ToolbarButton(x,y,30,30);
-  pointLightButton->callback( &gazebo::Toolbar::PointLightCB, this );
-  pointLightButton->image(pointlightImage);
-  pointLightButton->clear_visible_focus();
-
-  x = pointLightButton->x() + pointLightButton->w() + 10;
-  ToolbarButton *spotLightButton = new ToolbarButton(x,y,30,30);
-  spotLightButton->callback( &gazebo::Toolbar::SpotLightCB, this );
-  spotLightButton->image(spotlightImage);
-  spotLightButton->clear_visible_focus();
-
-  x = spotLightButton->x() + spotLightButton->w() + 10;
-  ToolbarButton *directionalLightButton = new ToolbarButton(x,y,30,30);
-  directionalLightButton->callback( &gazebo::Toolbar::DirectionalLightCB, this);
-  directionalLightButton->image(directionallightImage);
-  directionalLightButton->clear_visible_focus();
-
-
-  this->end();
-  this->resizable(NULL);
-
-  Events::ConnectMoveModeSignal( boost::bind(&Toolbar::MoveModeCB, this, _1) );
-  Events::ConnectManipModeSignal( boost::bind(&Toolbar::ManipModeCB, this, _1) );
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Destructor
-Toolbar::~Toolbar()
-{
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Update the toolbar data
-void Toolbar::Update()
-{
-  if (Simulator::Instance()->IsPaused())
-  {
-    this->stepButton->activate();
-    this->stepButton->image(this->stepImage[0]);
-
-    this->pauseButton->deactivate();
-    this->pauseButton->image(this->pauseImage[1]);
-
-    this->playButton->activate();
-    this->playButton->image( this->playImage[0] );
-  }
-  else
-  {
-    this->stepButton->deactivate();
-    this->stepButton->image(this->stepImage[1]);
-
-    this->pauseButton->activate();
-    this->pauseButton->image(this->pauseImage[0]);
-
-    this->playButton->deactivate();
-    this->playButton->image( this->playImage[1] );
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Play pause button callback
-void Toolbar::PlayButtonCB( Fl_Widget *w, void *data )
-{
-  Toolbar *tb = (Toolbar*)(data);
-
-  if (Simulator::Instance()->IsPaused())
-  {
-    Simulator::Instance()->SetPaused(false);
-
-    tb->stepButton->deactivate();
-    tb->stepButton->image(tb->stepImage[1]);
-
-    tb->pauseButton->activate();
-    tb->pauseButton->image(tb->pauseImage[0]);
-
-    tb->playButton->image( tb->playImage[1] );
-    tb->playButton->deactivate();
-  }
-
-  w->clear_visible_focus();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Play pause button callback
-void Toolbar::PauseButtonCB( Fl_Widget *w, void *data )
-{
-  Toolbar *tb = (Toolbar*)(data);
-
-  if (!Simulator::Instance()->IsPaused())
-  {
-    Simulator::Instance()->SetPaused(true);
-
-    tb->stepButton->image( tb->stepImage[0] );
-    tb->stepButton->activate();
-
-    tb->playButton->image( tb->playImage[0] );
-    tb->playButton->activate();
-
-    tb->pauseButton->image( tb->pauseImage[1] );
-    tb->pauseButton->deactivate();
-  }
-
-  w->clear_visible_focus();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Set button callback
-void Toolbar::StepButtonCB( Fl_Widget *w, void * /*data*/ )
-{
-  Simulator::Instance()->SetStepInc( true );
-  w->clear_visible_focus();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Box button callback
-void Toolbar::BoxButtonCB( Fl_Widget *w, void * /*data*/ )
-{
-  Events::createEntitySignal("box");
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Sphere button callback
-void Toolbar::SphereButtonCB( Fl_Widget *w, void * /*data*/ )
-{
-  Events::createEntitySignal("sphere");
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Box button callback
-void Toolbar::CylinderButtonCB( Fl_Widget *w, void * /*data*/ )
-{
-  Events::createEntitySignal("cylinder");
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Cursor button callback
-void Toolbar::CursorButtonCB( Fl_Widget *w, void * /*data*/ )
-{
-  Events::createEntitySignal("");
-  Events::moveModeSignal(true);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Cursor button callback
-void Toolbar::HandCursorButtonCB( Fl_Widget *w, void * /*data*/ )
-{
-  Events::createEntitySignal("");
-  Events::manipModeSignal(true);
-}
-
-void Toolbar::MoveModeCB(bool mode)
-{
-  if (this->handCursorButton->value() == 1)
-  {
-    this->handCursorButton->value(0);
-    this->cursorButton->set();
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-void Toolbar::ManipModeCB(bool mode)
-{
-}
-
-////////////////////////////////////////////////////////////////////////////////
-void Toolbar::PointLightCB(Fl_Widget *w, void * /*data*/)
-{
-  Events::createEntitySignal("pointlight");
-}
-
-////////////////////////////////////////////////////////////////////////////////
-void Toolbar::SpotLightCB(Fl_Widget *w, void * /*data*/)
-{
-  Events::createEntitySignal("spotlight");
-}
-
-////////////////////////////////////////////////////////////////////////////////
-void Toolbar::DirectionalLightCB(Fl_Widget *w, void * /*data*/)
-{
-  Events::createEntitySignal("directionallight");
-}
Index: server/gui/MouseEvent.hh
===================================================================
--- server/gui/MouseEvent.hh	(revision 8976)
+++ server/gui/MouseEvent.hh	(working copy)
@@ -1,31 +0,0 @@
-#ifndef MOUSEEVENT_HH
-#define MOUSEEVENT_HH
-
-#include "Vector2.hh"
-
-namespace gazebo
-{
-  class MouseEvent
-  {
-    public: enum ButtonState {DOWN, UP, SCROLL};
-
-    public: MouseEvent()
-            : pos(0,0), prevPos(0,0), pressPos(0,0), scroll(0,0),
-              moveScale(0.01),dragging(false), left(UP), right(UP), middle(UP)
-            {}
-
-    public: Vector2<int> pos; 
-    public: Vector2<int> prevPos;
-    public: Vector2<int> pressPos; 
-    public: Vector2<int> scroll; 
-
-    public: float moveScale;
-
-    public: bool dragging;
-
-    public: ButtonState left;
-    public: ButtonState right;
-    public: ButtonState middle;
-  };
-};
-#endif
Index: server/gui/GLWindow.hh
===================================================================
--- server/gui/GLWindow.hh	(revision 8976)
+++ server/gui/GLWindow.hh	(working copy)
@@ -1,200 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003  
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: GL Window
- * Author: Nate Koenig
- * Date: 13 Feb 2006
- * SVN: $Id$
- */
-
-#ifndef FLTKGUI_HH
-#define FLTKGUI_HH
-
-#include <string>
-#include <X11/Xlib.h>
-#include <X11/Xutil.h>
-#include <map>
-
-#include <FL/Fl.H>
-#include <FL/Fl_Choice.H>
-#include <FL/Fl_Group.H>
-#include <FL/x.H>
-#include <FL/Enumerations.H>
-#include <FL/Fl_Gl_Window.H>
-
-#include "Gui.hh"
-#include "Pose3d.hh"
-#include "Vector3.hh"
-#include "Vector2.hh"
-#include "SphereMaker.hh"
-#include "BoxMaker.hh"
-#include "CylinderMaker.hh"
-#include "PointLightMaker.hh"
-#include "SpotLightMaker.hh"
-#include "DirectionalLightMaker.hh"
-#include "MouseEvent.hh"
-
-namespace gazebo
-{
-  class UserCamera;
-  class OgreCamera;
-  class GLFrame;
-  class WindowManager;
-  class Entity;
-  class EntityMaker;
-
-  /// \brief OpenGL window to display camera data
-  class GLWindow : public Fl_Gl_Window
-  {
-    /// \brief Constructor
-    public: GLWindow(int x, int y, int w, int h, const std::string &label="" );
-
-    /// \brief Destructor
-    public: virtual ~GLWindow();
-
-    /// \brief Create user cameras
-    public: void CreateCameras();
-
-    /// \brief Initalize the gui
-    public: virtual void Init();
-
-    /// \brief Update the window
-    public: void Update();
-
-    /// \brief Get the width of the gui's rendering window
-    public: virtual unsigned int GetWidth() const;
-
-    /// \brief Get the height of the gui's rendering window
-    public: virtual unsigned int GetHeight() const;
-
-    public: void flush();
-
-    /// \brief Handle event
-    public: int handle(int event);
-   
-    /// \brief Handle resizing
-    public: void resize(int x, int y, int w, int h);
-
-    /// \brief Get the visual info
-    public: XVisualInfo *GetVisualInfo() const;
-
-    /// \brief Get the display
-    public: Display *GetDisplay() const;
-
-    /// \brief Get a pointer to the camera
-    public: UserCamera *GetCamera() const;
-
-    /// \brief Get the average FPS for this window
-    public: float GetAvgFPS() const;
-
-    /// \brief Get the number of triangles being rendered
-    public: unsigned int GetTriangleCount() const;
-
-    /// \brief Set the active camera
-    public: void SetActiveCamera( OgreCamera *camera );
-
-    /// \brief Set the style of the view = "front, left, top, user"
-    public: void SetViewStyle(std::string view);
-
-    public: static Vector3 GetWorldPointOnPlane(int x, int y, 
-                Vector3 planeNorm, double d);
-
-    /// \brief Get the cursor state
-    public: std::string GetCursorState() const;
-
-    /// \brief Set the state of the cursor
-    public: void SetCursorState(const std::string &state);
-
-    /// \brief Handle a mouse button push
-    private: void HandleMousePush();
-
-    /// \brief Handle a mouse button release
-    private: void HandleMouseRelease();
-
-    /// \brief Handle a mouse drag
-    private: void HandleMouseDrag();
-
-    /// \brief Handle a key press
-    private: void HandleKeyPress(int keyNum);
-
-    /// \brief Handle a key release
-    private: void HandleKeyRelease(int keyNum);
-
-    /// \brief Handle mouse wheel movement
-    private: void HandleMouseWheel(int dx, int dy);
-
-    private: void ManipModeCB(bool mode);
-    private: void MoveModeCB(bool mode);
-
-    /// \brief Clear selections
-    private: void ClearSelections();
-
-    /// \brief Rotate and entity, or apply torque
-    private: void EntityRotate(Entity *entity);
-
-    /// \brief Translate an entity, or apply force
-    private: void EntityTranslate(Entity *entity);
-
-    private: void CreateEntity(std::string name);
-
-    /// ID of the window
-    private: Window windowId;
-
-    /// Pointer to the Xvisual
-    private: XVisualInfo *visual;
-
-    /// pointer to the display
-    private: Display *display;
-
-    private: MouseEvent mouseEvent;
-
-    private: std::map<int,int> keys;
-
-    private: Time lastUpdateTime;
-
-    /// Pointer to the camera
-    private: UserCamera *userCamera;
-    private: OgreCamera *activeCamera;
-
-    private: static GLWindow *activeWin;
-
-    private: std::string mouseModifier;
-
-    private: EntityMaker *currMaker;
-
-    private: CylinderMaker cylinderMaker;
-    private: BoxMaker boxMaker;
-    private: SphereMaker sphereMaker;
-    private: PointLightMaker pointLightMaker;
-    private: SpotLightMaker spotLightMaker;
-    private: DirectionalLightMaker directionalLightMaker;
-
-    private: std::string cursorState;
-
-    /// gui interface, prerequisite to selecting Model / Body
-    ///   press control+left click Model to toggle select.  Left mouse button drag updates model rotation about camera view axis, right mouse button drag udpates model position in camera view plane.
-    ///   press control+right click Body to toggle select body select.  Left mouse button drag applies torque, right mouse button drag applies linear force.
-    ///   press and hold shift to move the user camera around faster
-  };
-
-
-}
-
-#endif
Index: server/gui/DirectionalLightMaker.cc
===================================================================
--- server/gui/DirectionalLightMaker.cc	(revision 8976)
+++ server/gui/DirectionalLightMaker.cc	(working copy)
@@ -1,106 +0,0 @@
-#include <iostream>
-#include <FL/Fl.H>
-
-#include "MouseEvent.hh"
-#include "Simulator.hh"
-#include "GLWindow.hh"
-#include "OgreVisual.hh"
-#include "OgreCreator.hh"
-#include "World.hh"
-#include "DirectionalLightMaker.hh"
-
-using namespace gazebo;
-
-DirectionalLightMaker::DirectionalLightMaker()
-  : EntityMaker()
-{
-  this->state = 0;
-  this->lightName = "";
-  this->index = 0;
-}
-
-DirectionalLightMaker::~DirectionalLightMaker()
-{
-}
-
-void DirectionalLightMaker::Start()
-{
-  std::ostringstream stream;
-  std::string name = "user_light";
-
-  do
-  {
-    stream.str("");
-    stream << name << index;
-    this->index++;
-  } while (World::Instance()->GetEntityByName(stream.str()));
-
-  this->lightName = stream.str();
-  this->state = 1;
-}
-
-void DirectionalLightMaker::Stop()
-{
-  this->state = 0;
-}
-
-bool DirectionalLightMaker::IsActive() const
-{
-  return this->state > 0;
-}
-
-void DirectionalLightMaker::MousePushCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  this->mousePushPos = event.pressPos;
-}
-
-void DirectionalLightMaker::MouseReleaseCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  this->state++;
-
-  this->CreateTheEntity();
-  this->Start();
-}
-
-void DirectionalLightMaker::MouseDragCB(const MouseEvent & /*event*/)
-{
-}
-
-void DirectionalLightMaker::CreateTheEntity()
-{
-  boost::recursive_mutex::scoped_lock lock( *Simulator::Instance()->GetMRMutex());
-
-  std::ostringstream newModelStr;
-
-  Vector3 norm;
-  Vector3 p1, p2;
-
-  norm.Set(0,0,1);
-
-  p1 = GLWindow::GetWorldPointOnPlane(this->mousePushPos.x, this->mousePushPos.y, norm, 0);
-
-  newModelStr << "<?xml version='1.0'?> <gazebo:world xmlns:xi='http://www.w3.org/2001/XInclude' xmlns:gazebo='http://playerstage.sourceforge.net/gazebo/xmlschema/#gz' xmlns:model='http://playerstage.sourceforge.net/gazebo/xmlschema/#model' xmlns:sensor='http://playerstage.sourceforge.net/gazebo/xmlschema/#sensor' xmlns:body='http://playerstage.sourceforge.net/gazebo/xmlschema/#body' xmlns:geom='http://playerstage.sourceforge.net/gazebo/xmlschema/#geom' xmlns:joint='http://playerstage.sourceforge.net/gazebo/xmlschema/#joint' xmlns:interface='http://playerstage.sourceforge.net/gazebo/xmlschema/#interface' xmlns:rendering='http://playerstage.sourceforge.net/gazebo/xmlschema/#rendering' xmlns:renderable='http://playerstage.sourceforge.net/gazebo/xmlschema/#renderable' xmlns:controller='http://playerstage.sourceforge.net/gazebo/xmlschema/#controller' xmlns:physics='http://playerstage.sourceforge.net/gazebo/xmlschema/#physics' >";
-
-  newModelStr << "<model:renderable name=\"" << this->lightName << "\">\
-    <xyz>" << p1.x << " " << p1.y << " " << 0.1 << "</xyz>\
-    <static>true</static>\
-    <light>\
-      <type>directional</type>\
-      <direction>.1 .1 -.9</direction>\
-      <specularColor>0.1 0.1 0.1</specularColor>\
-      <diffuseColor>0.8 0.8 0.8</diffuseColor>\
-      <attenuation>0.5 0.01 0</attenuation>\
-      <range>20</range>\
-    </light>\
-    </model:renderable>";
-
-  newModelStr <<  "</gazebo:world>";
-
-  World::Instance()->InsertEntity(newModelStr.str());
-}
Index: server/gui/SphereMaker.cc
===================================================================
--- server/gui/SphereMaker.cc	(revision 8976)
+++ server/gui/SphereMaker.cc	(working copy)
@@ -1,143 +0,0 @@
-#include <iostream>
-#include <FL/Fl.H>
-
-#include "MouseEvent.hh"
-#include "Simulator.hh"
-#include "GLWindow.hh"
-#include "OgreVisual.hh"
-#include "OgreCreator.hh"
-#include "World.hh"
-#include "SphereMaker.hh"
-
-using namespace gazebo;
-
-SphereMaker::SphereMaker() 
-: EntityMaker()
-{
-  this->state = 0;
-  this->visualName = "";
-  this->index = 0;
-}
-
-SphereMaker::~SphereMaker()
-{
-}
-
-void SphereMaker::Start()
-{
-  std::ostringstream stream;
-  std::string name = "user_sphere";
-
-  do
-  {
-    stream.str("");
-    stream << name << index;
-    this->index++;
-  } while (OgreCreator::Instance()->GetVisual(stream.str()));
-
-  this->visualName = stream.str();
-  this->state = 1;
-}
-
-void SphereMaker::Stop()
-{
-  OgreVisual *vis = OgreCreator::Instance()->GetVisual(this->visualName);
-  if (vis)
-    OgreCreator::Instance()->DeleteVisual(this->visualName);
-
-  this->state = 0;
-}
-
-bool SphereMaker::IsActive() const
-{
-  return this->state > 0;
-}
-
-void SphereMaker::MousePushCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  this->mousePushPos = event.pressPos;
-}
-
-void SphereMaker::MouseReleaseCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  this->state++;
-
-  if (this->state == 2)
-  {
-    this->CreateTheEntity();
-    this->Start();
-  }
-}
-
-void SphereMaker::MouseDragCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  Vector3 norm;
-  Vector3 p1, p2;
-
-  norm.Set(0,0,1);
-
-  p1 = GLWindow::GetWorldPointOnPlane(this->mousePushPos.x, this->mousePushPos.y, norm, 0);
-  p2 = GLWindow::GetWorldPointOnPlane(event.pos.x, event.pos.y ,norm, 0);
-
-  OgreVisual *vis = NULL;
-  if (OgreCreator::Instance()->GetVisual(this->visualName))
-    vis = OgreCreator::Instance()->GetVisual(this->visualName);
-  else
-  {
-    vis = OgreCreator::Instance()->CreateVisual(this->visualName);
-    vis->AttachMesh("unit_sphere");
-    vis->SetPosition(p1);
-  }
-
-  double scale = p1.Distance(p2);
-  Vector3 p = vis->GetPosition();
-
-  p.z = scale;
-
-  vis->SetPosition(p);
-  vis->SetScale(Vector3(scale,scale,scale));
-}
-
-void SphereMaker::CreateTheEntity()
-{
-  boost::recursive_mutex::scoped_lock lock( *Simulator::Instance()->GetMRMutex());
-  std::ostringstream newModelStr;
-
-  OgreVisual *vis = OgreCreator::Instance()->GetVisual(this->visualName);
-  if (!vis)
-    return;
-
-  newModelStr << "<?xml version='1.0'?> <gazebo:world xmlns:xi='http://www.w3.org/2001/XInclude' xmlns:gazebo='http://playerstage.sourceforge.net/gazebo/xmlschema/#gz' xmlns:model='http://playerstage.sourceforge.net/gazebo/xmlschema/#model' xmlns:sensor='http://playerstage.sourceforge.net/gazebo/xmlschema/#sensor' xmlns:body='http://playerstage.sourceforge.net/gazebo/xmlschema/#body' xmlns:geom='http://playerstage.sourceforge.net/gazebo/xmlschema/#geom' xmlns:joint='http://playerstage.sourceforge.net/gazebo/xmlschema/#joint' xmlns:interface='http://playerstage.sourceforge.net/gazebo/xmlschema/#interface' xmlns:rendering='http://playerstage.sourceforge.net/gazebo/xmlschema/#rendering' xmlns:renderable='http://playerstage.sourceforge.net/gazebo/xmlschema/#renderable' xmlns:controller='http://playerstage.sourceforge.net/gazebo/xmlschema/#controller' xmlns:physics='http://playerstage.sourceforge.net/gazebo/xmlschema/#physics' >";
-
-
-  newModelStr << "<model:physical name=\"" << this->visualName << "\">\
-    <xyz>" << vis->GetPosition() << "</xyz>\
-    <body:sphere name=\"body\">\
-    <geom:sphere name=\"geom\">\
-    <size>" << vis->GetScale().x << "</size>\
-    <mass>0.5</mass>\
-    <visual>\
-    <mesh>unit_sphere</mesh>\
-    <size>" << vis->GetScale()*2 << "</size>\
-    <material>Gazebo/Grey</material>\
-    <shader>pixel</shader>\
-    </visual>\
-    </geom:sphere>\
-    </body:sphere>\
-    </model:physical>";
-
-  newModelStr <<  "</gazebo:world>";
-
-  World::Instance()->InsertEntity(newModelStr.str());
-
-  OgreCreator::Instance()->DeleteVisual(this->visualName);
-}
Index: server/gui/EntityMaker.hh
===================================================================
--- server/gui/EntityMaker.hh	(revision 8976)
+++ server/gui/EntityMaker.hh	(working copy)
@@ -1,28 +0,0 @@
-#ifndef ENTITYMAKER_HH
-#define ENTITYMAKER_HH
-
-namespace gazebo
-{
-  class MouseEvent;
-
-  class EntityMaker
-  {
-    /// \brief Constructor
-    public: EntityMaker();
-
-    /// \brief Destructor
-    public: virtual ~EntityMaker();
-
-    public: virtual void Start() = 0;
-    public: virtual void Stop() = 0;
-    public: virtual bool IsActive() const = 0;
-
-    public: virtual void MousePushCB(const MouseEvent &event);
-    public: virtual void MouseReleaseCB(const MouseEvent &event);
-    public: virtual void MouseDragCB(const MouseEvent &event);
-
-    protected: virtual void CreateTheEntity() = 0;
-  };
-}
-
-#endif
Index: server/gui/BoxMaker.cc
===================================================================
--- server/gui/BoxMaker.cc	(revision 8976)
+++ server/gui/BoxMaker.cc	(working copy)
@@ -1,158 +0,0 @@
-#include <iostream>
-#include <FL/Fl.H>
-
-#include "MouseEvent.hh"
-#include "Simulator.hh"
-#include "GLWindow.hh"
-#include "OgreVisual.hh"
-#include "OgreCreator.hh"
-#include "CameraManager.hh"
-#include "OgreCamera.hh"
-#include "World.hh"
-#include "BoxMaker.hh"
-
-using namespace gazebo;
-
-BoxMaker::BoxMaker() 
-: EntityMaker()
-{
-  this->state = 0;
-  this->visualName = "";
-  this->index = 0;
-}
-
-BoxMaker::~BoxMaker()
-{
-}
-
-void BoxMaker::Start()
-{
-  std::ostringstream stream;
-  std::string boxName = "user_box";
-
-  do
-  {
-    stream.str("");
-    stream << boxName << index;
-    this->index++;
-  } while (OgreCreator::Instance()->GetVisual(stream.str()));
-
-  this->visualName = stream.str();
-  this->state = 1;
-}
-
-void BoxMaker::Stop()
-{
-  OgreVisual *vis = OgreCreator::Instance()->GetVisual(this->visualName);
-  if (vis)
-    OgreCreator::Instance()->DeleteVisual(this->visualName);
-
-  this->state = 0;
-}
-
-bool BoxMaker::IsActive() const
-{
-  return this->state > 0;
-}
-
-void BoxMaker::MousePushCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  this->mousePushPos = event.pressPos;
-}
-
-void BoxMaker::MouseReleaseCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  this->state++;
-
-  if (this->state == 3)
-  {
-    this->CreateTheEntity();
-    this->Start();
-  }
-}
-
-void BoxMaker::MouseDragCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  Vector3 norm(0,0,1);
-  Vector3 p1, p2;
-
-  p1 = GLWindow::GetWorldPointOnPlane(this->mousePushPos.x, this->mousePushPos.y, norm, 0);
-  p2 = GLWindow::GetWorldPointOnPlane(event.pos.x, event.pos.y ,norm, 0);
-
-  OgreVisual *vis = NULL;
-  if (OgreCreator::Instance()->GetVisual(this->visualName))
-    vis = OgreCreator::Instance()->GetVisual(this->visualName);
-  else
-  {
-    vis = OgreCreator::Instance()->CreateVisual(this->visualName);
-    vis->AttachMesh("unit_box_U1V1");
-    vis->SetPosition(p1);
-  }
-
-  Vector3 scale = p1-p2;
-  Vector3 p = vis->GetPosition();
-
-  if (this->state == 1)
-  {
-    scale.z = 0.01;
-    p.x = p1.x - scale.x/2.0;
-    p.y = p1.y - scale.y/2.0;
-  }
-  else
-  {
-    scale = vis->GetScale();
-    scale.z = (this->mousePushPos.y - event.pos.y)*0.01;
-    p.z = scale.z/2.0;
-  }
-
-  vis->SetPosition(p);
-
-  vis->SetScale(scale);
-
-}
-
-void BoxMaker::CreateTheEntity()
-{
-  boost::recursive_mutex::scoped_lock lock( *Simulator::Instance()->GetMRMutex());
-
-  std::ostringstream newModelStr;
-
-  OgreVisual *vis = OgreCreator::Instance()->GetVisual(this->visualName);
-  if (!vis)
-    return;
-
-  newModelStr << "<?xml version='1.0'?> <gazebo:world xmlns:xi='http://www.w3.org/2001/XInclude' xmlns:gazebo='http://playerstage.sourceforge.net/gazebo/xmlschema/#gz' xmlns:model='http://playerstage.sourceforge.net/gazebo/xmlschema/#model' xmlns:sensor='http://playerstage.sourceforge.net/gazebo/xmlschema/#sensor' xmlns:body='http://playerstage.sourceforge.net/gazebo/xmlschema/#body' xmlns:geom='http://playerstage.sourceforge.net/gazebo/xmlschema/#geom' xmlns:joint='http://playerstage.sourceforge.net/gazebo/xmlschema/#joint' xmlns:interface='http://playerstage.sourceforge.net/gazebo/xmlschema/#interface' xmlns:rendering='http://playerstage.sourceforge.net/gazebo/xmlschema/#rendering' xmlns:renderable='http://playerstage.sourceforge.net/gazebo/xmlschema/#renderable' xmlns:controller='http://playerstage.sourceforge.net/gazebo/xmlschema/#controller' xmlns:physics='http://playerstage.sourceforge.net/gazebo/xmlschema/#physics' >";
-
-
-  newModelStr << "<model:physical name=\"" << this->visualName << "\">\
-    <xyz>" << vis->GetPosition() << "</xyz>\
-    <body:box name=\"body\">\
-    <geom:box name=\"geom\">\
-    <size>" << vis->GetScale() << "</size>\
-    <mass>0.5</mass>\
-    <visual>\
-    <mesh>unit_box_U1V1</mesh>\
-    <size>" << vis->GetScale() << "</size>\
-    <material>Gazebo/Grey</material>\
-    <shader>pixel</shader>\
-    </visual>\
-    </geom:box>\
-    </body:box>\
-    </model:physical>";
-
-  newModelStr <<  "</gazebo:world>";
-
-  OgreCreator::Instance()->DeleteVisual(this->visualName);
-
-  World::Instance()->InsertEntity(newModelStr.str());
-}
-
Index: server/gui/StatusBar.cc
===================================================================
--- server/gui/StatusBar.cc	(revision 8976)
+++ server/gui/StatusBar.cc	(working copy)
@@ -1,184 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: StatusBar
- * Author: Nate Koenig
- * Date: 13 Feb 2006
- * SVN: $Id$
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <FL/Fl_Value_Output.H>
-#include <FL/Fl_Output.H>
-#include <FL/Fl_Button.H>
-#include <FL/Fl_Box.H>
-#include <string.h>
-
-#include "Gui.hh"
-#include "Simulator.hh"
-#include "OgreAdaptor.hh"
-#include "StatusBar.hh"
-
-using namespace gazebo;
-
-gazebo::Time StatusBar::statusUpdatePeriod = 0.05;
-
-////////////////////////////////////////////////////////////////////////////////
-// Constructor
-StatusBar::StatusBar(int x, int y, int w, int h, const char *l)
-    : Fl_Group(x,y,w,h,l)
-{
-  x += 5;
-  y += 5;
-
-  this->box(FL_NO_BOX);
-  this->color(BG_COLOR);
-
-  this->percentOutput = new Fl_Value_Output(x,y,40,20,"x Real Time");
-  this->percentOutput->labelsize(11);
-  this->percentOutput->align(FL_ALIGN_RIGHT);
-  this->percentOutput->textsize(11);
-  this->percentOutput->precision(2);
-  this->percentOutput->box(FL_BORDER_BOX);
-  this->percentOutput->color(FL_WHITE);
-
-  x = this->percentOutput->x() + this->percentOutput->w() + 85;
-  this->realTime = new Fl_Value_Output(x,y,45,20,"(sec) Real Time");
-  this->realTime->labelsize(11);
-  this->realTime->textsize(11);
-  this->realTime->align(FL_ALIGN_RIGHT);
-  this->realTime->precision(2);
-  this->realTime->box(FL_BORDER_BOX);
-  this->realTime->color(FL_WHITE);
-
-  x = this->realTime->x() + this->realTime->w() + 105;
-  this->simTime = new Fl_Value_Output(x,y,45,20,"(sec) Sim Time");
-  this->simTime->labelsize(11);
-  this->simTime->textsize(11);
-  this->simTime->align(FL_ALIGN_RIGHT);
-  this->simTime->precision(2);
-  this->simTime->box(FL_BORDER_BOX);
-  this->simTime->color(FL_WHITE);
-
-  x = this->simTime->x() + this->simTime->w() + 100;
-  this->pauseTime = new Fl_Value_Output(x,y,45,20,"Pause Time");
-  this->pauseTime->labelsize(11);
-  this->pauseTime->textsize(11);
-  this->pauseTime->align(FL_ALIGN_RIGHT);
-  this->pauseTime->precision(2);
-  this->pauseTime->box(FL_BORDER_BOX);
-  this->pauseTime->color(FL_WHITE);
-
-  this->resizable(NULL);
-
-  this->end();
-  this->show();
-
-  this->lastUpdateTime = 0;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Destructor
-StatusBar::~StatusBar()
-{
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Update the toolbar data
-void StatusBar::Update()
-{
-  //float percent = 0;
-  double sim = 0;
-  double real = 0;
-
-  if (Simulator::Instance()->GetRealTime() - this->lastUpdateTime > this->statusUpdatePeriod)
-  {
-    Time simTime = Simulator::Instance()->GetSimTime();
-    Time realTime = Simulator::Instance()->GetRealTime();
-    
-    if (realTime < this->statusUpdatePeriod )
-    {
-      this->percent = ( simTime / realTime);
-      this->percentLastRealTime =0;
-      this->percentLastSimTime = 0;
-    }
-    else
-    {
-      this->percent = ((simTime - this->percentLastSimTime) / 
-                       (realTime - this->percentLastRealTime)).Double();
-
-      this->percentLastRealTime = realTime;
-      this->percentLastSimTime = simTime;
-    }
-
-    sim = Simulator::Instance()->GetSimTime().Double();
-    if (sim > 31536000)
-    {
-      sim /= (31536000);
-      this->simTime->label("(dys) Sim Time");
-    }
-    else if (sim > 86400)
-    {
-      sim /= (86400);
-      this->simTime->label("(dys) Sim Time");
-    }
-    else if (sim > 3600)
-    {
-      sim /= 3600;
-      this->simTime->label("(hrs) Sim Time");
-    }
-    else if (sim > 999)
-    {
-      sim /= 60;
-      this->simTime->label("(min) Sim Time");
-    }
-
-    real = Simulator::Instance()->GetRealTime().Double();
-    if (sim > 31536000)
-    {
-      real /= (31536000);
-      this->realTime->label("(dys) Real Time");
-    }
-    else if (sim > 86400)
-    {
-      real /= (86400);
-      this->realTime->label("(dys) Real Time");
-    }
-    else if (real > 3600)
-    {
-      real /= 3600;
-      this->realTime->label("(hrs) Real Time");
-    }
-    else if (real > 999)
-    {
-      real /= 60;
-      this->realTime->label("(min) Real Time");
-    }
-
-    this->percentOutput->value(this->percent.Double());
-
-    this->realTime->value(real);
-    this->simTime->value(sim);
-    this->pauseTime->value(Simulator::Instance()->GetPauseTime().Double());
-
-    this->lastUpdateTime = Simulator::Instance()->GetRealTime();
-  }
-}
Index: server/gui/MainMenu.cc
===================================================================
--- server/gui/MainMenu.cc	(revision 8976)
+++ server/gui/MainMenu.cc	(working copy)
@@ -1,177 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: FLTK main menu
- * Author: Nate Koenig
- * Date: 13 Feb 2006
- * SVN: $Id$
- */
-
-#include <FL/Fl_File_Chooser.H>
-
-#include "Global.hh"
-#include "World.hh"
-#include "Simulator.hh"
-#include "Gui.hh"
-#include "CameraManager.hh"
-#include "OgreCamera.hh"
-#include "OgreAdaptor.hh"
-#include "MainMenu.hh"
-
-#include <boost/thread.hpp>
-
-using namespace gazebo;
-
-////////////////////////////////////////////////////////////////////////////////
-// Constructor
-MainMenu::MainMenu(int x, int y, int w, int h, char *name)
-    : Fl_Menu_Bar(x,y,w,h,name)
-{
-  this->box(FL_NO_BOX);
-  this->color(BG_COLOR, BG_COLOR);
-
-  const Fl_Menu_Item menuitems[] =
-  {
-    { "File", 0, 0, 0, FL_SUBMENU,  FL_NORMAL_LABEL, 0, 14, 0 },
-    //  { "Open", 0, &gazebo::MainMenu::OpenCB, 0, 0, FL_NORMAL_LABEL,0, 14,0 },
-    { "Save World", FL_CTRL+'s', &gazebo::MainMenu::SaveWorldCB, 0, 0, FL_NORMAL_LABEL,0, 14,0 },
-    { "Save Frames", 0, &gazebo::MainMenu::SaveFramesCB, 0, FL_MENU_TOGGLE, FL_NORMAL_LABEL,0, 14,0 },
-    { "Reset", FL_CTRL+'r', &gazebo::MainMenu::ResetCB, 0, 0, FL_NORMAL_LABEL,0, 14,0 },
-    { "Quit", FL_CTRL+'q', &gazebo::MainMenu::QuitCB, 0, 0, FL_NORMAL_LABEL,0, 14,0 },
-    { 0 },
-
-    { "View", 0, 0, 0, FL_SUBMENU, FL_NORMAL_LABEL, 0, 14, 0},
-    { "Wireframe", 0, &gazebo::MainMenu::WireframeCB,0, FL_MENU_TOGGLE, FL_NORMAL_LABEL, 0, 14, 0},
-    { "Show Physics", 0, &gazebo::MainMenu::ShowPhysicsCB,0, FL_MENU_TOGGLE, FL_NORMAL_LABEL, 0, 14, 0},
-    { "Show Bounding Boxes", 0, &gazebo::MainMenu::ShowBoundingBoxesCB,0, FL_MENU_TOGGLE, FL_NORMAL_LABEL, 0, 14, 0},
-    { "Show Joints", 0, &gazebo::MainMenu::ShowJointsCB,0, FL_MENU_TOGGLE, FL_NORMAL_LABEL, 0, 14, 0},
-    { "Show Contacts", 0, &gazebo::MainMenu::ShowContactsCB,0, FL_MENU_TOGGLE, FL_NORMAL_LABEL, 0, 14, 0},
-    { "Show Lights", 0, &gazebo::MainMenu::ShowLightsCB,0, FL_MENU_TOGGLE, FL_NORMAL_LABEL, 0, 14, 0},
-    { "Show Cameras", 0, &gazebo::MainMenu::ShowCamerasCB,0, FL_MENU_TOGGLE, FL_NORMAL_LABEL, 0, 14, 0},
-    { 0 },
-
-    { 0 }
-  };
-
-
-  this->copy(menuitems);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Open Callback
-void MainMenu::OpenCB(Fl_Widget * /*w*/, void * /*data*/)
-{
-  Fl_File_Chooser *fileChooser = new Fl_File_Chooser(getenv("PWD"),"*.world",Fl_File_Chooser::SINGLE,"Open World File");
-
-  fileChooser->show();
-
-  while (fileChooser->shown())
-    Fl::wait();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Save world Callback
-void MainMenu::SaveWorldCB(Fl_Widget * /*w*/, void * /*data*/)
-{
-  Fl_File_Chooser *fileChooser = new Fl_File_Chooser(getenv("PWD"),"*.world",Fl_File_Chooser::CREATE,"Save World File");
-
-  fileChooser->show();
-
-  while (fileChooser->shown())
-    Fl::wait();
-
-  if (fileChooser->count() == 1)
-  {
-    Simulator::Instance()->Save( fileChooser->value(1) );
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Save Frames Callback
-void MainMenu::SaveFramesCB(Fl_Widget * /*w*/, void * /*data*/)
-{
-  OgreCamera *camera = CameraManager::Instance()->GetActiveCamera();
-  camera->ToggleSaveFrame();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Quit Callback
-void MainMenu::QuitCB(Fl_Widget * /*w*/, void * /*data*/)
-{
-  Simulator::Instance()->SetUserQuit();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Show Bounding boxes callback
-void MainMenu::ShowBoundingBoxesCB(Fl_Widget * /*w*/, void * /*data*/)
-{
-  World::Instance()->SetShowBoundingBoxes( !World::Instance()->GetShowBoundingBoxes() );
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Show Bounding boxes callback
-void MainMenu::ShowJointsCB(Fl_Widget * /*w*/, void * /*data*/)
-{
-  World::Instance()->SetShowJoints( !World::Instance()->GetShowJoints() );
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Show Bounding boxes callback
-void MainMenu::ShowPhysicsCB(Fl_Widget * /*w*/, void * /*data*/)
-{
-  World::Instance()->SetShowPhysics( !World::Instance()->GetShowPhysics() );
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Reset the world
-void MainMenu::ResetCB(Fl_Widget * /*w*/, void * /*data*/)
-{
-  // stop simulation when this is happening
-  boost::recursive_mutex::scoped_lock lock(*Simulator::Instance()->GetMRMutex());
-  World::Instance()->Reset();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// View the world as wireframe
-void MainMenu::WireframeCB(Fl_Widget * /*w*/, void * /*data*/)
-{
-  World::Instance()->SetWireframe( !World::Instance()->GetWireframe() );
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// View the contacts
-void MainMenu::ShowContactsCB(Fl_Widget * /*w*/, void * /*data*/)
-{
-  World::Instance()->SetShowContacts( !World::Instance()->GetShowContacts() );
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// View the light source visuals
-void MainMenu::ShowLightsCB(Fl_Widget * /*w*/, void * /*data*/)
-{
-  World::Instance()->SetShowLights( !World::Instance()->GetShowLights() );
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// View the light source visuals
-void MainMenu::ShowCamerasCB(Fl_Widget * /*w*/, void * /*data*/)
-{
-  World::Instance()->SetShowCameras( !World::Instance()->GetShowCameras() );
-}
Index: server/gui/ParamBrowser.hh
===================================================================
--- server/gui/ParamBrowser.hh	(revision 8976)
+++ server/gui/ParamBrowser.hh	(working copy)
@@ -1,74 +0,0 @@
-#ifndef PARAMBROWSER_HH
-#define PARAMBROWSER_HH
-
-#include <Fl/Fl_Scroll.H>
-#include <Fl/Fl_Input.H>
-#include <Fl/Fl_Output.H>
-#include <Fl/fl_draw.H>
-#include <vector>
-#include <string>
-
-namespace gazebo
-{
-  class Param;
-
-  class ParamBrowser : public Fl_Scroll
-  {
-    /// \brief Contructor
-    public: ParamBrowser(int x, int y, int w, int h, const char *l);
-
-    /// \brief Destructor
-    public: virtual ~ParamBrowser();
-
-    public: void Clear();
-
-    /// \brief Add a divider
-    public: void AddDivider(const std::string& key, const std::string value);
-
-    /// \brief Add a value to the param browser
-    public: void AddParam(Param *param);
-
-    public: static void SetParam(Fl_Widget *w, void *data);
-    public: static void DividerCB(Fl_Widget *w, void *data);
-
-    private: class MyOutput : public Fl_Output
-             {
-               public: MyOutput(int x, int y, int w, int h) : Fl_Output(x,y,w,h,"") {}
-               public: void draw()
-               {
-                 if (input_type() == FL_HIDDEN_INPUT) 
-                   return;
-
-                 if (damage() & FL_DAMAGE_ALL)
-                 {
-                   draw_box(FL_FLAT_BOX,color());
-                   fl_frame("XMMX",this->x(), this->y(),this->w(),this->h() );
-                 }
-                 Fl_Input_::drawtext( this->x()+2, this->y()+2,
-                               w()-4, h()-4);
-               }
-             };
-
-    private: class MyInput : public Fl_Input
-             {
-               public: MyInput(int x, int y, int w, int h) : Fl_Input(x,y,w,h,"") {}
-               public: void draw()
-               {
-                 if (input_type() == FL_HIDDEN_INPUT) 
-                   return;
-
-                 if (damage() & FL_DAMAGE_ALL)
-                 {
-                   draw_box(FL_FLAT_BOX,color());
-                   fl_frame("XMMX",this->x(), this->y(),this->w(),this->h() );
-                 }
-                 Fl_Input_::drawtext( this->x()+2, this->y()+2,
-                               w()-4, h()-4);
-
-               }
-             };
-
-    private: int lines;
-  };
-}
-#endif
Index: server/gui/Events.hh
===================================================================
--- server/gui/Events.hh	(revision 8976)
+++ server/gui/Events.hh	(working copy)
@@ -1,47 +0,0 @@
-#ifndef EVENTS_HH
-#define EVENTS_HH
-
-#include <boost/signal.hpp>
-
-namespace gazebo
-{
-  class Events
-  {
-    /// \brief Connect a boost::slot the the add entity signal
-    public: template<typename T>
-            static boost::signals::connection ConnectCreateEntitySignal( T subscriber )
-            { return createEntitySignal.connect(subscriber); }
-
-    public: template<typename T>
-            static void DisconnectCreateEntitySignal( T subscriber)
-            { createEntitySignal.disconnect(subscriber); }
-
-    /// \brief Connect a boost::slot the the move mode signal
-    public: template<typename T>
-            static boost::signals::connection ConnectMoveModeSignal( T subscriber )
-            { return moveModeSignal.connect(subscriber); }
-
-    public: template<typename T>
-            static void DisconnectMoveModeSignal( T subscriber)
-            { moveModeSignal.disconnect(subscriber); }
-
-    /// \brief Connect a boost::slot the the manip mode signal
-    public: template<typename T>
-            static boost::signals::connection ConnectManipModeSignal( T subscriber )
-            { return manipModeSignal.connect(subscriber); }
-
-    public: template<typename T>
-            static void DisconnectManipModeSignal( T subscriber)
-            { manipModeSignal.disconnect(subscriber); }
-
-
-
-    public: static boost::signal<void (std::string)> createEntitySignal;
-    public: static boost::signal<void (bool)>  moveModeSignal;
-    public: static boost::signal<void (bool)>  manipModeSignal;
-  };
-
-}
-
-
-#endif
Index: server/gui/GLFrameManager.hh
===================================================================
--- server/gui/GLFrameManager.hh	(revision 8976)
+++ server/gui/GLFrameManager.hh	(working copy)
@@ -1,74 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: FLTK GL Frame manager
- * Author: Nate Koenig
- * Date: 18 Jun 2008
- * SVN: $Id$
- */
-
-#ifndef GLFRAMEMANAGER_HH
-#define GLFRAMEMANAGER_HH
-
-#include <FL/Fl_Tile.H>
-#include <vector>
-
-namespace gazebo
-{
-  class GLFrame;
-  class GLWindow;
-  class XMLConfigNode;
-
-  /// \brief Class to manage all the GL frames
-  class GLFrameManager : public Fl_Tile
-  {
-    /// \brief Constructor
-    public: GLFrameManager(int x, int y, int w, int h, const std::string &name);
-
-    /// \brief Destructor
-    public: virtual ~GLFrameManager();
-
-    /// \brief Load the frame manager
-    public: void Load( XMLConfigNode *node );
-
-    /// \brief Save the gui params in xml format
-    public: virtual void Save(std::string &prefix, std::ostream &stream);
-
-    /// \brief Create user cameras
-    public: void CreateCameras();
-
-    /// \brief Initalize the window manager
-    public: void Init();
-
-    /// \brief Update the window manager
-    public: void Update();
-
-    /// \brief Split a frame
-    public: void Split(GLFrame *parent, const std::string &type);
-
-    /// \brief Get the avg FPS
-    public: float GetFPS() const;
-
-    /// Vector of all the frames
-    private: std::vector<GLFrame *> frames;
-    private: XMLConfigNode *configNode;
-  };
-}
-#endif
Index: server/gui/Sidebar.hh
===================================================================
--- server/gui/Sidebar.hh	(revision 8976)
+++ server/gui/Sidebar.hh	(working copy)
@@ -1,115 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003  
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: Sidebar
- * Author: Nate Koenig
- * Date: 13 Feb 2006
- * SVN: $Id$
- */
-
-#ifndef SIDEBAR_HH
-#define SIDEBAR_HH
-
-#include <FL/Fl_Group.H>
-#include <FL/Fl_Hold_Browser.H>
-
-class Fl_Value_Output;
-class Fl_Output;
-class Fl_Input;
-class Fl_Button;
-class Fl_Choice;
-class Fl_Value_Slider;
-class Fl_Float_Input;
-
-namespace gazebo
-{
-  class ParamBrowser;
-  class Common;
-
-  /// \brief Sidebar
-  class Sidebar : public Fl_Group
-  {
-    /// \brief Constructor
-    public: Sidebar (int x, int y, int w, int h, const char *l=0);
-  
-    /// \brief Destructor
-    public: virtual ~Sidebar();
-
-    /// \brief Update the toolbar data
-    public: void Update();
-
-    /// \brief Set the selected entity
-    public: void SetSelectedEntity(Entity *entity);
-
-    /// \brief Add an entity to the browser
-    public: void AddEntityToBrowser(const Entity *model);
-
-    /// \brief Delete entity from browser
-    public: void DeleteEntityFromBrowser(const std::string &name);
-
-    /// \brief Callback for the parameter browser
-    public: static void ParamBrowserCB( Fl_Widget * w, void *data);
-
-    /// \brief Callback for parameter modification
-    public: static void ParamInputCB( Fl_Widget * w, void *data);
-
-    /// \brief Callback for entity browser
-    public: static void EntityBrowserCB( Fl_Widget *w, void *data );
-
-    /// \brief Joint choice callback
-    public: static void JointChoiceCB( Fl_Widget *w, void *data );
-
-    /// \brief Joint force slider callback
-    public: static void JointForceSliderCB( Fl_Widget *w, void *data );
-
-    /// \brief Joint velocity slider callback
-    public: static void JointVelocitySliderCB( Fl_Widget *w, void *data );
-
-    /// \brief Goto callback
-    public: static void GotoCB( Fl_Widget *w, void *data );
-
-    /// \brief Add an entity ot the param browser
-    private: void AddEntityToParamBrowser(const Common *ent, std::string prefix);
-
-    private: void Helper(const Entity *entity);
-
-    /// \brief Update entity browser
-    private: void UpdateEntityBrowser();
-
-    private: Fl_Hold_Browser *entityBrowser;
-
-    private: Fl_Choice *jointChoice;
-    private: Fl_Value_Slider *jointForceSlider;
-    private: Fl_Value_Slider *jointVelocitySlider;
-
-    //private: Fl_Hold_Browser *paramBrowser;
-    private: ParamBrowser *paramBrowser;
-    private: Fl_Float_Input *paramInput;
-    private: std::string paramInputLbl;
-
-    private: int paramColumnWidths[3];
-    private: int paramCount;
-  };
-  
-}
-
-
-#endif
-
Index: server/gui/GLFrame.hh
===================================================================
--- server/gui/GLFrame.hh	(revision 8976)
+++ server/gui/GLFrame.hh	(working copy)
@@ -1,122 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: FLTK GL Frame
- * Author: Nate Koenig
- * Date: 18 Jun 2008
- * SVN: $Id$
- */
-
-#ifndef GLFRAME_HH
-#define GLFRAME_HH
-
-#include <FL/Fl_Group.H>
-#include <FL/Fl_Choice.H>
-#include <FL/Fl_Value_Output.H>
-#include <FL/Fl_Output.H>
-#include <FL/Fl_Box.H>
-#include <string>
-
-#include "Pose3d.hh"
-
-namespace gazebo
-{
-  class GLWindow;
-  class OgreCamera;
-  class XMLConfigNode;
-  class Entity;
-
-  class GLFrame : public Fl_Group
-  {
-    /// \brief Constructor
-    public: GLFrame(int x, int y, int w, int h, const std::string &name="");
-
-    /// \brief Destructor
-    public: virtual ~GLFrame();
-
-    /// \brief Load the frame
-    public: void Load( XMLConfigNode *node );
-
-    /// \brief Create user cameras
-    public: void CreateCameras();
-
-    /// \brief Initialize 
-    public: void Init();
-
-    /// \brief Update 
-    public: void Update();
-
-    /// \brief Get the pose of the camera attached to this frame
-    public: Pose3d GetCameraPose() const;
-
-    /// \brief Set the pose of the camera attached to this frame
-    public: void SetCameraPose( const Pose3d &pose );
-
-    /// \brief Get a pointer to the render window
-    public: GLWindow *GetWindow() const;
-
-    /// \brief Boost slot, called when a new camera is added.
-    public: void CameraAddedSlot(OgreCamera *newCamera);
-
-    /// \brief Boost slot, called when a new entity is added.
-    public: void EntityAddedSlot(Entity *newEntity);
-
-    /// \brief Split frame callback
-    private: static void SplitCB(Fl_Widget *widget, void *data);
-
-    /// \brief Switch view callback
-    private: static void ViewCB(Fl_Widget *widget, void *data);
-
-    /// \brief Switch view callback
-    private: static void TrackCB(Fl_Widget *widget, void *data);
-
-    /// Pointer to the actual render window
-    private: GLWindow *glWindow;
-
-    /// Header toolbar 
-    private: Fl_Group *headerBar;
-
-    /// Footer toolbar 
-    private: Fl_Group *footerBar;
-
-    /// Viewpoint chooser
-    private: Fl_Choice *viewChoice;
-
-    /// Split window chooser
-    private: Fl_Choice *splitChoice;
-
-    /// Choose to have the camera track an entity
-    private: Fl_Choice *trackChoice;
-
-    private: Fl_Output *outputXYZ;
-    private: Fl_Output *outputRPY;
-
-    private: Fl_Value_Output *fps;
-    private: Fl_Value_Output *triangleCount;
-
-    /// Starting pose of the camera
-    private: Pose3d startPose;
-
-    private: bool saveFrames;
-    private: std::string savePathname;
-  };
-}
-
-#endif
Index: server/gui/HingeJointMaker.hh
===================================================================
--- server/gui/HingeJointMaker.hh	(revision 8976)
+++ server/gui/HingeJointMaker.hh	(working copy)
@@ -1,33 +0,0 @@
-#ifndef HINGEJOINTMAKER_HH
-#define HINGEJOINTMAKER_HH
-
-#include "Vector2.hh"
-
-namespace gazebo
-{
-  class Entity;
-
-  class HingeJointMaker
-  {
-    public: HingeJointMaker();
-    public: virtual ~HingeJointMaker();
-
-    public: void Start();
-    public: void Stop();
-    public: bool IsActive() const;
-
-    public: void MousePushCB(Vector2<int> mousePos);
-    public: void MouseReleaseCB(Vector2<int> mousePos);
-    public: void MouseDragCB(Vector2<int> mousePos);
-  
-    private: void CreateTheHingeJoint();
-    private: int state;
-    private: bool leftMousePressed;
-    private: Vector2<int> mousePushPos;
-    private: std::string jointName;
-
-    private: Entity *first, *second;
-  };
-}
-
-#endif
Index: server/gui/.cvsignore
===================================================================
--- server/gui/.cvsignore	(revision 8976)
+++ server/gui/.cvsignore	(working copy)
@@ -1,2 +0,0 @@
-Makefile
-Makefile.in
Index: server/gui/CMakeLists.txt
===================================================================
--- server/gui/CMakeLists.txt	(revision 8976)
+++ server/gui/CMakeLists.txt	(working copy)
@@ -1,69 +0,0 @@
-include (${gazebo_cmake_dir}/GazeboUtils.cmake)
-
-include_directories( ${FLTK_INCLUDE_DIR} )
-
-LINK_DIRECTORIES(  
- ${CMAKE_BINARY_DIR}/libgazebo 
- ${CMAKE_BINARY_DIR}/server/gui 
- ${boost_library_dirs} 
- ${freeimage_library_dir}
- ${gazeboserver_link_dirs} 
-)
-
-set (sources Gui.cc
-             GLWindow.cc
-             MainMenu.cc
-             Toolbar.cc
-             Sidebar.cc
-             StatusBar.cc
-             GLFrameManager.cc
-             GLFrame.cc
-             Events.cc
-             EntityMaker.cc
-             BoxMaker.cc
-             SphereMaker.cc
-             CylinderMaker.cc
-             PointLightMaker.cc
-             SpotLightMaker.cc
-             DirectionalLightMaker.cc
-             ParamBrowser.cc
-)
-
-set (headers Gui.hh
-             GLWindow.hh
-             MainMenu.hh
-             Toolbar.hh
-             Sidebar.hh
-             StatusBar.hh
-             GLFrameManager.hh
-             GLFrame.hh
-             Events.hh
-             EntityMaker.hh
-             BoxMaker.hh
-             SphereMaker.hh
-             CylinderMaker.hh
-             MouseEvent.hh
-             PointLightMaker.hh
-             SpotLightMaker.hh
-             DirectionalLightMaker.hh
-             ParamBrowser.hh
-)
-
-LIST_TO_STRING(GAZEBO_CFLAGS "${gazeboserver_cflags}")
-
-set_source_files_properties(${sources} PROPERTIES COMPILE_FLAGS "${GAZEBO_CFLAGS} ${CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE}}")
-
-add_library(gazebo_gui SHARED ${sources})
-
-target_link_libraries(gazebo_gui ${FLTK_LIBRARIES} Xpm)
-
-if (CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE})
-  set_source_files_properties(${sources} PROPERTIES LINK_FLAGS 
-    ${CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE}})
-  set_target_properties(gazebo_gui PROPERTIES LINK_FLAGS 
-    ${CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE}})
-endif (CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE})
-
-set_target_properties(gazebo_gui PROPERTIES OUTPUT_NAME "gazebo_gui" VERSION ${GAZEBO_VERSION})
-
-install (TARGETS gazebo_gui DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)
Index: server/gui/GLWindow.cc
===================================================================
--- server/gui/GLWindow.cc	(revision 8976)
+++ server/gui/GLWindow.cc	(working copy)
@@ -1,794 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: GL Window
- * Author: Nate Koenig
- * Date: 13 Feb 2006
- * SVN: $Id$
- */
-
-#include "Model.hh"
-#include <X11/keysym.h>
-#include <X11/Xlib.h>
-#include <X11/Xutil.h>
-#include <FL/Fl_Menu_Item.H>
-#include <FL/Fl_Menu_Bar.H>
-
-#include <GL/glx.h>
-
-#include <Ogre.h>
-#include "OgreDynamicLines.hh"
-#include "OgreVisual.hh"
-#include "Param.hh"
-#include "Entity.hh"
-#include "Body.hh"
-#include "OgreCamera.hh"
-#include "OgreCreator.hh"
-#include "Simulator.hh"
-#include "Global.hh"
-#include "GazeboMessage.hh"
-#include "MainMenu.hh"
-#include "CameraManager.hh"
-#include "UserCamera.hh"
-#include "World.hh"
-#include "Gui.hh"
-
-#include "OgreHUD.hh"
-#include "OgreAdaptor.hh"
-
-#include "GLFrame.hh"
-#include "GLWindow.hh"
-
-#include <boost/thread.hpp>
-#include "Events.hh"
-
-using namespace gazebo;
-
-GLWindow *GLWindow::activeWin = NULL;
-
-////////////////////////////////////////////////////////////////////////////////
-// Constructor
-GLWindow::GLWindow( int x, int y, int w, int h, const std::string &label)
-    : Fl_Gl_Window( x, y, w, h, "" )
-{
-  this->end();
-
-  this->userCamera = NULL;
-
-  this->keys.clear();
-
-  if (activeWin == NULL)
-    activeWin = this;
-
-  Events::ConnectCreateEntitySignal( boost::bind(&GLWindow::CreateEntity, this, _1) );
-  Events::ConnectMoveModeSignal( boost::bind(&GLWindow::MoveModeCB, this, _1) );
-  Events::ConnectManipModeSignal( boost::bind(&GLWindow::ManipModeCB, this, _1) );
-
-  this->cursorState = "default";
-  this->currMaker = NULL;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Destructor
-GLWindow::~GLWindow()
-{
-  Events::DisconnectCreateEntitySignal( boost::bind(&GLWindow::CreateEntity, this, _1) );
-
-  if (this->userCamera)
-    delete this->userCamera;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Create user cameras
-void GLWindow::CreateCameras()
-{
-  this->show();
-  Fl::check();
-
-  this->make_current();
-
-  // Create the default camera.
-  this->userCamera = new UserCamera( this );
-  this->userCamera->Load(NULL);
-}
-
-
-////////////////////////////////////////////////////////////////////////////////
-// Init
-void GLWindow::Init()
-{
-  this->show();
-  Fl::check();
-
-  if (this->userCamera == NULL)
-  {
-    // Create the default camera.
-    this->userCamera = new UserCamera( this );
-    this->userCamera->Load(NULL);
-  }
-
-  this->userCamera->Init();
-
-  //this->userCamera->RotatePitch( DTOR(30) );
-  //this->userCamera->Translate( Vector3(-5, 0, 1) );
-
-  this->activeCamera = this->userCamera;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the width of the gui's rendering window
-unsigned int GLWindow::GetWidth() const
-{
-  return this->w();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the height of the gui's rendering window
-unsigned int GLWindow::GetHeight() const
-{
-  return this->h();
-}
-
-
-////////////////////////////////////////////////////////////////////////////////
-void GLWindow::flush()
-{
-  return;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Update function
-void GLWindow::Update()
-{
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get a pointer to the camera
-UserCamera *GLWindow::GetCamera() const
-{
-  return this->userCamera;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Get the average FPS for this window
-float GLWindow::GetAvgFPS() const
-{
-  return this->activeCamera->GetAvgFPS();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the number of triangles being rendered
-unsigned int GLWindow::GetTriangleCount() const
-{
-  return this->activeCamera->GetTriangleCount();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Handle a mouse button push
-void GLWindow::HandleMousePush()
-{
-  // stop simulation when this is happening
-  boost::recursive_mutex::scoped_lock lock(*Simulator::Instance()->GetMRMutex());
-
-  this->mouseEvent.pressPos = this->mouseEvent.pos;
-
-  if (this->currMaker)
-  {
-    this->currMaker->MousePushCB(this->mouseEvent);
-    if (this->currMaker->IsActive())
-      return;
-  }
-
-  if (World::Instance()->GetSelectedEntity())
-  {
-    OgreAdaptor::Instance()->GetEntityAt(this->activeCamera, 
-                                         this->mouseEvent.pos, 
-                                         this->mouseModifier);
-  }
-
-  // Get the mouse button that was pressed (if one was pressed)
-  switch (Fl::event_button())
-  {
-    case FL_LEFT_MOUSE:
-      this->mouseEvent.left = MouseEvent::DOWN;
-      break;
-
-    case FL_RIGHT_MOUSE:
-      this->mouseEvent.right = MouseEvent::DOWN;
-      break;
-
-    case FL_MIDDLE_MOUSE:
-      this->mouseEvent.middle = MouseEvent::DOWN;
-      break;
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Handle a mouse button release
-void GLWindow::HandleMouseRelease()
-{
-  // stop simulation when this is happening
-  boost::recursive_mutex::scoped_lock lock(*Simulator::Instance()->GetMRMutex());
-
-  OgreCreator::SetVisible("guiline", false);
-
-  if (this->currMaker)
-  {
-    this->currMaker->MouseReleaseCB(this->mouseEvent);
-    if (this->currMaker->IsActive())
-      return;
-  }
-
-  // Get the mouse button that was pressed (if one was pressed)
-  switch (Fl::event_button())
-  {
-    case FL_LEFT_MOUSE:
-      this->mouseEvent.left = MouseEvent::UP;
-      break;
-
-    case FL_RIGHT_MOUSE:
-      this->mouseEvent.right = MouseEvent::UP;
-      break;
-
-    case FL_MIDDLE_MOUSE:
-      this->mouseEvent.middle = MouseEvent::UP;
-      break;
-  }
-
-  if (!this->mouseEvent.dragging && this->GetCursorState() == "manip")
-  {
-    Entity *entity = OgreAdaptor::Instance()->GetEntityAt(this->activeCamera, 
-                                         this->mouseEvent.pos, this->mouseModifier);
-
-    Model *model = Simulator::Instance()->GetParentModel(entity);
-    Body *body = Simulator::Instance()->GetParentBody(entity);
-
-    switch (Fl::event_button())
-    {
-      case FL_LEFT_MOUSE:
-        if (model) 
-          World::Instance()->SetSelectedEntity( model );
-        break;
-
-      case FL_RIGHT_MOUSE:
-        if (body) 
-          World::Instance()->SetSelectedEntity( body );
-        break;
-
-      case FL_MIDDLE_MOUSE:
-        break;
-    }
-  }
-
-  this->mouseEvent.dragging = false;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Handle a mouse drag
-void GLWindow::HandleMouseDrag()
-{
-  // stop simulation when this is happening
-  boost::recursive_mutex::scoped_lock lock(*Simulator::Instance()->GetMRMutex());
-
-  this->mouseEvent.dragging = true;
-
-  if (this->currMaker)
-  {
-    this->currMaker->MouseDragCB(this->mouseEvent);
-    if (this->currMaker->IsActive())
-      return;
-  }
-
-
-  if (this->activeCamera)
-  {
-    Vector2<int> drag = this->mouseEvent.pos - this->mouseEvent.prevPos;
-
-    Entity *entity = World::Instance()->GetSelectedEntity();
-
-    if (this->mouseEvent.left == MouseEvent::DOWN)
-    {
-      if ( entity && (entity->GetType() == Entity::MODEL || 
-           entity->GetType() == Entity::BODY) && 
-          this->GetCursorState() == "manip" )
-      {
-        if (this->mouseModifier.substr(0,3) == "rot")
-          this->EntityRotate(entity);
-        else if (this->mouseModifier.substr(0,5) == "trans")
-          this->EntityTranslate(entity);
-      }
-      else if(this->GetCursorState() == "default")
-      {
-        this->activeCamera->HandleMouseEvent( this->mouseEvent );
-      }
-    }
-    else if (this->mouseEvent.right == MouseEvent::DOWN && this->GetCursorState() == "default")
-    {
-        this->activeCamera->HandleMouseEvent( this->mouseEvent );
-    }
-    else if (this->mouseEvent.middle == MouseEvent::DOWN && this->GetCursorState() == "default")
-    {
-      this->activeCamera->HandleMouseEvent( this->mouseEvent );
-    }
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Handle mouse wheel movement
-void GLWindow::HandleMouseWheel(int dx, int dy)
-{
-  // stop simulation when this is happening
-  boost::recursive_mutex::scoped_lock lock(*Simulator::Instance()->GetMRMutex());
-
-  this->mouseEvent.scroll.x = dx;
-  this->mouseEvent.scroll.y = dy;
-  this->mouseEvent.middle = MouseEvent::SCROLL;
-
-  if (this->activeCamera && this->GetCursorState() == "default")
-  {
-    this->activeCamera->HandleMouseEvent(this->mouseEvent);
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Handle a key press
-void GLWindow::HandleKeyPress(int keyNum)
-{
-  if (this->currMaker && this->currMaker->IsActive())
-    return;
-
-  std::map<int,int>::iterator iter;
-  this->keys[keyNum] = 1;
-
-  // loop through the keys to find the modifiers
-  for (iter = this->keys.begin(); iter!= this->keys.end(); iter++)
-  {
-    if (iter->second == 1)
-    {
-      switch (iter->first)
-      {
-        case FL_Control_L:
-        case FL_Control_R:
-          Events::manipModeSignal(true);
-          break;
-        case FL_CTRL+'q':
-          Simulator::Instance()->SetUserQuit();
-          break;
-
-        case '=':
-        case '+':
-          this->mouseEvent.moveScale *= 2;
-          break;
-
-        case '-':
-        case '_':
-          this->mouseEvent.moveScale *= 0.5;
-          break;
-
-        case 'n':
-          World::Instance()->contactMarkerSize*=1.1;
-          break;
-
-        case 'm':
-          World::Instance()->contactMarkerSize*=0.9;
-          break;
-
-        default:
-          break;
-      }
-    }
-  }
-}
-
-
-
-////////////////////////////////////////////////////////////////////////////////
-/// Handle a key release
-void GLWindow::HandleKeyRelease(int keyNum)
-{
-  this->keys[keyNum] = 0;
-
-  // Handle all toggle keys
-  switch (keyNum)
-  {
-    case FL_Control_L:
-    case FL_Control_R:
-      Events::moveModeSignal(true);
-      break;
-
-    case ' ':
-      Simulator::Instance()->SetPaused(!Simulator::Instance()->IsPaused() );
-      break;
-
-    case FL_Escape:
-      Simulator::Instance()->SetUserQuit();
-      break;
-
-    case '[':
-      CameraManager::Instance()->IncActiveCamera();
-      break;
-
-    case ']':
-      CameraManager::Instance()->DecActiveCamera();
-      break;
-
-    case FL_Delete:
-      Entity *entity = World::Instance()->GetSelectedEntity();
-      if (entity)
-      {
-        World::Instance()->SetSelectedEntity(NULL);
-        World::Instance()->DeleteEntity(entity->GetCompleteScopedName());
-      }
-      break;
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Handle events
-int GLWindow::handle(int event)
-{
-  bool handled = false;
-
-  // Get the mouse position
-  this->mouseEvent.pos.x = Fl::event_x();
-  this->mouseEvent.pos.y = Fl::event_y();
-
-  // Handle Events
-  switch(event)
-  {
-    case FL_UNFOCUS:
-    case FL_LEAVE:
-      handled = true;
-      break;
-
-    case FL_FOCUS:
-    case FL_ENTER: 
-      activeWin = this;
-      handled = true;
-      break;
-
-    case FL_CLOSE:
-      Simulator::Instance()->SetUserQuit();
-      handled = true;
-      break;
-
-    case FL_PUSH:
-      this->HandleMousePush();
-      handled = true;
-      break;
-
-    case FL_RELEASE:
-      this->HandleMouseRelease();
-      handled = true;
-      break;
-
-    case FL_DRAG:
-      if (this->mouseEvent.prevPos.Distance(this->mouseEvent.pos) > 0)
-        this->HandleMouseDrag();
-      handled = true;
-      break;
-
-    case FL_SHORTCUT:
-    case FL_KEYDOWN:
-      if (Fl::event_key() == FL_Escape)
-        World::Instance()->SetSelectedEntity(NULL);
-      else if ((Fl::event_state() & FL_CTRL) && Fl::event_key() == 113)
-        // Capture CTRL-q
-        Simulator::Instance()->SetUserQuit();
-      else if (activeWin != this)
-        activeWin->HandleKeyPress(Fl::event_key());
-      else
-        this->HandleKeyPress(Fl::event_key());
-      handled = true;
-      break;
-
-    case FL_KEYUP:
-      if (Fl::event_key() == FL_Escape)
-        World::Instance()->SetSelectedEntity(NULL);
-      else if (activeWin != this)
-        activeWin->HandleKeyRelease(Fl::event_key());
-      else
-        this->HandleKeyRelease(Fl::event_key());
-      handled = true;
-      break;
-
-    case FL_MOUSEWHEEL:
-      this->HandleMouseWheel(Fl::event_dx(), Fl::event_dy());
-      handled = true;
-      break;
-  }
-
-  this->mouseEvent.prevPos = this->mouseEvent.pos;
-
-  if (Fl::event_key() == FL_Escape)
-  {
-    return 1;
-  }
-
-
-  if (!handled)
-    return Fl_Gl_Window::handle(event);
-  else
-    return 1;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Handle resizing the window
-void GLWindow::resize(int x, int y, int w, int h)
-{
-  Fl_Gl_Window::resize(x,y,w,h);
-  this->userCamera->Resize(w,h);
-
-  this->redraw();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the visual info
-XVisualInfo *GLWindow::GetVisualInfo() const
-{
-  return this->visual;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the display
-Display *GLWindow::GetDisplay() const
-{
-  return this->display;
-}
-
-
-////////////////////////////////////////////////////////////////////////////////
-/// Set the active camera
-void GLWindow::SetActiveCamera( OgreCamera *camera )
-{
-   this->activeCamera = camera;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Set the style of the view = "front, left, top, user"
-void GLWindow::SetViewStyle(std::string view)
-{
-  UserCamera *cam =  this->GetCamera();
-  Pose3d pose = cam->GetCameraWorldPose();
-
-  if (view == "Top")
-  {
-    pose.rot.SetFromEuler( Vector3(0, DTOR(90), 0) );
-  }
-  else if (view == "Left")
-  {
-    pose.rot.SetFromEuler( Vector3(0, 0, DTOR(90) ) );
-  }
-  else if (view == "Front")
-  {
-    pose.rot.SetFromEuler( Vector3(0, 0,0) );
-  }
-  else
-  {
-    OgreCamera *cam = CameraManager::Instance()->GetCamera( view );
-    ((UserCamera*)this->activeCamera)->SetCamera(cam);
-  }
-
-  cam->SetWorldPose( pose );
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Get point on a plane
-Vector3 GLWindow::GetWorldPointOnPlane(int x, int y, Vector3 planeNorm, double d)
-{
-  Vector3 origin, dir;
-  double dist;
-
-  // Cast two rays from the camera into the world
-  CameraManager::Instance()->GetActiveCamera()->GetCameraToViewportRay(x, y, origin, dir);
-
-  dist = origin.GetDistToPlane(dir, planeNorm, d);
-
-  // Compute two points on the plane. The first point is the current
-  // mouse position, the second is the previous mouse position
-  return origin + dir * dist; 
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Rotate and entity, or apply torque
-void GLWindow::EntityRotate(Entity *entity)
-{
-  Vector3 planeNorm, planeNorm2;
-  Vector3 p1, p2;
-  Vector3 a,b;
-  Vector3 ray(0,0,0);
-
-  Pose3d modelPose = entity->GetWorldPose();
-
-  // Figure out which axis to rotate around
-  if (this->mouseModifier == "rotx")
-    ray.x = 1.0;
-  else if (this->mouseModifier == "roty")
-    ray.y = 1.0;
-  else if (this->mouseModifier == "rotz")
-    ray.z = 1.0;
-
-  // Compute the normal to the plane on which to rotate
-  planeNorm = modelPose.rot.RotateVector(ray);
-  double d = -modelPose.pos.GetDotProd(planeNorm);
-
-  p1 = this->GetWorldPointOnPlane( this->mouseEvent.pos.x, 
-      this->mouseEvent.pos.y, planeNorm, d);
-
-  p2 = this->GetWorldPointOnPlane( this->mouseEvent.prevPos.x, 
-      this->mouseEvent.prevPos.y, planeNorm, d);
-
-  OgreCreator::DrawLine(entity->GetWorldPose().pos,p1, "guiline");
-
-  // Get point vectors relative to the entity's pose
-  a = p1 - entity->GetWorldPose().pos;
-  b = p2 - entity->GetWorldPose().pos;
-
-  a.Normalize();
-  b.Normalize();
-
-  // Get the angle between the two vectors. This is the amount to
-  // rotate the entity 
-  float angle = acos(a.GetDotProd(b));
-  if (isnan(angle))
-    angle = 0;
-
-  // Compute the normal to the plane which is defined by the
-  // direction of rotation
-  planeNorm2 = a.GetCrossProd(b);
-  planeNorm2.Normalize();
-
-  // Switch rotation direction if the two normals don't line up
-  if ( planeNorm.GetDotProd(planeNorm2) > 0)
-    angle *= -1;
-
-  if (entity->GetType() == Entity::MODEL) 
-  {
-    Quatern delta; 
-    delta.SetFromAxis( ray.x, ray.y, ray.z,angle);
-    
-    modelPose.rot = modelPose.rot * delta;
-    entity->SetWorldPose(modelPose);
-  }
-  else
-  {
-    ((Body*)entity)->SetTorque(planeNorm * angle * Gui::forceMultiplier);
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Translate an entity, or apply force
-void GLWindow::EntityTranslate(Entity *entity)
-{
-  Pose3d pose = entity->GetWorldPose();
-
-  Vector3 origin1, dir1, p1;
-  Vector3 origin2, dir2, p2;
-
-  // Cast two rays from the camera into the world
-  this->activeCamera->GetCameraToViewportRay(this->mouseEvent.pos.x, 
-      this->mouseEvent.pos.y, origin1, dir1);
-  this->activeCamera->GetCameraToViewportRay(this->mouseEvent.prevPos.x, 
-      this->mouseEvent.prevPos.y, origin2, dir2);
-
-  Vector3 moveVector(0,0,0);
-  Vector3 planeNorm(0,0,1);
-  if (this->mouseModifier == "transx")
-    moveVector.x = 1;
-  else if (this->mouseModifier == "transy")
-    moveVector.y = 1;
-  else if (this->mouseModifier == "transz")
-  {
-    moveVector.z = 1;
-    planeNorm.Set(1,0,0);
-  }
-
-  // Compute the distance from the camera to plane of translation
-  double d = -pose.pos.GetDotProd(planeNorm);
-  double dist1 = origin1.GetDistToPlane(dir1, planeNorm, d);
-  double dist2 = origin2.GetDistToPlane(dir2, planeNorm, d);
-
-  // Compute two points on the plane. The first point is the current
-  // mouse position, the second is the previous mouse position
-  p1 = origin1 + dir1 * dist1;
-  p2 = origin2 + dir2 * dist2;
-
-  OgreCreator::DrawLine(entity->GetWorldPose().pos,p2, "guiline");
-
-  moveVector *= p1 - p2;
-
-  if (entity->GetType() == Entity::MODEL)
-  {
-    pose.pos += moveVector;
-    entity->SetRelativePose(pose);
-  }
-  else if (entity->GetType() == Entity::BODY)
-  {
-    Body *body = (Body*)(entity);
-    moveVector *= Gui::forceMultiplier;
-    body->SetForce(moveVector);
-  }
-}
-
-void GLWindow::CreateEntity(std::string name)
-{
-  if (this->currMaker)
-    this->currMaker->Stop();
-
-  this->SetCursorState("create");
-
-  if (name.size() > 0)
-    World::Instance()->SetSelectedEntity(NULL);
-
-  if (name == "box")
-    this->currMaker = &this->boxMaker;
-  else if (name == "cylinder")
-    this->currMaker = &this->cylinderMaker;
-  else if (name == "sphere")
-    this->currMaker = &this->sphereMaker;
-  else if (name == "pointlight")
-    this->currMaker = &this->pointLightMaker;
-  else if (name == "spotlight")
-    this->currMaker = &this->spotLightMaker;
-  else if (name == "directionallight")
-    this->currMaker = &this->directionalLightMaker;
-  else
-  {
-    this->currMaker = NULL;
-    this->SetCursorState("default");
-  }
-
-  if (this->currMaker)
-    this->currMaker->Start();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Get the cursor state
-std::string GLWindow::GetCursorState() const
-{
-  return this->cursorState;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Set the cursor state
-void GLWindow::SetCursorState(const std::string &state)
-{
-  this->cursorState = state;
-
-  if (state == "default")
-    this->cursor(FL_CURSOR_DEFAULT);
-  else if (state == "manip")
-    this->cursor(FL_CURSOR_HAND);
-  else if (state == "create")
-    this->cursor(FL_CURSOR_CROSS);
-}
-
-void GLWindow::MoveModeCB(bool mode)
-{
-  if (mode)
-    this->SetCursorState("default");
-}
-
-void GLWindow::ManipModeCB(bool mode)
-{
-  if (mode)
-    this->SetCursorState("manip");
-}
-
Index: server/gui/EntityMaker.cc
===================================================================
--- server/gui/EntityMaker.cc	(revision 8976)
+++ server/gui/EntityMaker.cc	(working copy)
@@ -1,30 +0,0 @@
-#include "EntityMaker.hh"
-
-using namespace gazebo;
-
-////////////////////////////////////////////////////////////////////////////////
-/// Constructor
-EntityMaker::EntityMaker()
-{
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Destructor
-EntityMaker::~EntityMaker()
-{
-}
-
-////////////////////////////////////////////////////////////////////////////////
-void EntityMaker::MousePushCB(const MouseEvent &event)
-{
-}
-
-////////////////////////////////////////////////////////////////////////////////
-void EntityMaker::MouseReleaseCB(const MouseEvent &event)
-{
-}
-
-////////////////////////////////////////////////////////////////////////////////
-void EntityMaker::MouseDragCB(const MouseEvent &event)
-{
-}
Index: server/gui/Gui.hh
===================================================================
--- server/gui/Gui.hh	(revision 8976)
+++ server/gui/Gui.hh	(working copy)
@@ -1,112 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003  
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: FLTK Mainwindow
- * Author: Nate Koenig
- * Date: 13 Feb 2006
- * SVN: $Id$
- */
-
-#ifndef FLTKMAINWINDOW_HH
-#define FLTKMAINWINDOW_HH
-
-#include <X11/Xlib.h>
-#include <X11/Xutil.h>
-
-#include <FL/Fl.H>
-#include <FL/Fl_Double_Window.H>
-#include <FL/Fl_Slider.H>
-#include <string>
-#include <iostream>
-
-#include "Param.hh"
-#include "Vector2.hh"
-
-//#define BG_COLOR fl_rgb_color(235,225,208 )
-#define BG_COLOR FL_BACKGROUND_COLOR
-
-namespace gazebo
-{
-  class GLWindow;
-  class Sidebar;
-  class Toolbar;
-  class StatusBar;
-  class GLFrameManager;
-  class XMLConfigNode;
-
-  /// \brief FLTK Main Window
-  class Gui : public Fl_Double_Window
-  {
-    /// \brief Constructor
-    public: Gui (int x, int y, int w, int h, const std::string &t);
- 
-    /// \brief Destructor
-    public: virtual ~Gui();
-
-    /// \brief Load the gui
-    public: virtual void Load(XMLConfigNode *node);
-
-    /// \brief Save the gui params in xml format
-    public: virtual void Save(std::string &prefix, std::ostream &stream);
-
-    /// \brief Create the user camera's 
-    public: void CreateCameras();
-
-    /// \brief Initalize the gui
-    public: virtual void Init();
-
-    public: virtual void Update();
-
-    /// \brief Get the width of the gui's rendering window
-    public: unsigned int GetWidth() const;
-
-    /// \brief Get the height of the gui's rendering window
-    public: unsigned int GetHeight() const;
-
-    /// \brief Handle an event
-    public: int handle(int event);
-
-    /// \brief Get the average FPS
-    public: float GetAvgFPS() const;
-    public: double GetUpdateRate() {return this->updateRate;};
-
-    /// \brief Time slider cb
-    private: static void TimeSliderCB( Fl_Widget * w, void *data);
-
-    private: Toolbar *toolbar;
-    private: Sidebar *sidebar;
-    private: StatusBar *statusbar;
-    private: GLFrameManager *frameMgr;
-
-    private: bool hasFocus;
-
-    private: ParamT<Vector2<int> > *sizeP;
-    private: ParamT<Vector2<int> > *posP;
-    private: ParamT<double> *updateRateP;
-    private: double updateRate;
-    private: std::vector<Param*> parameters;
-
-    private: Fl_Slider *timeSlider;
-
-    public: static double forceMultiplier;
-  };
-}
-
-#endif
Index: server/gui/CylinderMaker.hh
===================================================================
--- server/gui/CylinderMaker.hh	(revision 8976)
+++ server/gui/CylinderMaker.hh	(working copy)
@@ -1,30 +0,0 @@
-#ifndef CYLINDERMAKER_HH
-#define CYLINDERMAKER_HH
-
-#include "Vector2.hh"
-#include "EntityMaker.hh"
-
-namespace gazebo
-{
-  class CylinderMaker : public EntityMaker
-  {
-    public: CylinderMaker();
-    public: virtual ~CylinderMaker();
-  
-    public: virtual void Start();
-    public: virtual void Stop();
-    public: virtual bool IsActive() const;
-
-    public: virtual void MousePushCB(const MouseEvent &event);
-    public: virtual void MouseReleaseCB(const MouseEvent &event);
-    public: virtual void MouseDragCB(const MouseEvent &event);
-  
-    private: virtual void CreateTheEntity();
-    private: int state;
-    private: bool leftMousePressed;
-    private: Vector2<int> mousePushPos;
-    private: std::string visualName;
-    private: int index;
-  };
-}
-#endif
Index: server/gui/ParamBrowser.cc
===================================================================
--- server/gui/ParamBrowser.cc	(revision 8976)
+++ server/gui/ParamBrowser.cc	(working copy)
@@ -1,111 +0,0 @@
-#include "Param.hh"
-#include "World.hh"
-#include "Entity.hh"
-#include "ParamBrowser.hh"
-
-using namespace gazebo;
-
-////////////////////////////////////////////////////////////////////////////////
-/// Contructor
-ParamBrowser::ParamBrowser(int x, int y, int w, int h, const char *l)
-  : Fl_Scroll(x,y,w,h,l)
-{
-  this->end();
-  this->resizable(NULL);
-  this->lines = 0;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Destructor
-ParamBrowser::~ParamBrowser()
-{
-}
-
-
-////////////////////////////////////////////////////////////////////////////////
-void ParamBrowser::Clear()
-{
-  this->clear();
-  this->lines = 0;
-  this->redraw();
-}
-
-void ParamBrowser::AddDivider(const std::string& key, const std::string value)
-{
-  int y = this->y() + this->lines*20;
-  MyOutput *out = new MyOutput(this->x(), y,this->w()*.5, 20);
-  out->box(FL_BORDER_BOX);
-  out->value(key.c_str());
-  out->textcolor(fl_rgb_color(255,255,255));
-  out->color(fl_rgb_color(100,100,100));
-
-  MyOutput *out2 = new MyOutput(out->x() + out->w(), y, this->w()-out->w(),20);
-  out2->box(FL_BORDER_BOX);
-  out2->textcolor(fl_rgb_color(255,255,255));
-
-  Entity *ent = World::Instance()->GetSelectedEntity();
-  if (ent && ent->GetName() == value)
-    out2->color(fl_rgb_color(3,20,179));
-  else
-    out2->color(fl_rgb_color(100,100,100));
-
-  out2->value(value.c_str());
-  out2->callback(ParamBrowser::DividerCB, this);
-
-  this->lines++;
-
-  this->add(out);
-  this->add(out2);
-  this->redraw();
-}
-
-void ParamBrowser::DividerCB(Fl_Widget *w, void *data)
-{
-  MyOutput *out = (MyOutput*)(w);
-  std::string childName = out->value();
-
-  out->color(fl_rgb_color(3,20,179), fl_rgb_color(255,255,255) );
-  out->redraw();
-
-  Entity *ent = World::Instance()->GetSelectedEntity();
-  Entity *child = NULL;
-
-  if (ent)
-    child = ent->GetChild(childName);
-
-  if (child)
-    World::Instance()->SetSelectedEntity(child);
-
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Add a value to the param browser
-void ParamBrowser::AddParam(Param *param)
-{
-  int y = this->y() + this->lines*20;
-  MyOutput *out = new MyOutput(this->x(), y,this->w()*.5, 20);
-  out->box(FL_BORDER_BOX);
-  out->value(param->GetKey().c_str());
-
-  MyInput *in = new MyInput(out->x() + out->w(), y, this->w()*.5,20);
-  in->box(FL_BORDER_BOX);
-  in->value(param->GetAsString().c_str());
-  in->callback( &ParamBrowser::SetParam, this );
-  in->when(FL_WHEN_ENTER_KEY | FL_WHEN_RELEASE );
-  in->user_data( param );
-
-  this->lines++;
-
-  this->add(out);
-  this->add(in);
-  this->redraw();
-}
-
-void ParamBrowser::SetParam(Fl_Widget *w, void *data)
-{
-  Fl_Input *in = (Fl_Input*)(w);
-  Param *param = (Param*)(w->user_data());
-
-  std::string value = in->value();
-  param->SetFromString(value, true);
-}
Index: server/gui/Events.cc
===================================================================
--- server/gui/Events.cc	(revision 8976)
+++ server/gui/Events.cc	(working copy)
@@ -1,7 +0,0 @@
-#include "Events.hh"
-
-using namespace gazebo;
-
-boost::signal<void (std::string)> Events::createEntitySignal;
-boost::signal<void (bool)> Events::moveModeSignal;
-boost::signal<void (bool)> Events::manipModeSignal;
Index: server/gui/SpotLightMaker.hh
===================================================================
--- server/gui/SpotLightMaker.hh	(revision 8976)
+++ server/gui/SpotLightMaker.hh	(working copy)
@@ -1,30 +0,0 @@
-#ifndef SPOTLIGHTMAKER_HH
-#define SPOTLIGHTMAKER_HH
-
-#include "Vector2.hh"
-#include "EntityMaker.hh"
-
-namespace gazebo
-{
-  class SpotLightMaker : public EntityMaker
-  {
-    public: SpotLightMaker();
-    public: virtual ~SpotLightMaker();
-  
-    public: virtual void Start();
-    public: virtual void Stop();
-    public: virtual bool IsActive() const;
-
-    public: virtual void MousePushCB(const MouseEvent &event);
-    public: virtual void MouseReleaseCB(const MouseEvent &event);
-    public: virtual void MouseDragCB(const MouseEvent &event);
-  
-    private: virtual void CreateTheEntity();
-    private: int state;
-    private: Vector2<int> mousePushPos;
-    private: std::string lightName;
-    private: int index;
-  };
-}
-
-#endif
Index: server/gui/icon.xpm
===================================================================
--- server/gui/icon.xpm	(revision 8976)
+++ server/gui/icon.xpm	(working copy)
@@ -1,122 +0,0 @@
-/* XPM */
-const static char * icon_xpm[] = {
-"16 16 103 2",
-"  	c None",
-". 	c #BFBFBF",
-"+ 	c #C3C2C2",
-"@ 	c #957E7E",
-"# 	c #804949",
-"$ 	c #8A3B3B",
-"% 	c #884545",
-"& 	c #E7E6E6",
-"* 	c #D1C0C0",
-"= 	c #C9B0B0",
-"- 	c #E8E2E2",
-"; 	c #FFFFFF",
-"> 	c #B99292",
-", 	c #911919",
-"' 	c #901D1D",
-") 	c #824646",
-"! 	c #CCCCCC",
-"~ 	c #D0BBBB",
-"{ 	c #933535",
-"] 	c #941515",
-"^ 	c #8E1E1E",
-"/ 	c #B58C8C",
-"( 	c #9F6060",
-"_ 	c #843A3A",
-": 	c #E9E2E2",
-"< 	c #932A2A",
-"[ 	c #921515",
-"} 	c #974A4A",
-"| 	c #911616",
-"1 	c #824747",
-"2 	c #EFEFEF",
-"3 	c #BF9898",
-"4 	c #973737",
-"5 	c #B37F7F",
-"6 	c #A36868",
-"7 	c #775151",
-"8 	c #FDFDFD",
-"9 	c #B68686",
-"0 	c #A45E5E",
-"a 	c #AB7575",
-"b 	c #8F4444",
-"c 	c #D7CACA",
-"d 	c #CBB3B3",
-"e 	c #931515",
-"f 	c #871F1F",
-"g 	c #AA8A8A",
-"h 	c #CEB8B8",
-"i 	c #911818",
-"j 	c #8C3B3B",
-"k 	c #8A2929",
-"l 	c #AF7E7E",
-"m 	c #9F5B5B",
-"n 	c #974343",
-"o 	c #FBFAFA",
-"p 	c #F0EDED",
-"q 	c #943535",
-"r 	c #892626",
-"s 	c #901C1C",
-"t 	c #D3C0C0",
-"u 	c #FAF9F9",
-"v 	c #B98F8F",
-"w 	c #9E5252",
-"x 	c #A15555",
-"y 	c #C5A3A3",
-"z 	c #F5F3F3",
-"A 	c #A56B6B",
-"B 	c #912222",
-"C 	c #B78D8D",
-"D 	c #FAFAFA",
-"E 	c #E4E0E0",
-"F 	c #C7AEAE",
-"G 	c #8D3A3A",
-"H 	c #884646",
-"I 	c #8B2323",
-"J 	c #9B4A4A",
-"K 	c #A05656",
-"L 	c #883131",
-"M 	c #CFBDBD",
-"N 	c #EBE7E7",
-"O 	c #913030",
-"P 	c #884444",
-"Q 	c #9E6262",
-"R 	c #8F2121",
-"S 	c #834747",
-"T 	c #974242",
-"U 	c #F8F7F7",
-"V 	c #B79D9D",
-"W 	c #881414",
-"X 	c #8B1414",
-"Y 	c #8E1414",
-"Z 	c #7E4444",
-"` 	c #853A3A",
-" .	c #911D1D",
-"..	c #DACBCB",
-"+.	c #F4F4F4",
-"@.	c #AFA7A7",
-"#.	c #943333",
-"$.	c #B68585",
-"%.	c #A87D7D",
-"&.	c #928686",
-"*.	c #882323",
-"=.	c #8A3232",
-"-.	c #873F3F",
-"          . + @ # $ %           ",
-"        & * = - ; > , ' )       ",
-"    ! ~ { ] ] ^ / ; ( ] ] _     ",
-"    : < ] ] ] ] [ } | ] ] ] 1   ",
-"  2 3 ] ] 4 5 5 5 5 5 5 5 6 '   ",
-"7 8 9 ] ] 0 ; ; ; ; ; ; ; a ] % ",
-"b c d e ] | f f f g ; ; h i ] j ",
-"k l ; m ] ] ] ] n o ; p q ] ] r ",
-"r s t u v w x y z ; ; A ] ] ] r ",
-"j ] B C D ; ; ; E ; F | ] ] ] G ",
-"H ] ] ] I J K L M N O ] ] ] ] P ",
-"  ' ] ] ] ] ] l ; Q ] ] ] ] R   ",
-"  S ] ] ] ] T U V W X X X Y Z   ",
-"    ` ] ]  ...; +.2 2 2 2 @.    ",
-"      S ' #.$.$.$.$.$.%.&.      ",
-"          % j r *.=.-.          "};
Index: server/gui/GLFrameManager.cc
===================================================================
--- server/gui/GLFrameManager.cc	(revision 8976)
+++ server/gui/GLFrameManager.cc	(working copy)
@@ -1,286 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: FLTK GL Frame manager
- * Author: Nate Koenig
- * Date: 18 Jun 2008
- * SVN: $Id$
- */
-
-#include "XMLConfig.hh"
-
-#include "GLFrame.hh"
-#include "GLWindow.hh"
-#include "GLFrameManager.hh"
-
-using namespace gazebo;
-
-////////////////////////////////////////////////////////////////////////////////
-// Constructor
-GLFrameManager::GLFrameManager(int x, int y, int w, int h, const std::string &name) : Fl_Tile(x,y,w,h, name.c_str())
-{
-  this->end();
-
-  this->resizable(this);
-
-  this->configNode = NULL;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Destructor
-GLFrameManager::~GLFrameManager()
-{
-  std::vector<GLFrame *>::iterator iter;
-  for (iter = this->frames.begin(); iter != this->frames.end(); iter++)
-  {
-    if (*iter) 
-      delete (*iter);
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Load from xml
-void GLFrameManager::Load( XMLConfigNode *node )
-{
-  GLFrame *frame = NULL;
-  int windowCount = 0;
-  XMLConfigNode *rowNode = NULL;
-  XMLConfigNode *camNode = NULL;
-
-  if (node)
-  {
-    rowNode = node->GetChild("row");
-
-    float frameHeight, frameWidth;
-    int width = this->w();
-    int height = this->h();
-    int x = this->x();
-    int y = this->y();
-
-    // Process each row
-    while (rowNode)
-    {
-      camNode = rowNode->GetChild("camera");
-
-      std::string heightStr = rowNode->GetString("height","",1);
-
-      frameHeight = atof( heightStr.substr(0, heightStr.find( "%", 0 ) ).c_str() );
-
-      frameHeight = frameHeight/100.0 * height;
-
-      // Process each camera
-      while (camNode)
-      {
-        std::string widthStr = camNode->GetString("width","",1);
-        frameWidth = atof( widthStr.substr(0, widthStr.find( "%", 0 ) ).c_str() );
-
-        frameWidth = frameWidth/100.0 * width;
-
-        windowCount = this->children();
-
-        // Create the frame
-        frame = new GLFrame( x, y, (int)frameWidth, (int)frameHeight, "" );
-        frame->Load(camNode);
-
-        this->frames.push_back( frame );
-        this->insert(*frame, windowCount);
-
-        x += (int)frameWidth;
-
-        camNode = camNode->GetNext();
-      }
-
-      y += (int)frameHeight;
-      x = this->x();
-
-      rowNode = rowNode->GetNext();
-    }
-  }
-
-  // Create a big default window if no frames have been defined
-  if (this->frames.size() == 0)
-  {
-    frame = new GLFrame( this->x(), this->y(), this->w(), this->h(), "" );
-    this->frames.push_back( frame );
-    this->insert(*frame, windowCount);
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Save the gui params in xml format
-void GLFrameManager::Save(std::string &prefix, std::ostream &stream)
-{
-  std::vector<GLFrame *>::iterator iter;
-  std::vector<int> rows;
-
-  stream << prefix << "<frames>\n";
-
-  for (iter = this->frames.begin(); iter != this->frames.end(); iter++)
-  {
-    int width = (*iter)->w();
-    int height = (*iter)->h();
-    int x = (*iter)->x();
-    int y = (*iter)->y();
-    Pose3d pose = (*iter)->GetCameraPose();
-
-    stream << prefix << "    <camera width=\"" << width 
-      << "\" height=\"" << height << "\" x=\"" << x << "\" y=\""
-      <<  y << "\">\n";
-    stream << prefix << "      <xyz>" << pose.pos << "</xyz>\n";
-    stream << prefix << "      <rpy>" << pose.rot << "</rpy>\n";
-    stream << prefix << "    </camera>\n";
-  }
-
-  stream << prefix << "</frames>\n";
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Create user cameras
-void GLFrameManager::CreateCameras()
-{
-  std::vector<GLFrame *>::iterator iter;
-  for (iter = this->frames.begin(); iter != this->frames.end(); iter++)
-  {
-    (*iter)->CreateCameras();
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Initalize the window manager
-void GLFrameManager::Init()
-{
-  // Create all the frames
-  if (this->configNode)
-  {
-    GLFrame *frame = this->frames[0];
-    XMLConfigNode *camNode = NULL;
-    camNode = this->configNode->GetChild("camera");
-
-    int i = 0;
-    while (camNode)
-    {
-      int width = camNode->GetInt("width",this->w(),1);
-      int height = camNode->GetInt("height",this->h(),1);
-      int x = camNode->GetInt("x",this->x(),1);
-      int y = camNode->GetInt("y",this->y(),1);
-      std::ostringstream stream;
-      stream << "GL Window " << i;
-
-      // Create the frame
-      if (i==0)
-        frame->resize(x,y,width,height);
-      else
-      {
-        frame = new GLFrame( x, y, width, height, stream.str() );
-
-        this->frames.push_back( frame );
-        this->insert(*frame, i);
-      }
-
-      frame->Load(camNode);
-
-      i++;
-      camNode = camNode->GetNext();
-      this->redraw();
-    }
-  }
-
-
-  std::vector<GLFrame *>::iterator iter;
-  for (iter = this->frames.begin(); iter != this->frames.end(); iter++)
-  {
-    (*iter)->Init();
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Update the window manager
-void GLFrameManager::Update()
-{
-  std::vector<GLFrame *>::iterator iter;
-
-  for (iter = this->frames.begin(); iter != this->frames.end(); iter++)
-  {
-    (*iter)->Update();
-  }
-}
-
-
-////////////////////////////////////////////////////////////////////////////////
-// Split a frame
-void GLFrameManager::Split(GLFrame *parent, const std::string &type)
-{
-  GLFrame *glFrame = NULL;
-  unsigned int origWidth = parent->w();
-  unsigned int origHeight = parent->h();
-  unsigned int newWidth = 0;
-  unsigned int newHeight = 0;
-  unsigned int originX = 0;
-  unsigned int originY = 0;
-  int windowCount = this->children();
-
-  if (type == "horz")
-  {
-    newWidth = origWidth / 2;
-    newHeight = origHeight;
-
-    originX = parent->x()+newWidth;
-    originY = parent->y();
-  }
-  else if (type == "vert")
-  {
-    newWidth = origWidth;
-    newHeight = origHeight / 2;
-
-    originX = parent->x();
-    originY = parent->y() + newHeight;
-  }
-
-  parent->resize(parent->x(), parent->y(), newWidth, newHeight);
-  if (type == "horz")
-    glFrame = new GLFrame(originX, originY, newWidth, newHeight, "GL Window 2");
-  else
-    glFrame = new GLFrame(originX, originY, newWidth, newHeight, "GL Window 2");
-
-  this->insert(*glFrame, windowCount);
-  glFrame->Init();
-  this->frames.push_back(glFrame);
-
-  this->redraw();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the avg FPS
-float GLFrameManager::GetFPS() const
-{
-  std::vector<GLFrame*>::const_iterator iter;
-  float sum = 0;
-
-  for (iter = this->frames.begin(); iter != this->frames.end(); iter++)
-  {
-    sum += (*iter)->GetWindow()->GetAvgFPS();
-  }
-
-  //printf("Sum[%f] Size[%d]\n", sum, this->frames.size());
-
-  return sum / this->frames.size();
-}
-
-
Index: server/gui/Sidebar.cc
===================================================================
--- server/gui/Sidebar.cc	(revision 8976)
+++ server/gui/Sidebar.cc	(working copy)
@@ -1,417 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: Sidebar
- * Author: Nate Koenig
- * Date: 13 Feb 2006
- * SVN: $Id$
- */
-
-#include <stdio.h>
-#include <FL/Fl_Value_Output.H>
-#include <FL/Fl_Output.H>
-#include <FL/Fl_Input.H>
-#include <FL/Fl_Float_Input.H>
-#include <FL/Fl_Button.H>
-#include <FL/Fl_Choice.H>
-#include <FL/Fl_Value_Slider.H>
-
-#include <boost/lexical_cast.hpp>
-#include <boost/bind.hpp>
-
-#include "Gui.hh"
-#include "World.hh"
-#include "Body.hh"
-#include "Geom.hh"
-#include "Entity.hh"
-#include "Light.hh"
-#include "Common.hh"
-#include "Model.hh"
-#include "Simulator.hh"
-#include "CameraManager.hh"
-#include "OgreVisual.hh"
-#include "OgreCamera.hh"
-#include "Sidebar.hh"
-#include "Global.hh"
-#include "ParamBrowser.hh"
-
-using namespace gazebo;
-
-////////////////////////////////////////////////////////////////////////////////
-// Constructor
-Sidebar::Sidebar(int x, int y, int w, int h, const char *l)
-    : Fl_Group(x,y,w,h,l)
-{
-  this->box(FL_NO_BOX);
-  this->color(BG_COLOR);
-
-  this->entityBrowser = new Fl_Hold_Browser(x+10, y+20, w-20, 
-      (this->h()-20)*0.25,"Models");
-  this->entityBrowser->align(FL_ALIGN_TOP);
-  this->entityBrowser->callback( &Sidebar::EntityBrowserCB, this );
-  this->entityBrowser->color(FL_WHITE);
-
-  x = this->entityBrowser->x() + this->entityBrowser->w()*.5 - 25;
-  y = this->entityBrowser->y() + this->entityBrowser->h() + 5;
-  Fl_Button *gotoButton = new Fl_Button(x,y,50,20, "Go To");
-  gotoButton->callback(&Sidebar::GotoCB, this);
-
-  this->paramColumnWidths[0] = 80;
-  this->paramColumnWidths[1] = 120;
-  this->paramColumnWidths[2] = 0;
-
-  y = gotoButton->y() + gotoButton->h() + 30;
-  x = this->entityBrowser->x();
-  this->paramBrowser = new ParamBrowser(x, y, w-20,
-      (this->h()-20)*0.5,"Parameters");
-  this->paramBrowser->align(FL_ALIGN_TOP);
-  //this->paramBrowser->column_char('~');
-  //this->paramBrowser->column_widths( this->paramColumnWidths );
-  this->paramBrowser->callback(&Sidebar::ParamBrowserCB, this);
-  this->paramBrowser->color(FL_WHITE);
-
-  y = this->paramBrowser->y() + this->paramBrowser->h() + 20;
-  this->paramInput = new Fl_Float_Input(x+10, y, w-20, 20, "Param:");
-  this->paramInput->align(FL_ALIGN_TOP);
-  this->paramInput->labelsize(12);
-  this->paramInput->when(FL_WHEN_ENTER_KEY | FL_WHEN_RELEASE | FL_WHEN_CHANGED);
-  this->paramInput->callback(&Sidebar::ParamInputCB, this);
-  this->paramInput->color(FL_WHITE);
-  this->paramInput->value("1.0");
-  this->paramInput->hide();
-
-  this->end();
-
-  this->resizable( this->entityBrowser );
-  this->resizable( this->paramBrowser );
-
-
-  World::Instance()->ConnectAddEntitySignal( 
-      boost::bind(&Sidebar::AddEntityToBrowser, this, _1) );
-
-  World::Instance()->ConnectEntitySelectedSignal( 
-      boost::bind(&Sidebar::SetSelectedEntity, this, _1) );
-
-  World::Instance()->ConnectDeleteEntitySignal( 
-      boost::bind(&Sidebar::DeleteEntityFromBrowser, this, _1) );
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Destructor
-Sidebar::~Sidebar()
-{
-  delete this->paramBrowser;
-  delete this->paramInput;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Update the toolbar data
-void Sidebar::Update()
-{
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Set the selected entity
-void Sidebar::SetSelectedEntity(Entity *entity)
-{
-  this->paramCount = 0;
-
-  Model *model = NULL;
-
-  if (entity && entity->GetType() == Entity::BODY)
-    model = (Model*)(entity->GetParent());
-  else if (entity && entity->GetType() == Entity::MODEL)
-  {
-    model = (Model*)(entity);
-  }
-
-  if (model)
-  {
-    this->paramBrowser->Clear();
-
-    this->Helper(model);
-    //std::cout << "Value[" << ((Fl_Valuator*)&this->paramBrowser->scrollbar)->value() << "]\n";
-
-    //((Fl_Valuator*)&this->paramBrowser->scrollbar)->value(20);
-    this->paramBrowser->redraw();
-    this->paramInput->hide();
-  }
-
-  if (entity && entity->GetType() == Entity::BODY)
-  {
-    this->paramInput->show();
-    this->paramInput->value(boost::lexical_cast<std::string>(Gui::forceMultiplier).c_str());
-    this->paramInput->label("Force Multiplier:");
-  }
-
-
-  if (!entity)
-  {
-    this->entityBrowser->deselect();
-    this->paramBrowser->Clear();
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Helper
-void Sidebar::Helper(const Entity *entity)
-{
-  if (!entity)
-    return;
-
-  const std::vector<Entity*> children = entity->GetChildren();
-  std::vector<Entity*>::const_iterator iter;
-
-  this->AddEntityToParamBrowser( entity, "    " );
-
-  for (iter = children.begin(); iter != children.end(); iter++)
-  {
-    std::string value = (*iter)->GetTypeString()+ ":" + (*iter)->GetName();
-    this->paramBrowser->AddDivider((*iter)->GetTypeString(), (*iter)->GetName() );
-    this->Helper(*iter);
-  }
-}
-
-
-
-////////////////////////////////////////////////////////////////////////////////
-// Attribute browser callback
-void Sidebar::ParamBrowserCB( Fl_Widget * w, void *data)
-{
-  Fl_Hold_Browser *browser = (Fl_Hold_Browser*)(w);
-  Sidebar *toolbar = (Sidebar*)(data);
-  std::string lineText, lbl;
-  int beginLbl = 0;
-  int endLbl = 0;
-  int beginValue = 0;
-  int selected = browser->value();
- 
-  if (selected <= 0)
-    return;
-
-  lineText = browser->text(selected);
-
-  if (lineText.find("-Body") != std::string::npos)
-  {
-    Entity *selected = World::Instance()->GetSelectedEntity();
-
-    beginLbl = lineText.rfind("@") + 2;
-
-    std::string bodyName = lineText.substr(beginLbl, lineText.size()-beginLbl);
-
-    std::string modelName = toolbar->entityBrowser->text( toolbar->entityBrowser->value() );
-    std::string scopedName = modelName + "::" + bodyName;
-
-    Entity *ent = World::Instance()->GetEntityByName(scopedName);
-
-    if (selected != ent)
-      World::Instance()->SetSelectedEntity(ent);
-  }
-  else if (lineText.find("-Geom") != std::string::npos)
-  {
-   beginLbl = lineText.rfind("@") + 2;
-
-    std::string geomName = lineText.substr(beginLbl, lineText.size()-beginLbl);
-
-    Entity *ent = World::Instance()->GetEntityByName(geomName);
-
-    if (ent)
-      World::Instance()->SetSelectedEntity(ent);
-
-    return;
-  }
-
-  endLbl = lineText.find("~");
-  while (lineText[beginLbl] == '@') beginLbl+=2; 
-  while (lineText[beginLbl] == ' ') beginLbl++;
-
-  beginValue = endLbl+1;
-  while (lineText[beginValue] == '@') beginValue+=2; 
-
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Attribute modification callback
-void Sidebar::ParamInputCB( Fl_Widget *w, void *data)
-{
-  Fl_Input *input = (Fl_Input*)(w);
-
-  std::string value = input->value();
-
-  if (value.size() > 0)
-  {
-    double dblValue = boost::lexical_cast<double>(value);
-    Gui::forceMultiplier = dblValue;
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Callback for entity browser
-void Sidebar::EntityBrowserCB( Fl_Widget *w, void *data )
-{
-  Fl_Hold_Browser *browser = (Fl_Hold_Browser*)(w);
-  std::string lineText;
-  int selected = browser->value();
-
-  if (selected <=0)
-    return;
-
-  lineText = browser->text(selected);
-
-  Entity *ent = World::Instance()->GetEntityByName(lineText);
-
-  if (ent)
-  {
-    World::Instance()->SetSelectedEntity(ent);
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Add entity to browser
-void Sidebar::AddEntityToParamBrowser(const Common *entity, std::string prefix)
-{
-  std::string value;
-  std::string colorStr = "";
-
-  // Process all the parameters in the entity
-  for (unsigned int i=0; i < entity->GetParamCount(); i++)
-  {
-    Param *param = entity->GetParam(i);
-    this->paramBrowser->AddParam(param);
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Update entity browser
-void Sidebar::UpdateEntityBrowser()
-{
-  std::vector<Model*>::const_iterator iter;
-  const std::vector<Model*> models = World::Instance()->GetModels();
-
-  this->entityBrowser->clear();
-  for (iter = models.begin(); iter != models.end(); iter++)
-  {
-    std::vector<Entity*>::const_iterator eiter;
-    for (eiter = (*iter)->GetChildren().begin(); 
-         eiter != (*iter)->GetChildren().end(); eiter++)
-    {
-      if ((*eiter)->GetType() == Entity::MODEL)
-        this->AddEntityToBrowser((Model*)*eiter);
-    }
-
-    this->AddEntityToBrowser((*iter));
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Add an entity to the browser
-void Sidebar::AddEntityToBrowser(const Entity *entity)
-{
-  this->entityBrowser->add( entity->GetCompleteScopedName().c_str() );
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Delete entity from browser
-void Sidebar::DeleteEntityFromBrowser(const std::string &name)
-{
-  this->UpdateEntityBrowser();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Joint choice callback
-void Sidebar::JointChoiceCB( Fl_Widget *w, void *data )
-{
-  Sidebar *self = (Sidebar*)(data);
-  Fl_Choice *choice = (Fl_Choice*)(w);
-
-  Entity *entity = World::Instance()->GetSelectedEntity();
-  if (entity->GetType() == Entity::MODEL)
-  {
-    Model *model = (Model*)(entity);
-
-    Joint *joint = model->GetJoint( choice->text() );
-    Angle lowStop = joint->GetLowStop(0);
-    Angle highStop = joint->GetHighStop(0);
-
-    self->jointForceSlider->bounds(-500,500); 
-    self->jointVelocitySlider->bounds(-100,100); 
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Joint choice callback
-void Sidebar::JointForceSliderCB( Fl_Widget *w, void *data )
-{
-  Sidebar *self = (Sidebar*)(data);
-  Fl_Value_Slider *slider = (Fl_Value_Slider*)(w);
-
-  // Only valid when a joint has been selected
-  if(self->jointChoice->value() <0)
-    return;
-
-  double value = slider->value();
-
-  Entity *entity = World::Instance()->GetSelectedEntity();
-  if (entity->GetType() == Entity::MODEL)
-  {
-    Model *model = (Model*)(entity);
-
-    Joint *joint = model->GetJoint( self->jointChoice->text() );
-    joint->SetMaxForce( 0, value );
-    joint->SetForce( 0, value );
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Joint velocity slider callback
-void Sidebar::JointVelocitySliderCB( Fl_Widget *w, void *data )
-{
-  Sidebar *self = (Sidebar*)(data);
-  Fl_Value_Slider *slider = (Fl_Value_Slider*)(w);
-
-  // Only valid when a joint has been selected
-  if(self->jointChoice->value() <0)
-    return;
-
-  double value = slider->value();
-
-  Entity *entity = World::Instance()->GetSelectedEntity();
-  if (entity->GetType() == Entity::MODEL)
-  {
-    Model *model = (Model*)(entity);
-    Joint *joint = model->GetJoint( self->jointChoice->text() );
-    joint->SetVelocity( 0, value );
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Goto callback
-void Sidebar::GotoCB( Fl_Widget *w, void *data )
-{
-
-  Entity *ent = World::Instance()->GetSelectedEntity();
-
-  if (ent)
-  {
-    OgreCamera *cam = CameraManager::Instance()->GetActiveCamera();
-    if (cam)
-      cam->MoveToEntity(ent);
-  }
-}
Index: server/gui/PointLightMaker.hh
===================================================================
--- server/gui/PointLightMaker.hh	(revision 8976)
+++ server/gui/PointLightMaker.hh	(working copy)
@@ -1,30 +0,0 @@
-#ifndef POINTLIGHTMAKER_HH
-#define POINTLIGHTMAKER_HH
-
-#include "Vector2.hh"
-#include "EntityMaker.hh"
-
-namespace gazebo
-{
-  class PointLightMaker : public EntityMaker
-  {
-    public: PointLightMaker();
-    public: virtual ~PointLightMaker();
-  
-    public: virtual void Start();
-    public: virtual void Stop();
-    public: virtual bool IsActive() const;
-
-    public: virtual void MousePushCB(const MouseEvent &event);
-    public: virtual void MouseReleaseCB(const MouseEvent &event);
-    public: virtual void MouseDragCB(const MouseEvent &event);
-  
-    private: virtual void CreateTheEntity();
-    private: int state;
-    private: Vector2<int> mousePushPos;
-    private: std::string lightName;
-    private: int index;
-  };
-}
-
-#endif
Index: server/gui/Toolbar.hh
===================================================================
--- server/gui/Toolbar.hh	(revision 8976)
+++ server/gui/Toolbar.hh	(working copy)
@@ -1,136 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003  
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: Toolbar
- * Author: Nate Koenig
- * Date: 13 Feb 2006
- * SVN: $Id: Toolbar.hh 8381 2009-11-10 17:10:09Z natepak $
- */
-
-#ifndef TOOLBAR_HH
-#define TOOLBAR_HH
-
-#include <FL/Fl_Group.H>
-#include <FL/Fl_Button.H>
-
-class Fl_Box;
-
-namespace gazebo
-{
-  class Common;
-  class Gui;
-
-  /// \brief Toolbar
-  class Toolbar : public Fl_Group
-  {
-    /// \brief Constructor
-    public: Toolbar (int x, int y, int w, int h, const char *l=0);
-  
-    /// \brief Destructor
-    public: virtual ~Toolbar();
-
-    /// \brief Update the toolbar data
-    public: void Update();
-
-    /// \brief Play pause button callback
-    public: static void PlayButtonCB( Fl_Widget *w, void *data );
-
-    /// \brief Pause pause button callback
-    public: static void PauseButtonCB( Fl_Widget *w, void *data );
-
-    /// \brief Set button callback
-    public: static void StepButtonCB( Fl_Widget * /*w*/, void * /*data*/ );
-
-    /// \brief Box button callback
-    public: static void BoxButtonCB( Fl_Widget *w, void * /*data*/ );
-
-    /// \brief Sphere button callback
-    public: static void SphereButtonCB( Fl_Widget *w, void * /*data*/ );
-
-    /// \brief Cylinder button callback
-    public: static void CylinderButtonCB( Fl_Widget *w, void * /*data*/ );
-
-    /// \brief Cursor button callback
-    public: static void CursorButtonCB( Fl_Widget *w, void * /*data*/ );
-
-    /// \brief Cursor button callback
-    public: static void HandCursorButtonCB( Fl_Widget *w, void * /*data*/ );
-    private: static void PointLightCB( Fl_Widget *w, void * /*data*/ );
-    private: static void SpotLightCB( Fl_Widget *w, void * /*data*/ );
-    private: static void DirectionalLightCB( Fl_Widget *w, void * /*data*/ );
-
-    private: void ManipModeCB(bool mode);
-    private: void MoveModeCB(bool mode);
-
-
-    private: class ToolbarButton : public Fl_Button
-          {
-            public: ToolbarButton(int x, int y, int w, int h, const char *l=0)
-                    : Fl_Button(x,y,w,h,l)
-            {
-              this->box(FL_FLAT_BOX);
-              this->down_box(FL_DOWN_BOX);
-              this->type(FL_RADIO_BUTTON);
-            }
-            public: virtual ~ToolbarButton() {}
-            public: int handle(int event)
-                    {
-                      int ret = Fl_Button::handle(event);
-                      switch(event)
-                      {
-                        case FL_ENTER:
-                          this->box(FL_UP_BOX);
-                          this->redraw();
-                          break;
-                        case FL_LEAVE:
-                          this->box(FL_FLAT_BOX);
-                          this->redraw();
-                          break;
-                      }
-
-                      return ret;
-                    }
-          };
-
-
-    private: Fl_Button *playButton;
-    private: Fl_Button *pauseButton;
-    private: Fl_Button *stepButton;
-    private: Fl_Button *moveButton;
-    private: ToolbarButton *boxButton;
-    private: ToolbarButton *sphereButton;
-    private: ToolbarButton *cylinderButton;
-    private: ToolbarButton *cursorButton;
-    private: ToolbarButton *handCursorButton;
-
-    private: Fl_RGB_Image *playImage[2];
-    private: Fl_RGB_Image *pauseImage[2];
-    private: Fl_RGB_Image *stepImage[2];
-    private: Fl_RGB_Image *boxImage[2];
-    private: Fl_RGB_Image *sphereImage[2];
-    private: Fl_RGB_Image *cylinderImage[2];
-    private: Fl_RGB_Image *cursorImage, *handCursorImage;
-
-    public: Gui *gui;
-  };
-  
-}
-
-#endif
Index: server/gui/GLFrame.cc
===================================================================
--- server/gui/GLFrame.cc	(revision 8976)
+++ server/gui/GLFrame.cc	(working copy)
@@ -1,327 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: FLTK GL Frame
- * Author: Nate Koenig
- * Date: 18 Jun 2008
- * SVN: $Id$
- */
-
-#include <boost/bind.hpp>
-
-#include "World.hh"
-#include "Model.hh"
-#include "XMLConfig.hh"
-#include "CameraManager.hh"
-#include "Global.hh"
-#include "Pose3d.hh"
-#include "GLWindow.hh"
-#include "GLFrameManager.hh"
-#include "UserCamera.hh"
-#include "Gui.hh"
-#include "GLFrame.hh"
-
-using namespace gazebo;
-
-////////////////////////////////////////////////////////////////////////////////
-// Constructor
-GLFrame::GLFrame(int x, int y, int w, int h, const std::string &name)
-  : Fl_Group(x,y,w,h, "")
-{
-
-  this->box(FL_ENGRAVED_BOX);
-  this->color(BG_COLOR);
-
-  this->headerBar = new Fl_Group(x,y,w,30);
-  this->headerBar->box(FL_NO_BOX);
-  this->headerBar->color(BG_COLOR);
-
-  this->viewChoice = new Fl_Choice(x+2, y+2, 150,26);
-  this->viewChoice->add("View");
-  this->viewChoice->mode(0, FL_MENU_DIVIDER);
-  this->viewChoice->add("Top", "", &gazebo::GLFrame::ViewCB, this);
-  this->viewChoice->add("Front", "", &gazebo::GLFrame::ViewCB, this);
-  this->viewChoice->add("Left", "",  &gazebo::GLFrame::ViewCB, this);
-  this->viewChoice->add("User", "", &gazebo::GLFrame::ViewCB, this);
-  this->viewChoice->value(0);
-  this->viewChoice->color(BG_COLOR);
-  this->viewChoice->clear_visible_focus();
-
-
-  this->splitChoice = new Fl_Choice(
-      this->viewChoice->x() + this->viewChoice->w()+2, 
-      this->viewChoice->y(), 150, 26);
-
-  this->splitChoice->add("Split Window");
-  this->splitChoice->mode(0, FL_MENU_DIVIDER);
-  this->splitChoice->add("Horizontal","", &gazebo::GLFrame::SplitCB, this);
-  this->splitChoice->add("Vertical","",  &gazebo::GLFrame::SplitCB, this);
-  this->splitChoice->value(0);
-  this->splitChoice->color(BG_COLOR);
-  this->splitChoice->clear_visible_focus();
-
-  this->trackChoice = new Fl_Choice(
-      this->splitChoice->x() + this->splitChoice->w()+2, 
-      this->splitChoice->y(), 150, 26);
-  this->trackChoice->add("Track Model");
-  this->trackChoice->mode(0, FL_MENU_DIVIDER);
-  this->trackChoice->add("None","", &gazebo::GLFrame::TrackCB, this);
-  this->trackChoice->value(0);
-  this->trackChoice->color(BG_COLOR);
-  this->trackChoice->clear_visible_focus();
-
-  std::vector<Model*> models = World::Instance()->GetModels();
-  std::vector<Model*>::iterator iter;
-  for (iter = models.begin(); iter != models.end(); iter++)
-    this->EntityAddedSlot(*iter);
-
-
-  this->headerBar->end();
-  this->headerBar->resizable(NULL);
-
-  this->glWindow = new GLWindow(x+4,y+30, w-8, h-60);
-
-  this->footerBar = new Fl_Group(x,y+h-30,w,30);
-
-  int x1 = this->footerBar->x() + 35;
-  int y1 = this->footerBar->y() + 5;
-
-  Fl_Group *posGroup = new Fl_Group(x1,y1,280,20);
-  this->outputXYZ = new Fl_Output(x1, y1, 140, 20,"XYZ");
-  this->outputXYZ->labelsize(10);
-  this->outputXYZ->textsize(10);
-  this->outputXYZ->value("0.0 0.0 0.0");
-  this->outputXYZ->box(FL_ENGRAVED_BOX);
-
-  x1 += this->outputXYZ->w() + 30;
-  this->outputRPY = new Fl_Output(x1, y1, 140, 20,"RPY");
-  this->outputRPY->labelsize(10);
-  this->outputRPY->textsize(10);
-  this->outputRPY->value("0.0 0.0 0.0");
-  this->outputRPY->box(FL_ENGRAVED_BOX);
-  posGroup->resizable(NULL);
-  posGroup->end();
-
-  x1 += this->outputRPY->w();
-
-  Fl_Box *fillerBox = new Fl_Box(x1,y1,this->w() - (x1-x + 175) ,20);
-  x1 += fillerBox->w();
-
-  Fl_Group *statsGroup = new Fl_Group(x1, y1,100,20);
-  this->fps = new Fl_Value_Output(x1,y1,30,20,"FPS");
-  this->fps->labelsize(10);
-  this->fps->textsize(10);
-  this->fps->precision(0);
-  this->fps->color(FL_WHITE);
-  this->fps->box(FL_ENGRAVED_BOX);
-
-  x1 += this->fps->w() + 60;
-  this->triangleCount = new Fl_Value_Output(x1,y1,50,20,"Triangles");
-  this->triangleCount->labelsize(10);
-  this->triangleCount->textsize(10);
-  this->triangleCount->precision(0);
-  this->triangleCount->color(FL_WHITE);
-  this->triangleCount->box(FL_ENGRAVED_BOX);
-
-  statsGroup->resizable(NULL);
-  statsGroup->end();
-
-  this->footerBar->end();
-  this->footerBar->resizable(NULL);
-  this->footerBar->resizable(fillerBox);
-
-  this->end();
-
-  this->resizable(NULL);
-  this->resizable(this->glWindow);
-
-  // Set default starting pose of the camera
-  this->startPose.pos.Set(-2, 0, 2);
-  this->startPose.rot.SetFromEuler( Vector3(0, DTOR(30), 0) );
-
-  this->saveFrames = false;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Destructor
-GLFrame::~GLFrame()
-{
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Load the frame
-void GLFrame::Load( XMLConfigNode *node )
-{
-
-  this->saveFrames = false;
-
-  if (node)
-  {
-    this->startPose.pos = node->GetVector3("xyz", Vector3(0,0,0));
-    this->startPose.rot = node->GetRotation("rpy", Quatern());
-    this->saveFrames = node->GetBool("saveFrames",false,0);
-    this->savePathname = node->GetString("saveFramePath","",0);
-  }
-
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Create user cameras
-void GLFrame::CreateCameras()
-{
-  this->glWindow->CreateCameras();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Initialize the frame
-void GLFrame::Init()
-{
-  this->glWindow->Init();
-  this->glWindow->GetCamera()->SetWorldPose(this->startPose);
-  this->glWindow->GetCamera()->EnableSaveFrame(this->saveFrames);
-  this->glWindow->GetCamera()->SetSaveFramePathname(this->savePathname);
-
-  CameraManager::Instance()->ConnectAddCameraSignal( boost::bind(&GLFrame::CameraAddedSlot, this, _1) );
-
-  World::Instance()->ConnectAddEntitySignal( boost::bind(&GLFrame::EntityAddedSlot, this, _1) );
-
-  // Add all the current cameras
-  for (unsigned int i=0; i < CameraManager::Instance()->GetNumCameras(); i++)
-  {
-    this->CameraAddedSlot( CameraManager::Instance()->GetCamera(i) );
-  }
-
-  this->show();
-  this->redraw();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Update the frame
-void GLFrame::Update()
-{  
-  char buff[256];
-  this->glWindow->Update();
-
-  Pose3d pose = this->glWindow->GetCamera()->GetCameraWorldPose();
-
-  sprintf(buff, "%6.2f %6.2f %6.2f", pose.pos.x, pose.pos.y, pose.pos.z);
-  this->outputXYZ->value(buff);
-
-  sprintf( buff,"%6.2f %6.2f %6.2f", RTOD(pose.rot.GetRoll()),
-     RTOD(pose.rot.GetPitch()), RTOD(pose.rot.GetYaw()) );
-  this->outputRPY->value(buff);
-
-  this->fps->value(this->glWindow->GetAvgFPS());
-  this->triangleCount->value(this->glWindow->GetTriangleCount());
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Boost slot, called when a new camera is added.
-void GLFrame::CameraAddedSlot(OgreCamera *newCamera)
-{
-  if (newCamera->GetCameraName().substr(0, 4) != "User")
-  {
-    this->viewChoice->add(newCamera->GetCameraName().c_str(), "", &gazebo::GLFrame::ViewCB, this);
-    this->viewChoice->redraw();
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Boost slot, called when a new entity is added.
-void GLFrame::EntityAddedSlot(Entity *newEntity)
-{
-  this->trackChoice->add(newEntity->GetName().c_str(), "", &gazebo::GLFrame::TrackCB, this);
-  this->trackChoice->redraw();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Split the current window
-void GLFrame::SplitCB(Fl_Widget *widget, void *data)
-{
-  GLFrame *frame = reinterpret_cast<GLFrame *>(data);
-  Fl_Choice *choice = dynamic_cast<Fl_Choice *>(widget);
-
-  GLFrameManager *manager = dynamic_cast<GLFrameManager*>(frame->parent());
-
-  switch (choice->value())
-  {
-    case 1:
-      manager->Split(frame, "horz");
-      break;
-    case 2:
-      manager->Split(frame, "vert");
-      break;
-  }
-
-  choice->value(0);
-
-  frame->glWindow->take_focus();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Switch view callback
-void GLFrame::ViewCB(Fl_Widget *widget, void *data)
-{
-  GLFrame *frame = reinterpret_cast<GLFrame *>(data);
-  Fl_Choice *choice = dynamic_cast<Fl_Choice *>(widget);
-
-  frame->glWindow->SetViewStyle(choice->text());
-  frame->glWindow->take_focus();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the pose of the camera attached to this frame
-Pose3d GLFrame::GetCameraPose() const
-{
-  return this->glWindow->GetCamera()->GetCameraWorldPose();  
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Set the pose of the camera attached to this frame
-void GLFrame::SetCameraPose( const Pose3d &pose )
-{
-  //this->glWindow->GetCamera()->SetWorldPose( pose );  
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get a pointer to the render window
-GLWindow *GLFrame::GetWindow() const
-{
-  return this->glWindow;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Switch view callback
-void GLFrame::TrackCB(Fl_Widget *widget, void *data)
-{
-  GLFrame *frame = reinterpret_cast<GLFrame *>(data);
-  Fl_Choice *choice = dynamic_cast<Fl_Choice *>(widget);
-
-  if (std::string(choice->text()) == "None" || 
-      std::string(choice->text()) == "Track Model")
-    frame->glWindow->GetCamera()->TrackModel( NULL );
-  else
-  {
-    Model *model = dynamic_cast<Model*>(World::Instance()->GetEntityByName(choice->text() ));
-    frame->glWindow->GetCamera()->TrackModel( model );
-  }
-
-  frame->glWindow->take_focus();
-}
Index: server/gui/HingeJointMaker.cc
===================================================================
--- server/gui/HingeJointMaker.cc	(revision 8976)
+++ server/gui/HingeJointMaker.cc	(working copy)
@@ -1,147 +0,0 @@
-#include <iostream>
-#include <FL/Fl.H>
-
-#include "PhysicsEngine.hh"
-#include "Joint.hh"
-#include "XMLConfig.hh"
-#include "Body.hh"
-#include "Simulator.hh"
-#include "OgreAdaptor.hh"
-#include "Entity.hh"
-#include "Pose3d.hh"
-#include "GLWindow.hh"
-#include "OgreVisual.hh"
-#include "OgreCreator.hh"
-#include "CameraManager.hh"
-#include "OgreCamera.hh"
-#include "World.hh"
-#include "HingeJointMaker.hh"
-
-using namespace gazebo;
-
-HingeJointMaker::HingeJointMaker()
-{
-  this->state = 0;
-  this->jointName = "";
-  this->leftMousePressed = false;
-}
-
-HingeJointMaker::~HingeJointMaker()
-{
-}
-
-void HingeJointMaker::Start()
-{
-  this->jointName = "user_hingejoint";
-  this->first = NULL;
-  this->second = NULL;
-  this->state = 1;
-}
-
-void HingeJointMaker::Stop()
-{
-  this->state = 0;
-}
-
-bool HingeJointMaker::IsActive() const
-{
-  return this->state > 0;
-}
-
-void HingeJointMaker::MousePushCB(Vector2<int> mousePos)
-{
-  if (this->state == 0)
-    return;
-
-  this->leftMousePressed = false;
-
-  this->mousePushPos = mousePos;
-
-  std::string mod;
-  OgreCamera *cam = CameraManager::Instance()->GetActiveCamera();
-  this->first = OgreAdaptor::Instance()->GetEntityAt(cam, mousePos, mod);
-
-  switch (Fl::event_button())
-  {
-    case FL_LEFT_MOUSE:
-      this->leftMousePressed = true;
-      break;
-  }
-}
-
-void HingeJointMaker::MouseReleaseCB(Vector2<int> mousePos)
-{
-  if (this->state == 0)
-    return;
-
-  this->state++;
-
-  std::string mod;
-  OgreCamera *cam = CameraManager::Instance()->GetActiveCamera();
-  this->second = OgreAdaptor::Instance()->GetEntityAt(cam, mousePos, mod);
-  this->CreateTheHingeJoint();
-}
-
-void HingeJointMaker::MouseDragCB(Vector2<int> mousePos)
-{
-  if (this->state == 0)
-    return;
-
-  Vector3 norm;
-  Vector3 p1, p2;
-
-  p1 = this->first->GetWorldPose().pos;
-  p2 = OgreAdaptor::Instance()->GetFirstContact(CameraManager::Instance()->GetActiveCamera(), mousePos);
-
-  OgreCreator::DrawLine(p1,p2,"HingeMaker");
-
-}
-
-void HingeJointMaker::CreateTheHingeJoint()
-{
-  boost::recursive_mutex::scoped_lock lock( *Simulator::Instance()->GetMRMutex());
-
-
-  Body *body1 = Simulator::Instance()->GetParentBody(this->first);
-  Body *body2 = Simulator::Instance()->GetParentBody(this->second);
-
-  Joint *joint;
-  Joint::Type jtype = Joint::HINGE;
-
-  joint = World::Instance()->GetPhysicsEngine()->CreateJoint(jtype);
-
-  std::ostringstream newJointStr;
-
-  newJointStr << "<?xml version='1.0'?> <gazebo:world xmlns:xi='http://www.w3.org/2001/XInclude' xmlns:gazebo='http://playerstage.sourceforge.net/gazebo/xmlschema/#gz' xmlns:model='http://playerstage.sourceforge.net/gazebo/xmlschema/#model' xmlns:sensor='http://playerstage.sourceforge.net/gazebo/xmlschema/#sensor' xmlns:body='http://playerstage.sourceforge.net/gazebo/xmlschema/#body' xmlns:geom='http://playerstage.sourceforge.net/gazebo/xmlschema/#geom' xmlns:joint='http://playerstage.sourceforge.net/gazebo/xmlschema/#joint' xmlns:interface='http://playerstage.sourceforge.net/gazebo/xmlschema/#interface' xmlns:rendering='http://playerstage.sourceforge.net/gazebo/xmlschema/#rendering' xmlns:renderable='http://playerstage.sourceforge.net/gazebo/xmlschema/#renderable' xmlns:controller='http://playerstage.sourceforge.net/gazebo/xmlschema/#controller' xmlns:physics='http://playerstage.sourceforge.net/gazebo/xmlschema/#physics' >";
-
-
-  newJointStr << "<joint:hinge name=\"" << this->jointName << "\">\
-    <body1>" << body1->GetCompleteScopedName() << "</body1>\
-    <body2>" << body2->GetCompleteScopedName() <<  "</body2>\
-    <anchor>" <<body1->GetCompleteScopedName()  << "</anchor>\
-    <anchorOffset>0 0 0</anchorOffset>\
-    <axis>0 0 1</axis>\
-    <erp>0.8</erp>\
-    <cfm>10e-5</cfm>\
-    </joint:hinge>";
-
-  newJointStr << "</gazebo:world>";
-
-
-  XMLConfig *xmlConfig = new XMLConfig();
-
-  // Load the XML tree from the given string
-  try
-  {
-    xmlConfig->LoadString( newJointStr.str() );
-  }
-  catch (gazebo::GazeboError e)
-  {
-    gzerr(0) << "The world could not load the XML data [" << e << "]\n";
-  }
-
-  XMLConfigNode *root = xmlConfig->GetRootNode();
-  joint->Load( root->GetChild() );
-
-  OgreCreator::SetVisible("guiline", false);
-}
Index: server/gui/DirectionalLightMaker.hh
===================================================================
--- server/gui/DirectionalLightMaker.hh	(revision 8976)
+++ server/gui/DirectionalLightMaker.hh	(working copy)
@@ -1,30 +0,0 @@
-#ifndef DIRECTIONALLIGHTMAKER_HH
-#define DIRECTIONALLIGHTMAKER_HH
-
-#include "Vector2.hh"
-#include "EntityMaker.hh"
-
-namespace gazebo
-{
-  class DirectionalLightMaker : public EntityMaker
-  {
-    public: DirectionalLightMaker();
-    public: virtual ~DirectionalLightMaker();
-  
-    public: virtual void Start();
-    public: virtual void Stop();
-    public: virtual bool IsActive() const;
-
-    public: virtual void MousePushCB(const MouseEvent &event);
-    public: virtual void MouseReleaseCB(const MouseEvent &event);
-    public: virtual void MouseDragCB(const MouseEvent &event);
-  
-    private: virtual void CreateTheEntity();
-    private: int state;
-    private: Vector2<int> mousePushPos;
-    private: std::string lightName;
-    private: int index;
-  };
-}
-
-#endif
Index: server/gui/SphereMaker.hh
===================================================================
--- server/gui/SphereMaker.hh	(revision 8976)
+++ server/gui/SphereMaker.hh	(working copy)
@@ -1,32 +0,0 @@
-#ifndef SPHEREMAKER_HH
-#define SPHEREMAKER_HH
-
-#include "Vector2.hh"
-#include "EntityMaker.hh"
-
-namespace gazebo
-{
-  class SphereMaker : public EntityMaker
-  {
-    public: SphereMaker();
-    public: virtual ~SphereMaker();
-  
-    public: virtual void Start();
-    public: virtual void Stop();
-    public: virtual bool IsActive() const;
-
-    public: virtual void MousePushCB(const MouseEvent &event);
-    public: virtual void MouseReleaseCB(const MouseEvent &event);
-    public: virtual void MouseDragCB(const MouseEvent &event);
-  
-    protected: virtual void CreateTheEntity();
-
-    private: int state;
-    private: bool leftMousePressed;
-    private: Vector2<int> mousePushPos;
-    private: std::string visualName;
-    private: int index;
-  
-  };
-}
-#endif
Index: server/gui/BoxMaker.hh
===================================================================
--- server/gui/BoxMaker.hh	(revision 8976)
+++ server/gui/BoxMaker.hh	(working copy)
@@ -1,31 +0,0 @@
-#ifndef BOXMAKER_HH
-#define BOXMAKER_HH
-
-#include "Vector2.hh"
-#include "EntityMaker.hh"
-
-namespace gazebo
-{
-  class BoxMaker : public EntityMaker
-  {
-    public: BoxMaker();
-    public: virtual ~BoxMaker();
-  
-    public: virtual void Start();
-    public: virtual void Stop();
-    public: virtual bool IsActive() const;
-
-    public: virtual void MousePushCB(const MouseEvent &event);
-    public: virtual void MouseReleaseCB(const MouseEvent &event);
-    public: virtual void MouseDragCB(const MouseEvent &event);
-  
-    private: virtual void CreateTheEntity();
-    private: int state;
-    private: bool leftMousePressed;
-    private: Vector2<int> mousePushPos;
-    private: std::string visualName;
-    private: int index;
-  };
-}
-
-#endif
Index: server/gui/StatusBar.hh
===================================================================
--- server/gui/StatusBar.hh	(revision 8976)
+++ server/gui/StatusBar.hh	(working copy)
@@ -1,75 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003  
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: StatusBar
- * Author: Nate Koenig
- * Date: 13 Feb 2006
- * SVN: $Id$
- */
-#ifndef STATUSBAR_HH
-#define STATUSBAR_HH
-
-#include <FL/Fl_Group.H>
-
-#include "Time.hh"
-
-class Fl_Value_Output;
-class Fl_Output;
-class Fl_Button;
-
-namespace gazebo
-{
-
-  /// \brief Toolbar
-  class StatusBar : public Fl_Group
-  {
-    /// \brief Constructor
-    public: StatusBar (int x, int y, int w, int h, const char *l=0);
-   
-    /// \brief Destructor
-    public: virtual ~StatusBar();
-    
-    /// \brief Update the toolbar data
-    public: void Update();
-  
-    /// \brief Play Pause button callback
-    public: static void PlayPauseButtonCB( Fl_Widget *w, void *data );
-
-    /// \brief Set button callback
-    public: static void StepButtonCB( Fl_Widget *w, void *data );
-
-    private: Fl_Value_Output *iterations;
-    private: Fl_Value_Output *percentOutput;
-    private: Fl_Value_Output *realTime;
-    private: Fl_Value_Output *pauseTime;
-    private: Fl_Value_Output *simTime;
-
-    public: Gui *gui;
-
-    private: Time lastUpdateTime;
-
-    // calculated percent speedup in last percentWindowDuration seconds real time.
-    private: Time percent, percentLastRealTime, percentLastSimTime;
-    private: static gazebo::Time statusUpdatePeriod;
-  };
-  
-}
-
-#endif
Index: server/gui/MainMenu.hh
===================================================================
--- server/gui/MainMenu.hh	(revision 8976)
+++ server/gui/MainMenu.hh	(working copy)
@@ -1,67 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003  
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: FLTK main menu
- * Author: Nate Koenig
- * Date: 13 Feb 2006
- * SVN: $Id$
- */
-
-#ifndef MAINMENU_HH
-#define MAINMENU_HH
-
-#include <FL/Fl_Menu_Bar.H>
-
-namespace gazebo
-{
-  class MainMenu : public Fl_Menu_Bar
-  {
-    public: MainMenu(int x, int y, int w, int h, char *name=0);
-
-    public: static void OpenCB(Fl_Widget * /*w*/, void * /*data*/);
-
-    public: static void SaveFramesCB(Fl_Widget *w, void *data);
-
-    public: static void QuitCB(Fl_Widget *w, void *data);
-
-    public: static void SaveWorldCB(Fl_Widget *w, void *data);
-
-    public: static void ShowBoundingBoxesCB(Fl_Widget *w, void *data);
-
-    public: static void ShowJointsCB(Fl_Widget * /*w*/, void * /*data*/);
-
-    public: static void ShowPhysicsCB(Fl_Widget * /*w*/, void * /*data*/);
-
-    public: static void ResetCB(Fl_Widget * /*w*/, void * /*data*/);
-
-    public: static void WireframeCB(Fl_Widget * /*w*/, void * /*data*/);
-
-    public: static void SplitCB(Fl_Widget * /*w*/, void * /*data*/);
-
-    public: static void ShowContactsCB(Fl_Widget * /*w*/, void * /*data*/);
-
-    public: static void ShowLightsCB(Fl_Widget * /*w*/, void * /*data*/);
-
-    public: static void ShowCamerasCB(Fl_Widget * /*w*/, void * /*data*/);
-
-  };
-}
-
-#endif
Index: server/gui/Gui.cc
===================================================================
--- server/gui/Gui.cc	(revision 8976)
+++ server/gui/Gui.cc	(working copy)
@@ -1,274 +0,0 @@
-/*
- *  Gazebo - Outdoor Multi-Robot Simulator
- *  Copyright (C) 2003
- *     Nate Koenig & Andrew Howard
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-/* Desc: FLTK Mainwindow
- * Author: Nate Koenig
- * Date: 13 Feb 2006
- * SVN: $Id$
- */
-
-#include <string>
-
-#include <X11/xpm.h>
-#include <FL/Fl_Menu_Item.H>
-#include <FL/Fl_Menu_Bar.H>
-#include <FL/Fl_Choice.H>
-#include <FL/Fl_Gl_Window.H>
-#include <FL/fl_draw.H>
-#include <FL/x.H>
-
-#include "World.hh"
-#include "Global.hh"
-#include "XMLConfig.hh"
-#include "GLFrameManager.hh"
-#include "OgreAdaptor.hh"
-#include "OgreCreator.hh"
-#include "Simulator.hh"
-#include "GLWindow.hh"
-#include "MainMenu.hh"
-#include "Toolbar.hh"
-#include "Sidebar.hh"
-#include "StatusBar.hh"
-#include "Gui.hh"
-
-#include "icon.xpm"
-
-using namespace gazebo;
-
-double Gui::forceMultiplier = 1;
-
-////////////////////////////////////////////////////////////////////////////////
-/// Constructor
-Gui::Gui (int x, int y, int width, int height, const std::string &t)
-  : Fl_Double_Window(x, y, width, height, t.c_str())
-{
-  this->color(BG_COLOR);
-
-  Param::Begin(&this->parameters);
-  this->sizeP = new ParamT<Vector2<int> >("size", Vector2<int>(800, 600), 0);
-  this->posP = new ParamT<Vector2<int> >("pos",Vector2<int>(0,0),0);
-  this->updateRateP = new ParamT<double>("updateRate",15,0);
-  Param::End();
-
-  width = std::max(800, this->w());
-  height = std::max(480, this->h());
-
-  this->w(width);
-  this->h(height);
-
-  // The order of creation matters! Menubar first, followed by FrameManager,
-  // then statusbar
-  {
-    int toolbarWidth = 250;
-
-    // Create a main menu
-    new MainMenu(0, 0, w(), 20, (char *)"MainMenu");
-
-    this->toolbar = new Toolbar(0, 20, this->w(), 30);
-    this->toolbar->gui = this;
-    this->sidebar = new Sidebar(0, this->toolbar->y() + this->toolbar->h(), toolbarWidth, this->h() - 115);
-
-    // Create the frame mamanger
-    this->frameMgr = new GLFrameManager(toolbarWidth, this->toolbar->y() + this->toolbar->h(), this->w()-toolbarWidth, this->h()-115, "");
-
-    this->timeSlider = new Fl_Slider(35,this->h()-50,this->w()-35,20,"Time:" );
-    this->timeSlider->type(FL_HOR_NICE_SLIDER);
-    this->timeSlider->align(FL_ALIGN_LEFT);
-    this->timeSlider->labelsize(10);
-    this->timeSlider->callback(&Gui::TimeSliderCB, this);
-    this->timeSlider->value(1.0);
-
-    // Create the status bar
-    this->statusbar = new StatusBar(0, this->h()-30, 
-                         width, 30);
-
-    this->statusbar->gui = this;
-  }
-
-  this->resizable(this->statusbar);
-  this->resizable(this->frameMgr);
-
-  this->end();
-  this->show();
-
-  Fl::check();
-  Fl::wait(0.3);
-
-  this->hasFocus = true;
-
-  Fl::check();
-  Fl::wait(0.3);
-
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Destructor
-Gui::~Gui()
-{
-  this->hide();
-
-  delete this->sizeP;
-  delete this->posP;
-  delete this->updateRateP;
-
-  //delete this->statusbar;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Load the gui
-void Gui::Load( XMLConfigNode *node )
-{
-  this->sizeP->Load(node);
-  this->posP->Load(node);
-  this->updateRateP->Load(node);
-  this->updateRate = this->updateRateP->GetValue();
-
-  if (node)
-    this->frameMgr->Load( node->GetChild("frames") );
-  else
-    this->frameMgr->Load(NULL);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Save the gui params in xml format
-void Gui::Save(std::string &prefix, std::ostream &stream)
-{
-  std::string p = prefix + "  ";
-
-  this->sizeP->SetValue(Vector2<int>(this->GetWidth(), this->GetHeight()));
-  this->posP->SetValue(Vector2<int>(this->x(), this->y()));
-  this->updateRateP->SetValue(this->updateRate);
-
-  stream << prefix <<  "<rendering:gui>\n";
-  stream << prefix <<  "  " << *(this->sizeP) << "\n";
-  stream << prefix <<  "  " << *(this->posP) << "\n";
-  stream << prefix <<  "  " << *(this->updateRateP) << "\n";
-  this->frameMgr->Save(p, stream);
-  stream << prefix << "</rendering:gui>\n";
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Create the user camera's 
-void Gui::CreateCameras()
-{
-  this->frameMgr->CreateCameras();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Initalize the gui
-void Gui::Init()
-{
-  this->frameMgr->Init();
-
-  Pixmap p, mask;
-  XpmCreatePixmapFromData(fl_display, RootWindow(fl_display, fl_screen),
-      const_cast<char**>(icon_xpm), &p, &mask, NULL);
-
-  XWMHints *hints;
-  hints = XGetWMHints(fl_display, fl_xid(this));
-  hints->icon_pixmap = p;
-  hints->icon_mask = mask;
-  hints->flags = IconPixmapHint | IconMaskHint;
-  XSetWMHints(fl_display, fl_xid(this), hints);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-void Gui::Update()
-{
-  this->sidebar->Update();
-  this->toolbar->Update();
-  this->statusbar->Update();
-  this->frameMgr->Update();
-  
-  if (!Simulator::Instance()->IsPaused())
-    this->timeSlider->value(1.0);
-
-  Fl::check();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the width of the gui's rendering window
-unsigned int Gui::GetWidth() const
-{
-  return this->w();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the height of the gui's rendering window
-unsigned int Gui::GetHeight() const
-{
-  return this->h();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Handle an event
-int Gui::handle(int event)
-{
-  switch(event)
-  {
-    case FL_KEYUP:
-      {
-        if (Fl::event_key() == ' ')
-        {
-          Simulator::Instance()->SetPaused(!Simulator::Instance()->IsPaused() );
-          return 1;
-        }
-      }
-
-    case FL_SHORTCUT:
-      if ( (Fl::event_state() & FL_CTRL) && Fl::event_key() == 113)
-        Simulator::Instance()->SetUserQuit();
-      break;
-    case FL_FOCUS:
-      this->hasFocus = true;
-      break;
-    case FL_UNFOCUS:
-      this->hasFocus = false;
-      break;
-    case FL_HIDE:
-      if (this->hasFocus)
-        Simulator::Instance()->SetUserQuit();
-      break;
-  }
-
-  if (Fl::event_key() == FL_Escape)
-  {
-    World::Instance()->SetSelectedEntity(NULL);
-    return 1;
-  }
-
-  return Fl_Window::handle(event);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the average FPS
-float Gui::GetAvgFPS() const
-{
-  return this->frameMgr->GetFPS();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Time slider CB
-void Gui::TimeSliderCB( Fl_Widget * w, void *data)
-{
-  //Gui *self = (Gui*)(data);
-  Fl_Slider *slider = (Fl_Slider*)(w);
-  World::Instance()->GotoTime( slider->value() );
-}
Index: server/gui/CylinderMaker.cc
===================================================================
--- server/gui/CylinderMaker.cc	(revision 8976)
+++ server/gui/CylinderMaker.cc	(working copy)
@@ -1,160 +0,0 @@
-#include <iostream>
-#include <FL/Fl.H>
-
-#include "MouseEvent.hh"
-#include "Simulator.hh"
-#include "GLWindow.hh"
-#include "OgreVisual.hh"
-#include "OgreCreator.hh"
-#include "World.hh"
-#include "CylinderMaker.hh"
-
-using namespace gazebo;
-
-CylinderMaker::CylinderMaker()
-  : EntityMaker()
-{
-  this->state = 0;
-  this->visualName = "";
-  this->index = 0;
-}
-
-CylinderMaker::~CylinderMaker()
-{
-}
-
-void CylinderMaker::Start()
-{
-  std::ostringstream stream;
-  std::string name = "user_cylinder";
-
-  do
-  {
-    stream.str("");
-    stream << name << index;
-    this->index++;
-  } while (OgreCreator::Instance()->GetVisual(stream.str()));
-
-  this->visualName = stream.str();
-  this->state = 1;
-}
-
-void CylinderMaker::Stop()
-{
-  OgreVisual *vis = OgreCreator::Instance()->GetVisual(this->visualName);
-  if (vis)
-    OgreCreator::Instance()->DeleteVisual(this->visualName);
-
-  this->state = 0;
-}
-
-bool CylinderMaker::IsActive() const
-{
-  return this->state > 0;
-}
-
-void CylinderMaker::MousePushCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  this->mousePushPos = event.pressPos;
-}
-
-void CylinderMaker::MouseReleaseCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  this->state++;
-
-  if (this->state == 3)
-  {
-    this->CreateTheEntity();
-    this->Start();
-  }
-}
-
-void CylinderMaker::MouseDragCB(const MouseEvent &event)
-{
-  if (this->state == 0)
-    return;
-
-  Vector3 norm;
-  Vector3 p1, p2;
-
-  if (this->state == 1)
-    norm.Set(0,0,1);
-  else if (this->state == 2)
-    norm.Set(1,0,0);
-
-  p1 = GLWindow::GetWorldPointOnPlane(this->mousePushPos.x, this->mousePushPos.y, norm, 0);
-  p2 = GLWindow::GetWorldPointOnPlane(event.pos.x, event.pos.y ,norm, 0);
-
-  OgreVisual *vis = NULL;
-  if (OgreCreator::Instance()->GetVisual(this->visualName))
-    vis = OgreCreator::Instance()->GetVisual(this->visualName);
-  else
-  {
-    vis = OgreCreator::Instance()->CreateVisual(this->visualName);
-    vis->AttachMesh("unit_cylinder");
-    vis->SetPosition(p1);
-  }
-
-  Vector3 p = vis->GetPosition();
-  Vector3 scale;
-
-  if (this->state == 1)
-  {
-    double dist = p1.Distance(p2);
-    scale.x = dist*2;
-    scale.y = dist*2;
-    scale.z = 0.01;
-  }
-  else
-  {
-    scale = vis->GetScale();
-   // scale.z = p2.z - p1.z;
-    scale.z = (this->mousePushPos.y - event.pos.y)*0.01;
-    p.z = scale.z/2.0;
-  }
-
-  vis->SetPosition(p);
-  vis->SetScale(scale);
-}
-
-void CylinderMaker::CreateTheEntity()
-{
-  boost::recursive_mutex::scoped_lock lock( *Simulator::Instance()->GetMRMutex());
-
-  std::ostringstream newModelStr;
-
-  OgreVisual *vis = OgreCreator::Instance()->GetVisual(this->visualName);
-  if (!vis)
-    return;
-
-  newModelStr << "<?xml version='1.0'?> <gazebo:world xmlns:xi='http://www.w3.org/2001/XInclude' xmlns:gazebo='http://playerstage.sourceforge.net/gazebo/xmlschema/#gz' xmlns:model='http://playerstage.sourceforge.net/gazebo/xmlschema/#model' xmlns:sensor='http://playerstage.sourceforge.net/gazebo/xmlschema/#sensor' xmlns:body='http://playerstage.sourceforge.net/gazebo/xmlschema/#body' xmlns:geom='http://playerstage.sourceforge.net/gazebo/xmlschema/#geom' xmlns:joint='http://playerstage.sourceforge.net/gazebo/xmlschema/#joint' xmlns:interface='http://playerstage.sourceforge.net/gazebo/xmlschema/#interface' xmlns:rendering='http://playerstage.sourceforge.net/gazebo/xmlschema/#rendering' xmlns:renderable='http://playerstage.sourceforge.net/gazebo/xmlschema/#renderable' xmlns:controller='http://playerstage.sourceforge.net/gazebo/xmlschema/#controller' xmlns:physics='http://playerstage.sourceforge.net/gazebo/xmlschema/#physics' >";
-
-
-  newModelStr << "<model:physical name=\"" << this->visualName << "\">\
-    <xyz>" << vis->GetPosition() << "</xyz>\
-    <body:cylinder name=\"body\">\
-    <geom:cylinder name=\"geom\">\
-    <size>" << vis->GetScale().x*.5 << " " << vis->GetScale().z << "</size>\
-    <mass>0.5</mass>\
-    <visual>\
-    <mesh>unit_cylinder</mesh>\
-    <size>" << vis->GetScale() << "</size>\
-    <material>Gazebo/Grey</material>\
-    <shader>pixel</shader>\
-    </visual>\
-    </geom:cylinder>\
-    </body:cylinder>\
-    </model:physical>";
-
-  newModelStr <<  "</gazebo:world>";
-
-  OgreCreator::Instance()->DeleteVisual(this->visualName);
-  World::Instance()->InsertEntity(newModelStr.str());
-}
-
Index: server/World.hh
===================================================================
--- server/World.hh	(revision 8976)
+++ server/World.hh	(working copy)
@@ -38,11 +38,6 @@
 
 #include "Global.hh"
 
-#ifdef USE_THREADPOOL
-#include "boost/threadpool.hpp"
-#include "boost/thread/mutex.hpp"
-#endif
-
 #include "SingletonT.hh"
 #include "Vector3.hh"
 #include "Pose3d.hh"
@@ -51,7 +46,6 @@
 
 namespace libgazebo
 {
-  class SimulationIface;
   class Server;
 }
 
@@ -63,6 +57,7 @@
 
 // Forward declarations
   class Model;
+  class Body;
   class Geom;
   class PhysicsEngine;
   class XMLConfigNode;
@@ -72,6 +67,7 @@
   class Timer;
   class Time;
   class GraphicsIfaceHandler;
+  class SimulationIfaceHandler;
    
 /// \brief The World
 /*
@@ -110,6 +106,15 @@
   /// Finilize the world
   public: void Fini();
 
+  /// \brief Remove all entities from the world
+  public: void Clear();
+
+  /// \brief Get the number of parameters
+  public: unsigned int GetParamCount() const;
+
+  /// \brief Get a param
+  public: Param *GetParam(unsigned int index) const;
+
   /// Retun the libgazebo server
   /// \return Pointer the the libgazebo server
   public: libgazebo::Server *GetGzServer() const;
@@ -157,17 +162,12 @@
   /// \brief Delete all the entities that have been queued
   public: void ProcessEntitiesToDelete();
 
-  /// \brief Delete an entity by name
-  /// \param name The name of the entity to delete
-  public: void DeleteEntity(const std::string &name);
+  /// \brief Get the number of models
+  public: unsigned int GetModelCount() const;
 
-  /// \brief Get a pointer to a entity based on a name
-  public: Entity *GetEntityByName(const std::string &name) const;
-  private: Entity *GetEntityByNameHelper(const std::string &name, Entity *parent) const;
+  /// \brief Get a model based on an index
+  public: Model *GetModel(unsigned int index);
 
-  /// \brief Get an iterator over the models
-  public: const std::vector<Model*> &GetModels() const;
-
   /// \brief Reset the simulation to the initial settings
   public: void Reset();
 
@@ -177,65 +177,18 @@
   /// \brief Register a body 
   public: void RegisterBody(Body *body);
 
-  // User control of how the world is viewed 
-  // If this section grows it may become a model-view structure ...
-  /// \brief Return true if the bounding boxes should be shown
-  public: bool GetShowBoundingBoxes();
-
-  /// \brief Set if the bounding boxes should be shown
-  public: void SetShowBoundingBoxes(bool show);
-
-  /// \brief Get wheter to show the joints
-  public: bool GetShowJoints();
-
-  /// \brief Set whether to show the joints
-  public: void SetShowJoints(bool show);
-
-  /// \brief Get whether to show the joints
-  public: bool GetShowJoints() const;
-
-  /// \brief Set whether to show the contacts
-  public: void SetShowContacts(bool show);
-
-  /// \brief Get whether to show the contacts
-  public: bool GetShowContacts() const;
-
-  /// \brief Set whether to show the light source visuals
-  public: void SetShowLights(bool show);
-
-  /// \brief Get whether to show the light source visuals
-  public: bool GetShowLights() const;
-
-  /// \brief Set whether to show the camera visuals
-  public: void SetShowCameras(bool show);
-
-  /// \brief Get whether to show the camera visuals
-  public: bool GetShowCameras() const;
-
-  /// \brief Set to view as wireframe
-  public: void SetWireframe( bool wire );
-
-  /// \brief Get whether to view as wireframe
-  public: bool GetWireframe();
-
-  /// \brief Set to view as wireframe
-  public: void SetShowPhysics( bool show );
-
-  /// \brief Get whether to view as wireframe
-  public: bool GetShowPhysics();
-
   /// \brief Goto a position in time
   public: void GotoTime(double pos);
 
-  /// \brief Set the selected entity
-  public: void SetSelectedEntity( Entity *ent );
-
   /// \brief Get the selected entity
   public: Entity *GetSelectedEntity() const;
 
   /// \brief Print entity tree
   public: void PrintEntityTree();
 
+  /// \brief Get the server id
+  public: int GetServerId() const;
+
   /// \brief Save the state of the world
   private: void SaveState();
 
@@ -245,23 +198,7 @@
   /// \brief Pause callback
   private: void PauseSlot(bool p);
 
-  /// Set to true to show bounding boxes
-  private: bool showBoundingBoxes;
 
-  /// Set to true to show joints
-  private: bool showJoints;
-
-  private: bool showContacts;
-
-  private: bool showLights;
-
-  private: bool showCameras;
-
-  private: bool showPhysics;
-
-  private: bool wireframe;
-
-
   /// \brief Load a model
   /// \param node Pointer to the XMLConfig node
   /// \param parent The parent model
@@ -272,112 +209,13 @@
   /// \brief Update the simulation iface
   public: void UpdateSimulationIface();
 
-  /// \brief Connect a boost::slot the the add entity signal
-  public: template<typename T>
-          boost::signals::connection ConnectAddEntitySignal( T subscriber )
-          { return addEntitySignal.connect(subscriber); }
-  public: template<typename T>
-          void DisconnectAddEntitySignal( T subscriber)
-          { addEntitySignal.disconnect(subscriber); }
+  /// \brief Delete an entity by name
+  /// \param name The name of the entity to delete
+  private: void DeleteEntityCB(const std::string &name);
 
-  /// \brief Connect a boost::slot the delete entity signal
-  public: template<typename T>
-          boost::signals::connection ConnectDeleteEntitySignal( T subscriber )
-          { return deleteEntitySignal.connect(subscriber); }
-  public: template<typename T>
-          void DisconnectDeleteEntitySignal( T subscriber)
-          { deleteEntitySignal.disconnect(subscriber); }
+  /// \brief Set the selected entity
+  private: void SetSelectedEntityCB( const std::string &name );
 
-  /// \brief Connect a boost::slot the the show light source signal
-  public: template<typename T>
-          boost::signals::connection ConnectShowLightsSignal( T subscriber )
-          { return showLightsSignal.connect(subscriber); }
-
-  public: template<typename T>
-          void DisconnectShowLightsSignal( T subscriber )
-          { showLightsSignal.disconnect(subscriber); }
-
-  /// \brief Connect a boost::slot the the show camera source signal
-  public: template<typename T>
-          boost::signals::connection ConnectShowCamerasSignal( T subscriber )
-          { return showCamerasSignal.connect(subscriber); }
-  public: template<typename T>
-          void DisconnectShowCamerasSignal( T subscriber )
-          { showCamerasSignal.disconnect(subscriber); }
-
-  /// \brief Connect a boost::slot the the show contacts signal
-  public: template<typename T>
-          boost::signals::connection ConnectShowContactsSignal( T subscriber )
-          { return showContactsSignal.connect(subscriber); }
-  public: template<typename T>
-          void DisconnectShowContactsSignal( T subscriber )
-          { showContactsSignal.disconnect(subscriber); }
-
-
-  /// \brief Connect a boost::slot the the show wireframe signal
-  public: template<typename T>
-          boost::signals::connection ConnectShowWireframeSignal( T subscriber )
-          { return wireframeSignal.connect(subscriber); }
-  public: template<typename T>
-          void DisconnectShowWireframeSignal( T subscriber )
-          { wireframeSignal.disconnect(subscriber); }
-
-
-  /// \brief Connect a boost::slot the the show physics signal
-  public: template<typename T>
-          boost::signals::connection ConnectShowPhysicsSignal( T subscriber )
-          { return showPhysicsSignal.connect(subscriber); }
-  public: template<typename T>
-          void DisconnectShowPhysicsSignal( T subscriber )
-          { showPhysicsSignal.disconnect(subscriber); }
-
-
-  /// \brief Connect a boost::slot the the show joints signal
-  public: template<typename T>
-          boost::signals::connection ConnectShowJointsSignal( T subscriber )
-          { return showJointsSignal.connect(subscriber); }
-  public: template<typename T>
-          void DisconnectShowJointsSignal( T subscriber )
-          { showJointsSignal.disconnect(subscriber); }
-
-  /// \brief Connect a boost::slot the the show bounding boxes signal
-  public: template<typename T>
-          boost::signals::connection ConnectShowBoundingBoxesSignal( T subscriber )
-          { return showBoundingBoxesSignal.connect(subscriber); }
-  public: template<typename T>
-          void DisconnectShowBoundingBoxesSignal( T subscriber )
-          { showBoundingBoxesSignal.disconnect(subscriber); }
-
-  /// \brief Connect a boost::slot the the world update start signal
-  public: template<typename T>
-          boost::signals::connection ConnectWorldUpdateStartSignal(T subscriber)
-          { return worldUpdateStartSignal.connect(subscriber); }
-  /// \brief Disconnect a boost::slot the the world update start signal
-  public: template<typename T>
-          void DisconnectWorldUpdateStartSignal( T subscriber )
-          { worldUpdateStartSignal.disconnect(subscriber); }
-
-  /// \brief Connect a boost::slot the the world update end signal
-  public: template<typename T>
-          boost::signals::connection ConnectWorldUpdateEndSignal(T subscriber)
-          { return worldUpdateEndSignal.connect(subscriber); }
-  /// \brief Disconnect a boost::slot the the world update end signal
-  public: template<typename T>
-          void DisconnectWorldUpdateEndSignal( T subscriber )
-          { worldUpdateEndSignal.disconnect(subscriber); }
-
-  /// \brief Connect a boost::slot the the entity selected signal
-  public: template<typename T>
-          boost::signals::connection ConnectEntitySelectedSignal(T subscriber)
-          { return entitySelectedSignal.connect(subscriber); }
-  /// \brief Disconnect a boost::slot the the entity selected signal
-  public: template<typename T>
-          void DisconnectEntitySelectedSignal( T subscriber )
-          { entitySelectedSignal.disconnect(subscriber); }
-
-  /// \brief Get the names of interfaces defined in the tree of a model
-  private: void GetInterfaceNames(Entity* m, std::vector<std::string>& list);
-
   /// Pointer the physics engine
   private: PhysicsEngine *physicsEngine;
 
@@ -392,16 +230,11 @@
   /// Simulator control interface
   private: libgazebo::Server *server;
 
-  /// Simulation interface
-  private: libgazebo::SimulationIface *simIface;
-
   private: Factory *factory;
 
   private: GraphicsIfaceHandler *graphics;
+  private: SimulationIfaceHandler *simIfaceHandler;
 
-  /// Length of time to run before receiving a "go" command
-  private: Time simPauseTime;
-
   private: OpenAL *openAL;
 
   /// List of all the parameters
@@ -409,10 +242,6 @@
 
   private: ParamT<int>* threadsP;
 
-#ifdef USE_THREADPOOL
-  public: boost::threadpool::pool* threadPool;
-#endif
-
   private: friend class DestroyerT<World>;
   private: friend class SingletonT<World>;
 
@@ -421,20 +250,20 @@
 
   public: double contactMarkerSize;
 
-  private: boost::signal<void (Entity*)> addEntitySignal;
-  private: boost::signal<void (std::string)> deleteEntitySignal;
-  private: boost::signal<void (bool)> showLightsSignal;
-  private: boost::signal<void (bool)> showCamerasSignal;
-  private: boost::signal<void (bool)> showContactsSignal;
-  private: boost::signal<void (bool)> wireframeSignal;
-  private: boost::signal<void (bool)> showPhysicsSignal;
-  private: boost::signal<void (bool)> showJointsSignal;
-  private: boost::signal<void (bool)> showBoundingBoxesSignal;
-  private: boost::signal<void (Entity*)> entitySelectedSignal;
+  //  private: boost::signal<void (Entity*)> addEntitySignal;
+  //  private: boost::signal<void (std::string)> deleteEntitySignal;
+  //  private: boost::signal<void (bool)> showLightsSignal;
+  //  private: boost::signal<void (bool)> showCamerasSignal;
+  //  private: boost::signal<void (bool)> showContactsSignal;
+  //  private: boost::signal<void (bool)> wireframeSignal;
+  //  private: boost::signal<void (bool)> showPhysicsSignal;
+  //  private: boost::signal<void (bool)> showJointsSignal;
+  //  private: boost::signal<void (bool)> showBoundingBoxesSignal;
+  //  private: boost::signal<void (Entity*)> entitySelectedSignal;
+  // 
+  //  private: boost::signal<void ()> worldUpdateStartSignal;
+  //  private: boost::signal<void ()> worldUpdateEndSignal;
 
-  private: boost::signal<void ()> worldUpdateStartSignal;
-  private: boost::signal<void ()> worldUpdateEndSignal;
-
   private: std::deque<WorldState> worldStates;
   private: std::deque<WorldState>::iterator worldStatesInsertIter;
   private: std::deque<WorldState>::iterator worldStatesEndIter;
Index: server/Common.hh
===================================================================
--- server/Common.hh	(revision 8976)
+++ server/Common.hh	(working copy)
@@ -31,21 +31,24 @@
 #include <vector>
 #include <string>
 
+#include "Global.hh"
 #include "Param.hh"
 
 namespace gazebo
 {
+  class Model;
+
   class Common
   {
     /// \brief Constructor
-    public: Common();
+    public: Common(Common *parent);
 
     /// \brief Destructor
     public: virtual ~Common();
 
     /// \brief Set the name of the entity
     /// \param name Body name
-    public: void SetName(const std::string &name);
+    public: virtual void SetName(const std::string &name);
   
     /// \brief Return the name of the entity
     /// \return Name of the entity
@@ -74,7 +77,90 @@
     /// \brief Get whether the object should be "saved", when the user
     ///        selects to save the world to xml
     public: bool GetSaveable() const;
-   
+
+    /// \brief Return the ID of the parent
+    /// \return Integer ID
+    public: int GetParentId() const;
+  
+    /// \brief Set the parent
+    /// \param parent Parent entity
+    public: void SetParent(Common *parent);
+  
+    /// \brief Get the parent
+    /// \return Pointer to the parent entity
+    public: Common *GetParent() const;
+
+    /// \brief Add a child to this entity
+    /// \param child Child entity
+    public: void AddChild(Common *child);
+
+    /// \brief Remove a child from this entity
+    /// \param child Child to remove
+    public: virtual void RemoveChild(Common *child);
+ 
+    /// \brief Get the number of children
+    public: unsigned int GetChildCount() const;
+
+    /// \brief Get an element by name
+    public: static Common *GetByName(const std::string &name);
+
+    /// \brief Get by name helper
+    private: Common *GetByNameHelper(const std::string &name, Common *parent);
+
+    /// \brief Get a child by index
+    public: Common *GetChild(unsigned int i) const;
+
+    /// \brief Get a child by name
+    public: Common *GetChild(const std::string &name );
+
+    /// \brief Add a type specifier
+    public: void AddType( EntityType type );
+
+    /// \brief Get the type
+    public: bool HasType(const EntityType &t) const;
+
+    /// \brief Get the number of types
+    public: unsigned int GetTypeCount() const;
+
+    /// \brief Get a type by index
+    public: EntityType GetType(unsigned int index) const;
+
+    /// \brief Get the leaf type (last type set)
+    public: EntityType GetLeafType() const;
+
+    /// \brief Get the parent model, if one exists
+    /// \return Pointer to a model, or NULL if no parent model exists
+    public: Model *GetParentModel() const;
+
+    /// \brief Return the name of this entity with the model scope
+    ///        model1::...::modelN::entityName
+    public: std::string GetScopedName() const;
+
+    /// \brief Return the name of this entity with the model+body+geom scope
+    ///        model1::...::modelN::bodyN::entityName
+    public: std::string GetCompleteScopedName() const;
+
+    public: void Print(std::string prefix);
+
+    /// \brief True == show parameters in the gui
+    public: bool GetShowInGui() const;
+
+    /// \brief True == show parameters in the gui
+    public: void SetShowInGui(bool v);
+
+    /// \brief Set whether this entity has been selected by the user through 
+    //         the gui
+    public: virtual bool SetSelected( bool s );
+  
+    /// \brief True if the entity is selected by the user
+    public: bool IsSelected() const;
+
+    /// \brief Returns true if the entities are the same. Checks only the name
+    public: bool operator==(const Common &ent) const;
+
+    /// \brief Parent of this entity
+    protected: Common *parent;
+
     /// \brief This entities ID
     private: unsigned int id;
   
@@ -89,6 +175,17 @@
 
     /// \brief Set to true if the object should be saved.
     protected: bool saveable;
+ 
+    /// \brief Children of this entity
+    protected: std::vector< Common* > children;
+ 
+    private: std::vector< EntityType > type;
+
+    private: static Common *root;
+
+    private: bool selected;
+
+    private: bool showInGui;
   };
 }
 
Index: server/Logger.cc
===================================================================
--- server/Logger.cc	(revision 8976)
+++ server/Logger.cc	(working copy)
@@ -77,7 +77,7 @@
   this->logFile.open(filename.c_str(), std::fstream::out);
   this->startRealTime = Simulator::Instance()->GetRealTime();
   this->startSimTime = Simulator::Instance()->GetSimTime();
-  this->entity = World::Instance()->GetEntityByName(entityName);
+  this->entity = dynamic_cast<Entity*>(Common::GetByName(entityName));
 
   if (!this->logFile.is_open())
   {
Index: server/controllers/camera/generic/Generic_Camera.cc
===================================================================
--- server/controllers/camera/generic/Generic_Camera.cc	(revision 8976)
+++ server/controllers/camera/generic/Generic_Camera.cc	(working copy)
@@ -122,13 +122,13 @@
   // Data timestamp
   data->head.time = Simulator::Instance()->GetSimTime().Double();
 
-  data->width = this->myParent->GetImageWidth();
-  data->height = this->myParent->GetImageHeight();
-  data->image_size = data->width * data->height * this->myParent->GetImageDepth();
+  data->width = this->myParent->GetCamera()->GetImageWidth();
+  data->height = this->myParent->GetCamera()->GetImageHeight();
+  data->image_size = data->width * data->height * this->myParent->GetCamera()->GetImageDepth();
 
   // GetFOV() returns radians
-  data->hfov = *(this->myParent->GetHFOV());
-  data->vfov = *(this->myParent->GetVFOV());
+  data->hfov = *(this->myParent->GetCamera()->GetHFOV());
+  data->vfov = *(this->myParent->GetCamera()->GetVFOV());
 
   // Set the pose of the camera
   cameraPose = this->myParent->GetWorldPose();
@@ -143,13 +143,13 @@
   assert (data->image_size <= sizeof(data->image));
 
   // Copy the pixel data to the interface
-  src = this->myParent->GetImageData(0);
+  src = this->myParent->GetCamera()->GetImageData(0);
   dst = data->image;
 
   boost::recursive_mutex::scoped_lock mr_lock(*Simulator::Instance()->GetMRMutex());
   memcpy(dst, src, data->image_size);
 
-  this->myParent->EnableSaveFrame( data->saveFrames );
+  this->myParent->GetCamera()->EnableSaveFrame( data->saveFrames );
 
   this->cameraIface->Unlock();
 
Index: server/controllers/camera/CMakeLists.txt
===================================================================
--- server/controllers/camera/CMakeLists.txt	(revision 8976)
+++ server/controllers/camera/CMakeLists.txt	(working copy)
@@ -1,2 +1 @@
 ADD_SUBDIRECTORY(generic)
-ADD_SUBDIRECTORY(stereo)
Index: server/controllers/Controller.cc
===================================================================
--- server/controllers/Controller.cc	(revision 8976)
+++ server/controllers/Controller.cc	(working copy)
@@ -100,7 +100,7 @@
     std::string ifaceName = childNode->GetString("name","",1);
 
     // Constructor the heirarchical name for the iface
-    Entity *p = parent;
+    Common *p = parent;
     while (p != NULL)
     {
       Model *m = dynamic_cast<Model*>(p);
Index: server/controllers/gripper/pioneer2/Pioneer2_Gripper.cc
===================================================================
--- server/controllers/gripper/pioneer2/Pioneer2_Gripper.cc	(revision 8976)
+++ server/controllers/gripper/pioneer2/Pioneer2_Gripper.cc	(working copy)
@@ -191,7 +191,7 @@
   if (!this->paddles[RIGHT])
     gzthrow("Couldn't get the right paddle geom");
 
-  this->holdJoint = World::Instance()->GetPhysicsEngine()->CreateJoint(Joint::SLIDER);
+  this->holdJoint = World::Instance()->GetPhysicsEngine()->CreateJoint("slider");
   this->holdJoint->SetName(this->GetName() + "_Hold_Joint");
 
   this->paddles[LEFT]->ConnectContactCallback(
Index: server/GraphicsIfaceHandler.cc
===================================================================
--- server/GraphicsIfaceHandler.cc	(revision 8976)
+++ server/GraphicsIfaceHandler.cc	(working copy)
@@ -26,6 +26,7 @@
 
 #include <stdint.h>
 
+#include "Scene.hh"
 #include "World.hh"
 #include "Entity.hh"
 #include "GazeboError.hh"
@@ -201,7 +202,7 @@
     attached = true;
   }
   else
-    line = OgreCreator::Instance()->CreateDynamicLine(opType);
+    line = vis->AddDynamicLine(opType);
 
   line->setMaterial(OgreCreator::CreateMaterial( data->color.r,
                                                  data->color.g,
@@ -218,9 +219,6 @@
     else
       line->AddPoint(pos);
   }
-
-  if (!attached)
-    vis->AttachObject(line);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -313,7 +311,7 @@
           std::ostringstream bname;
 
           bname << "BILLBOARD_" << this->name;
-          bset = OgreAdaptor::Instance()->sceneMgr->createBillboardSet(
+          bset = OgreAdaptor::Instance()->GetScene(0)->GetManager()->createBillboardSet(
               bname.str().c_str());
         }
 
@@ -412,7 +410,7 @@
   }
   else
   {
-    bset = OgreAdaptor::Instance()->sceneMgr->createBillboardSet(
+    bset = OgreAdaptor::Instance()->GetScene(0)->GetManager()->createBillboardSet(
         bname.str().c_str());
 
     // Create the texture
Index: server/Entity.hh
===================================================================
--- server/Entity.hh	(revision 8976)
+++ server/Entity.hh	(working copy)
@@ -36,64 +36,27 @@
 
 namespace gazebo
 {
- 
-  class Geom; 
-  class Body;
-  class Model;
 
   class OgreVisual;
   /// \addtogroup gazebo_server
   /// \{
   
-  
   /// Base class for all objects in Gazebo
   /*
    * Facilitates meshing of physics engine with rendering engine
    */
   class Entity : public Common
   {
-    public: enum Type{DEFAULT, MODEL, BODY, GEOM, LIGHT};
 
     /// \brief Constructor
     /// \param parent Parent of the entity.
-    public: Entity(Entity *parent = NULL);
+    public: Entity(Common *parent = NULL);
   
     /// \brief Destructor
     public: virtual ~Entity();
-
-    /// \brief Return the ID of the parent
-    /// \return Integer ID
-    public: int GetParentId() const;
-  
-    /// \brief Set the parent
-    /// \param parent Parent entity
-    public: void SetParent(Entity *parent);
-  
-    /// \brief Get the parent
-    /// \return Pointer to the parent entity
-    public: Entity *GetParent() const;
-
-    /// \brief Add a child to this entity
-    /// \param child Child entity
-    public: void AddChild(Entity *child);
-
-    /// \brief Remove a child from this entity
-    /// \param child Child to remove
-    public: virtual void RemoveChild(Entity *child);
-  
-    /// \brief Get all children
-    /// \return Vector of children entities
-    public: const std::vector< Entity* >  &GetChildren() const;
-
-    /// \brief Get the number of children
-    public: unsigned int GetChildCount() const;
-
-    /// \brief Get a child by index
-    public: Entity *GetChild(unsigned int i);
-
-    /// \brief Get a child by name
-    public: Entity *GetChild(const std::string &name );
-  
+ 
+    public: void SetName(const std::string &name);
+ 
     /// \brief Return this entity's sceneNode
     /// \return Ogre scene node
     public: OgreVisual *GetVisualNode() const;
@@ -110,13 +73,6 @@
     /// \return bool True = static
     public: bool IsStatic() const;
   
-    /// \brief Set whether this entity has been selected by the user through 
-    //         the gui
-    public: virtual bool SetSelected( bool s );
-  
-    /// \brief True if the entity is selected by the user
-    public: bool IsSelected() const;
-
     /// \brief Get the absolute pose of the entity
     public: virtual Pose3d GetWorldPose() const;
 
@@ -179,52 +135,17 @@
     ///        pose of the parent has changed
     protected: virtual void OnPoseChange() {}
 
-    public: void Print(std::string prefix);
-
-    /// \brief Returns true if the entities are the same. Checks only the name
-    public: bool operator==(const Entity &ent) const;
-
-    /// \brief Get the parent model, if one exists
-    /// \return Pointer to a model, or NULL if no parent model exists
-    public: Model *GetParentModel() const;
-
-    /// \brief Return the name of this entity with the model scope
-    ///        model1::...::modelN::entityName
-    public: std::string GetScopedName() const;
-
-    /// \brief Return the name of this entity with the model+body+geom scope
-    ///        model1::...::modelN::bodyN::entityName
-    public: std::string GetCompleteScopedName() const;
-
-    /// \brief Set the type of this entity
-    public: void SetType(Type type);
-
-    /// \brief Get the type of this entity
-    public: Type GetType() const;
-
-    /// \brief Get the type as a string
-    public: std::string GetTypeString() const;
-
     /// \brief Handle a change of pose
     private: void PoseChange(bool notify = true);
 
-    /// \brief Parent of this entity
-    protected: Entity *parent;
-  
-    /// \brief Children of this entity
-    protected: std::vector< Entity* > children;
-  
     // is this an static entity
     protected: ParamT<bool> *staticP;
   
     /// \brief Visual stuff
     protected: OgreVisual *visualNode;
   
-    private: bool selected;
 
     private: Pose3d relativePose;
-
-    protected: Type type;
   };
   
   /// \}
Index: server/Simulator.hh
===================================================================
--- server/Simulator.hh	(revision 8976)
+++ server/Simulator.hh	(working copy)
@@ -45,7 +45,7 @@
 /// \{
 
 // Forward declarations
-  class Gui;
+  class SimulationApp;
   class Server;
   class XMLConfig;
   class XMLConfigNode;
@@ -88,8 +88,10 @@
     public: void Fini( );
 
     /// \brief Main simulation loop, when this loop ends the simulation finish
-    public: void MainLoop();
+    public: void Run();
 
+    public: void GraphicsUpdate();
+
     /// \brief Gets the local configuration for this computer
     public: GazeboConfig *GetGazeboConfig() const;
 
@@ -129,6 +131,12 @@
     /// \brief Simulator finished by the user
     public: void SetUserQuit();
 
+    /// \brief Stop the physics engine
+    public: void StopPhysics();
+
+    /// \brief Start the physics engine
+    public: void StartPhysics();
+
     /// \brief Return true if the step has incremented
     public: bool GetStepInc() const;
 
@@ -145,7 +153,8 @@
     public: void SetRenderEngineEnabled( bool enabled );
 
     /// \brief Return true if the gui is enabled
-    public: bool GetRenderEngineEnabled() const;
+    public: inline bool GetRenderEngineEnabled() const
+            { return this->renderEngineEnabled; }
 
     /// \brief Set the length of time the simulation should run.
     public: void SetTimeout(double time);
@@ -154,7 +163,8 @@
     public: void SetPhysicsEnabled(bool enabled);
 
     /// \brief Get the physics enabled/disabled
-    public: bool GetPhysicsEnabled() const;
+    public: inline bool GetPhysicsEnabled() const 
+            {return this->physicsEnabled;}
 
     /// \brief Get the model that contains the entity
     public: Model *GetParentModel( Entity *entity ) const;
@@ -204,7 +214,7 @@
     private: XMLConfig *xmlFile;
 
     /// Pointer to the selected Gui 
-    private: Gui *gui;
+    private: SimulationApp *gui;
 
     private: OgreAdaptor *renderEngine;
 
@@ -235,6 +245,7 @@
 
     //The user has somewhat signaled the end of the program
     private: bool userQuit;
+    private: bool physicsQuit;
 
     /// True if the GUI is enabled
     private: bool guiEnabled;

Property changes on: server/physics/SurfaceParams.cc
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/server/physics/SurfaceParams.cc:r8900-8978
   Merged /code/gazebo/branches/wx/server/physics/SurfaceParams.cc:r8807-8927

Index: server/physics/TrimeshShape.cc
===================================================================
--- server/physics/TrimeshShape.cc	(revision 8976)
+++ server/physics/TrimeshShape.cc	(working copy)
@@ -39,7 +39,7 @@
 // Constructor
 TrimeshShape::TrimeshShape(Geom *parent) : Shape(parent)
 {
-  this->type = Shape::TRIMESH;
+  this->AddType(TRIMESH_SHAPE);
 
   Param::Begin(&this->parameters);
   this->meshNameP = new ParamT<std::string>("mesh","",1);
@@ -96,7 +96,7 @@
     meshManager->GenSphericalTexCoord(this->mesh,center);
   }
 
-  Mass mass = this->parent->GetMass();
+  Mass mass = this->geomParent->GetMass();
 
   if (this->mesh->GetSubMeshCount() > 1)
   {
@@ -138,7 +138,7 @@
       config->LoadString( stream.str() );
 
       Geom *newGeom = this->physicsEngine->CreateGeom( "trimesh", 
-          this->parent->GetBody() );
+          this->geomParent->GetBody() );
 
       newGeom->SetSaveable(false);
       newGeom->Load( config->GetRootNode()->GetChild() );

Property changes on: server/physics/TrimeshShape.cc
___________________________________________________________________
Modified: svn:mergeinfo
   Reverse-merged /code/gazebo/branches/bullet2/server/physics/TrimeshShape.cc:r8321-8355
   Merged /code/gazebo/trunk/server/physics/TrimeshShape.cc:r8900-8978
   Merged /code/gazebo/branches/wx/server/physics/TrimeshShape.cc:r8807-8927

Index: server/physics/Geom.hh
===================================================================
--- server/physics/Geom.hh	(revision 8976)
+++ server/physics/Geom.hh	(working copy)
@@ -101,15 +101,18 @@
   
     /// \brief Get the laser retro reflectiveness 
     public: float GetLaserRetro() const;
- 
+
+    /// \brief Toggle bounding box visibility
+    public: void ToggleShowBoundingBox();
+
     /// \brief Set the visibility of the bounding box
     public: void ShowBoundingBox(bool show);
 
-    /// \brief Set the visibility of the joints
-    public: void ShowJoints(bool show);
+    /// \brief Toggle transparency
+    public: void ToggleTransparent();
 
-    /// \brief Set the visibility of the physical entity of this geom
-    public: void ShowPhysics(bool);
+    /// \brief Set the transparency
+    public: void SetTransparent(bool show);
 
     /// \brief Set the mass
     public: void SetMass(const double &mass);
@@ -142,7 +145,7 @@
     public: const Mass &GetMass() const;
 
     /// \brief Get the shape type
-    public: Shape::Type GetShapeType();
+    public: EntityType GetShapeType();
 
     /// \brief Set the shape for this geom
     public: void SetShape(Shape *shape);
@@ -191,7 +194,7 @@
 
     /// \brief Get the angular acceleration of the geom in the world frame
     public: virtual Vector3 GetWorldAngularAccel() const;
- 
+
     public: template< typename T>
             boost::signals::connection ConnectContactCallback( T subscriber )
             { return contactSignal.connect(subscriber); }
@@ -209,8 +212,6 @@
     ///  Contact parameters
     public: SurfaceParams *surface; 
 
-    public: std::vector<Contact> contacts;
- 
     /// The body this geom belongs to
     protected: Body *body;
   

Property changes on: server/physics/HeightmapShape.hh
___________________________________________________________________
Modified: svn:mergeinfo
   Reverse-merged /code/gazebo/branches/bullet2/server/physics/HeightmapShape.hh:r8321-8355
   Merged /code/gazebo/trunk/server/physics/HeightmapShape.hh:r8900-8978
   Merged /code/gazebo/branches/wx/server/physics/HeightmapShape.hh:r8807-8927

Index: server/physics/Body.hh
===================================================================
--- server/physics/Body.hh	(revision 8976)
+++ server/physics/Body.hh	(working copy)
@@ -217,6 +217,9 @@
     /// \brief Set the angular damping factor
     public: virtual void SetAngularDamping(double damping) = 0;
 
+    /// \brief Toggle show the physics visualizations
+    public: void ToggleShowPhysics();
+
     /// \brief Set to true to show the physics visualizations
     public: void ShowPhysics(bool show);
 
@@ -293,6 +296,9 @@
 
     /// This flag is used to trigger the enabledSignal
     private: bool enabled;
+
+    protected: Pose3d newPose;
+    protected: bool poseDirty;
   };
 
   /// \}

Property changes on: server/physics/MapShape.hh
___________________________________________________________________
Modified: svn:mergeinfo
   Reverse-merged /code/gazebo/branches/bullet2/server/physics/MapShape.hh:r8321-8355
   Merged /code/gazebo/branches/wx/server/physics/MapShape.hh:r8807-8927

Index: server/physics/HingeJoint.hh
===================================================================
--- server/physics/HingeJoint.hh	(revision 8976)
+++ server/physics/HingeJoint.hh	(working copy)
@@ -91,7 +91,7 @@
     /// \brief Constructor
     public: HingeJoint() : T()
             {
-              this->type = Joint::HINGE;
+              this->AddType(HINGE_JOINT);
 
               Param::Begin(&this->parameters);
               this->axisP = new ParamT<Vector3>("axis",Vector3(0,1,0), 1);
Index: server/physics/Shape.hh
===================================================================
--- server/physics/Shape.hh	(revision 8976)
+++ server/physics/Shape.hh	(working copy)
@@ -7,7 +7,6 @@
 #include "XMLConfig.hh"
 #include "Common.hh"
 
-
 namespace gazebo
 {
   class Geom;
@@ -16,12 +15,6 @@
   /// \brief Base class for all shapes
   class Shape : public Common
   {
-    public: enum Type {BOX, CYLINDER, HEIGHTMAP, MAP, SPHERE, PLANE, RAY, 
-                       TRIMESH, MULTIRAY, TYPE_COUNT};
-
-    // These names should be all lower-caser versions of the Type enum.
-    public: static std::string TypeNames[TYPE_COUNT]; 
-
     /// \brief Constructor
     public: Shape(Geom *p);
 
@@ -34,10 +27,7 @@
     /// \brief Save the shape
     public: virtual void Save(std::string &prefix, std::ostream &stream) = 0;
 
-    public: Shape::Type GetType() const;
-
-    protected: Geom *parent;
-    protected: Type type;
+    protected: Geom *geomParent;
     protected: PhysicsEngine *physicsEngine;
   };
 }
Index: server/physics/PlaneShape.cc
===================================================================
--- server/physics/PlaneShape.cc	(revision 8976)
+++ server/physics/PlaneShape.cc	(working copy)
@@ -28,7 +28,8 @@
 /// Constructor
 PlaneShape::PlaneShape(Geom *parent) : Shape(parent)
 {
-  this->type = Shape::PLANE;
+  this->AddType(PLANE_SHAPE);
+  this->SetName("plane_shape");
 
   Param::Begin(&this->parameters);
   this->normalP = new ParamT<Vector3>("normal",Vector3(0,0,1),0);
@@ -100,7 +101,7 @@
   this->meshName = OgreCreator::CreatePlane(**(this->normalP), 
       **(this->sizeP), **(this->segmentsP), **(this->uvTileP), 
       **(this->materialP), **(this->castShadowsP), 
-      this->parent->GetVisualNode(), this->meshName);
+      this->geomParent->GetVisualNode(), this->meshName);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: server/physics/PhysicsEngine.hh
===================================================================
--- server/physics/PhysicsEngine.hh	(revision 8976)
+++ server/physics/PhysicsEngine.hh	(working copy)
@@ -95,10 +95,10 @@
   
     /// \brief Initialize the physics engine
     public: virtual void Init() = 0;
+ 
+    /// \brief Init the engine for threads. 
+    public: virtual void InitForThread() = 0;
 
-    /// \brief Initialize for separate thread
-    public: virtual void InitForThread() = 0;
-  
     /// \brief Update the physics engine collision
     public: virtual void UpdateCollision() = 0;
 
@@ -118,20 +118,17 @@
     public: virtual Body *CreateBody(Entity *parent) = 0;
 
     /// \brief Create a geom
-    public: virtual Geom *CreateGeom(Shape::Type type, Body *body) = 0;
+    public: virtual Geom *CreateGeom(std::string shapeTypename, Body *body) = 0;
 
-    /// \brief Create a geom
-    public: Geom *CreateGeom(std::string typeName, Body *body);
-  
     /// \brief Create a new joint
-    public: virtual Joint *CreateJoint(Joint::Type type) = 0;
+    public: virtual Joint *CreateJoint(std::string type) = 0;
   
     /// \brief Return the gavity vector
     /// \return The gavity vector
     public: Vector3 GetGravity() const;
 
     /// \brief Set the gavity vector
-    public: void SetGravity(Vector3 gravity) const;
+    public: virtual void SetGravity(const gazebo::Vector3 &gravity) = 0;
 
     /// \brief Get the time between each update cycle
     /// \return seconds between updates 
@@ -156,6 +153,8 @@
     /// \brief Lock the physics engine mutex
     public: void LockMutex();
 
+    public: inline bool Locked() const {return this->locked;}
+
     /// \brief Unlock the physics engine mutex
     public: void UnlockMutex();
 
@@ -165,6 +164,9 @@
     /// \brief Convert a Gazebo mass to an engine specific mass
     public: virtual void ConvertMass(void *engineMass, const Mass &mass) = 0;
 
+    /// \brief Toggle whether to show contacts
+    public: void ToggleShowVisual();
+
     /// \brief Set whether to show contacts
     public: void ShowVisual(bool show);
 
@@ -202,6 +204,18 @@
     /// \brief access functions to set ODE parameters
     public: virtual double GetMaxContacts() {return 0;}
 
+    /// \brief Get the count of the parameters
+    public: unsigned int GetParamCount() const;
+
+    /// \brief Get a param by index
+    public: Param *GetParam(unsigned int index) const;
+
+    /// \brief Get a parameter by name
+    public: Param *GetParam(const std::string &key) const;
+
+     /// \brief Set a parameter by name
+    public: void SetParam(const std::string &key, const std::string &value);
+ 
     /// \brief Add a contact visual
     protected: void AddContactVisual(Vector3 pos, Vector3 norm);
 
@@ -219,6 +233,7 @@
     protected: std::vector<Param*> parameters;
 
     private: boost::recursive_mutex *mutex;
+    private: bool locked;
 
     protected: OgreVisual *visual;
 
Index: server/physics/Geom.cc
===================================================================
--- server/physics/Geom.cc	(revision 8976)
+++ server/physics/Geom.cc	(working copy)
@@ -26,6 +26,9 @@
 
 #include <sstream>
 
+#include "RenderState.hh"
+#include "Events.hh"
+#include "Model.hh"
 #include "Shape.hh"
 #include "Mass.hh"
 #include "PhysicsEngine.hh"
@@ -46,7 +49,8 @@
 Geom::Geom( Body *body )
     : Entity(body->GetCoMEntity())
 {
-  this->type = Entity::GEOM;
+  this->AddType(GEOM);
+
   this->physicsEngine = World::Instance()->GetPhysicsEngine();
 
   this->typeName = "unknown";
@@ -82,10 +86,9 @@
   
   Param::End();
 
-  World::Instance()->ConnectShowPhysicsSignal( boost::bind(&Geom::ShowPhysics, this, _1) );
-  World::Instance()->ConnectShowJointsSignal( boost::bind(&Geom::ShowJoints, this, _1) );
-  World::Instance()->ConnectShowPhysicsSignal( boost::bind(&Geom::ShowJoints, this, _1) );
-  World::Instance()->ConnectShowBoundingBoxesSignal( boost::bind(&Geom::ShowBoundingBox, this, _1) );
+  Events::ConnectShowJointsSignal( boost::bind(&Geom::ToggleTransparent, this) );
+  Events::ConnectShowPhysicsSignal( boost::bind(&Geom::ToggleTransparent, this) );
+  Events::ConnectShowBoundingBoxesSignal( boost::bind(&Geom::ToggleShowBoundingBox, this) );
 
   this->body->ConnectEnabledSignal( boost::bind(&Geom::EnabledCB, this, _1) );
 }
@@ -129,14 +132,12 @@
 {
   this->body->DisconnectEnabledSignal(boost::bind(&Geom::EnabledCB, this, _1));
 
-  World::Instance()->DisconnectShowPhysicsSignal( 
-      boost::bind(&Geom::ShowPhysics, this, _1) );
+  Events::DisconnectShowPhysicsSignal( boost::bind(&Geom::ToggleTransparent, this) );
 
-  World::Instance()->DisconnectShowJointsSignal( 
-      boost::bind(&Geom::ShowJoints, this, _1) );
+  Events::DisconnectShowJointsSignal( boost::bind(&Geom::ToggleTransparent, this) );
 
-  World::Instance()->DisconnectShowBoundingBoxesSignal( 
-      boost::bind(&Geom::ShowBoundingBox, this, _1) );
+  Events::DisconnectShowBoundingBoxesSignal( 
+      boost::bind(&Geom::ToggleShowBoundingBox, this) );
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -151,7 +152,6 @@
 
   this->nameP->Load(node);
   this->SetName(this->nameP->GetValue());
-  this->nameP->Load(node);
   this->massP->Load(node);
   this->xyzP->Load(node);
   this->rpyP->Load(node);
@@ -203,7 +203,7 @@
 void Geom::CreateBoundingBox()
 {
   // Create the bounding box
-  if (this->GetShapeType() != Shape::PLANE && this->GetShapeType() != Shape::MAP)
+  if (this->GetShapeType() != PLANE_SHAPE && this->GetShapeType() != MAP_SHAPE)
   {
     Vector3 min;
     Vector3 max;
@@ -220,7 +220,7 @@
     {
       this->bbVisual->SetCastShadows(false);
       this->bbVisual->AttachBoundingBox(min,max);
-      this->bbVisual->SetVisible( World::Instance()->GetShowBoundingBoxes() );
+      this->bbVisual->SetVisible( RenderState::GetShowBoundingBoxes() );
     }
   }
 }
@@ -287,7 +287,6 @@
 // Update
 void Geom::Update()
 {
-  this->ClearContacts();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -326,6 +325,14 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+// Toggle bounding box visibility
+void Geom::ToggleShowBoundingBox()
+{
+  if (this->bbVisual)
+    this->bbVisual->ToggleVisible();
+}
+
+////////////////////////////////////////////////////////////////////////////////
 /// Set the visibility of the Bounding box of this geometry
 void Geom::ShowBoundingBox(bool show)
 {
@@ -334,11 +341,29 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Set the visibility of the joints of this geometry
-void Geom::ShowJoints(bool show)
+// Toggle transparency
+void Geom::ToggleTransparent()
 {
   std::vector<OgreVisual*>::iterator iter;
 
+  for (iter = this->visuals.begin(); iter != this->visuals.end(); iter++)
+  {
+    if (*iter)
+    {
+      if ((*iter)->GetTransparency() == 0.0)
+        (*iter)->SetTransparency(0.6);
+      else
+        (*iter)->SetTransparency(0.0);
+    }
+  }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Set the transparency
+void Geom::SetTransparent(bool show)
+{
+  std::vector<OgreVisual*>::iterator iter;
+
   if (show)
   {
     for (iter = this->visuals.begin(); iter != this->visuals.end(); iter++)
@@ -364,13 +389,6 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Set the visibility of the physical entity of this geom
-void Geom::ShowPhysics(bool show)
-{
-  this->body->ShowPhysics(show);
-}
-
-////////////////////////////////////////////////////////////////////////////////
 /// Set the mass
 void Geom::SetMass(const Mass &_mass)
 {
@@ -449,9 +467,9 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 // Get the shape type
-Shape::Type Geom::GetShapeType()
+EntityType Geom::GetShapeType()
 {
-  return this->shape->GetType();
+  return this->shape->GetLeafType();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -483,43 +501,28 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+/// Get the number of contacts
+unsigned int Geom::GetContactCount() const
+{
+  return this->GetParentModel()->GetContactCount(this);
+}
+
+////////////////////////////////////////////////////////////////////////////////
 /// Add an occurance of a contact to this geom
 void Geom::AddContact(const Contact &contact)
 {
-  if (!this->contactsEnabled)
+  if (!this->GetContactsEnabled() || this->GetShapeType() == RAY_SHAPE || this->GetShapeType() == PLANE_SHAPE)
     return;
 
-  if (this->GetShapeType() == Shape::RAY || this->GetShapeType() == Shape::PLANE)
-    return;
-
-  this->contacts.push_back( contact.Clone() );
+  this->GetParentModel()->StoreContact(this, contact);
   this->contactSignal( contact );
-}
+}           
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Clear all contact info
-void Geom::ClearContacts()
-{
-  this->contacts.clear();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get the number of contacts
-unsigned int Geom::GetContactCount() const
-{
-  return this->contacts.size();
-}
-            
-////////////////////////////////////////////////////////////////////////////////
 /// Get a specific contact
 Contact Geom::GetContact(unsigned int i) const
 {
-  if (i < this->contacts.size())
-    return this->contacts[i];
-  else
-    gzerr(0) << "Invalid contact index\n";
-
-  return Contact();
+  return this->GetParentModel()->RetrieveContact(this, i);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: server/physics/HeightmapShape.cc
===================================================================
--- server/physics/HeightmapShape.cc	(revision 8976)
+++ server/physics/HeightmapShape.cc	(working copy)
@@ -42,7 +42,7 @@
 HeightmapShape::HeightmapShape(Geom *parent)
     : Shape(parent)
 {
-  this->type = Shape::HEIGHTMAP;
+  this->AddType(HEIGHTMAP_SHAPE);
 
   Param::Begin(&this->parameters);
   this->imageFilenameP = new ParamT<std::string>("image","",1);
@@ -52,7 +52,7 @@
   this->offsetP = new ParamT<Vector3>("offset",Vector3(0,0,0), 0);
   Param::End();
 
-  this->ogreHeightmap = new OgreHeightmap();
+  this->ogreHeightmap = new OgreHeightmap(0);
 }
 
 

Property changes on: server/physics/HeightmapShape.cc
___________________________________________________________________
Modified: svn:mergeinfo
   Reverse-merged /code/gazebo/branches/bullet2/server/physics/HeightmapShape.cc:r8321-8355
   Merged /code/gazebo/trunk/server/physics/HeightmapShape.cc:r8900-8978
   Merged /code/gazebo/branches/wx/server/physics/HeightmapShape.cc:r8807-8927

Index: server/physics/BallJoint.hh
===================================================================
--- server/physics/BallJoint.hh	(revision 8976)
+++ server/physics/BallJoint.hh	(working copy)
@@ -70,7 +70,7 @@
     /// \brief Constructor
     public: BallJoint() : T()
             {
-              this->type = Joint::BALL;
+              this->AddType(BALL_JOINT);
             }
   
     /// \brief Destructor
Index: server/physics/CMakeLists.txt
===================================================================
--- server/physics/CMakeLists.txt	(revision 8976)
+++ server/physics/CMakeLists.txt	(working copy)
@@ -1,5 +1,19 @@
 include (${gazebo_cmake_dir}/GazeboUtils.cmake)
 
+
+STRING (REPLACE " " ";" parallel_quickstep_include_dirs_split "${parallel_quickstep_include_dirs}")
+STRING (REPLACE " " ";" parallel_quickstep_library_dirs_split "${parallel_quickstep_library_dirs}")
+
+INCLUDE_DIRECTORIES(
+  ${CMAKE_SOURCE_DIR}/libgazebo 
+  ${parallel_quickstep_include_dirs_split}
+)
+
+LINK_DIRECTORIES(  
+ ${CMAKE_BINARY_DIR}/libgazebo 
+ ${parallel_quickstep_library_dirs_split} 
+)
+
 if (INCLUDE_ODE)
   add_subdirectory(ode)
 endif (INCLUDE_ODE)
@@ -55,14 +69,15 @@
 )
 
 add_library(gazebo_physics SHARED ${sources})
+target_link_libraries(gazebo_physics parallel_quickstep ${LINK_LIBS} )
 
 if (CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE})
-  set_source_files_properties(${sources} PROPERTIES LINK_FLAGS 
-    ${CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE}})
-  set_target_properties(gazebo_physics PROPERTIES LINK_FLAGS 
-    ${CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE}})
+  set_source_files_properties(${sources} PROPERTIES LINK_FLAGS ${CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE}})
+  set_target_properties(gazebo_physics PROPERTIES LINK_FLAGS ${CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE}} ${parallel_quickstep_lflags})
 endif (CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE})
 
+target_link_libraries(gazebo_physics profiler)
+
 install ( TARGETS gazebo_physics DESTINATION ${CMAKE_INSTALL_PREFIX}/lib )
 #APPEND_TO_SERVER_SOURCES(${sources})
 APPEND_TO_SERVER_HEADERS(${headers})
Index: server/physics/CylinderShape.cc
===================================================================
--- server/physics/CylinderShape.cc	(revision 8976)
+++ server/physics/CylinderShape.cc	(working copy)
@@ -6,7 +6,7 @@
 /// Constructor
 CylinderShape::CylinderShape(Geom *parent) : Shape(parent)
 {
-  this->type = Shape::CYLINDER;
+  this->AddType(CYLINDER_SHAPE);
 
   Param::Begin(&this->parameters);
   this->sizeP = new ParamT<Vector2<double> >("size", 
Index: server/physics/Hinge2Joint.hh
===================================================================
--- server/physics/Hinge2Joint.hh	(revision 8976)
+++ server/physics/Hinge2Joint.hh	(working copy)
@@ -100,7 +100,7 @@
   /// \brief Constructor
   public: Hinge2Joint() : T()
           {
-            this->type = Joint::HINGE2;
+            this->AddType(HINGE2_JOINT);
 
             Param::Begin(&this->parameters);
             this->axis1P = new ParamT<Vector3>("axis1",Vector3(0,0,1), 0);
Index: server/physics/Joint.hh
===================================================================
--- server/physics/Joint.hh	(revision 8976)
+++ server/physics/Joint.hh	(working copy)
@@ -30,6 +30,7 @@
 #include "Common.hh"
 #include "Param.hh"
 #include "Vector3.hh"
+#include "Global.hh"
 #include <boost/signal.hpp>
 
 namespace gazebo
@@ -49,12 +50,8 @@
   class Joint : public Common
   {
     /// \brief Type of joint
-    public: enum Type {SLIDER, HINGE, HINGE2, BALL, UNIVERSAL, TYPE_COUNT};
     public: enum Attribute {FUDGE_FACTOR, SUSPENSION_ERP, SUSPENSION_CFM, STOP_ERP,STOP_CFM,ERP,CFM,FMAX,VEL,HI_STOP,LO_STOP};
 
-    /// \brief Type names of joint
-    public: static std::string TypeNames[TYPE_COUNT]; 
-
     /// \brief Constructor
     public: Joint();
 
@@ -71,6 +68,9 @@
     /// \brief Update the joint
     public: void Update();
 
+    /// \brief Toggle the joint visuals visibility
+    public: void ToggleShowJoints();
+
     /// \brief Set the joint to show visuals
     public: void ShowJoints(bool s);
 
@@ -80,9 +80,6 @@
     /// \brief Set the model this joint belongs too
     public: void SetModel(Model *model);
 
-    /// \brief Get the type of the joint
-    public: Joint::Type GetType() const;
-
     /// \brief Get the body to which the joint is attached according the _index
     public: virtual Body *GetJointBody( int index ) const = 0;
 
@@ -163,9 +160,6 @@
     /// \brief Set a parameter for the joint
     public: virtual void SetAttribute( Attribute, int index, double value) = 0;
   
-    /// Type of Joint
-    protected: Type type;
-
     /// The first body this joint connects to
     protected: Body *body1;
 
Index: server/physics/Body.cc
===================================================================
--- server/physics/Body.cc	(revision 8976)
+++ server/physics/Body.cc	(working copy)
@@ -27,6 +27,7 @@
 #include <sstream>
 #include <float.h>
 
+#include "Events.hh"
 #include "SensorManager.hh"
 #include "XMLConfig.hh"
 #include "Model.hh"
@@ -55,9 +56,13 @@
 Body::Body(Entity *parent)
     : Entity(parent)
 {
-  this->type = Entity::BODY;
+  this->AddType(BODY);
+  this->GetVisualNode()->SetShowInGui(false);
+
   this->comEntity = new Entity(this);
   this->comEntity->SetName("COM_Entity");
+  this->comEntity->SetShowInGui(false);
+  this->comEntity->GetVisualNode()->SetShowInGui(false);
 
   this->physicsEngine = World::Instance()->GetPhysicsEngine();
 
@@ -218,6 +223,7 @@
 
   this->SetKinematic(**this->kinematicP);
 
+  Events::ConnectShowPhysicsSignal( boost::bind(&Body::ToggleShowPhysics, this) );
   //this->GetModel()->ConnectUpdateSignal( boost::bind(&Body::Update, this) );
 }
 
@@ -347,6 +353,8 @@
 // Initialize the body
 void Body::Init()
 {
+  this->poseDirty = false;
+
   // If no geoms are attached, then don't let gravity affect the body.
   if (this->geoms.size()==0 || **this->turnGravityOffP)
     this->SetGravityMode(false);
@@ -392,9 +400,8 @@
       // Create a line to each geom
       for (giter = this->geoms.begin(); giter != this->geoms.end(); giter++)
       {
-        OgreDynamicLines *line = OgreCreator::Instance()->CreateDynamicLine(OgreDynamicRenderable::OT_LINE_LIST);
-        line->setMaterial("Gazebo/GreenEmissive");
-        this->cgVisual->AttachObject(line);
+        OgreDynamicLines *line = this->cgVisual->AddDynamicLine(OgreDynamicRenderable::OT_LINE_LIST);
+        line->setMaterial("Gazebo/GreenGlow");
         line->AddPoint(Vector3(0,0,0));
         line->AddPoint(giter->second->GetRelativePose().pos);
       }
@@ -410,11 +417,11 @@
 // Update the body
 void Body::Update()
 {
-  //DiagnosticTimer timer("Body[" + this->GetName() +"] Update");
-  
-  std::map< std::string, Geom* >::iterator geomIter;
-  Vector3 vel;
-  Vector3 avel;
+  if (this->poseDirty)
+  {
+    this->poseDirty = false;
+    this->SetWorldPose(this->newPose, false);
+  }
 
   // Apply our linear accel
   this->SetForce(this->linearAccel);
@@ -428,20 +435,6 @@
   //   this->enabled = this->GetEnabled();
   //   this->enabledSignal(this->enabled);
   // }
- 
-  {
-    //DiagnosticTimer timer("Body[" + this->GetName() +"] Update Geoms");
-
-    for (geomIter=this->geoms.begin();
-        geomIter!=this->geoms.end(); geomIter++)
-    {
-#ifdef USE_THREADPOOL
-      World::Instance()->threadPool->schedule(boost::bind(&Geom::Update, (geomIter->second)));
-#else
-      geomIter->second->Update();
-#endif
-    }
-  }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -704,6 +697,14 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+/// Toggle show the physics visualizations
+void Body::ToggleShowPhysics()
+{
+  if (this->cgVisual)
+    this->cgVisual->ToggleVisible();
+}
+
+////////////////////////////////////////////////////////////////////////////////
 /// Set to true to show the physics visualizations
 void Body::ShowPhysics(bool show)
 {
Index: server/physics/MapShape.cc
===================================================================
--- server/physics/MapShape.cc	(revision 8976)
+++ server/physics/MapShape.cc	(working copy)
@@ -49,7 +49,7 @@
 MapShape::MapShape(Geom *parent)
     : Shape(parent)
 {
-  this->type = Shape::MAP;
+  this->AddType(MAP_SHAPE);
 
   this->root = new QuadNode(NULL);
 
@@ -151,7 +151,7 @@
     std::ostringstream stream;
 
     // Create the box geometry
-    Geom *geom = this->physicsEngine->CreateGeom("box",this->parent->GetBody());
+    Geom *geom = this->physicsEngine->CreateGeom("box", this->geomParent->GetBody());
     geom->SetSaveable(false);
 
     XMLConfig *boxConfig = new XMLConfig();

Property changes on: server/physics/MapShape.cc
___________________________________________________________________
Modified: svn:mergeinfo
   Reverse-merged /code/gazebo/branches/bullet2/server/physics/MapShape.cc:r8321-8355
   Merged /code/gazebo/branches/wx/server/physics/MapShape.cc:r8807-8927

Index: server/physics/SliderJoint.hh
===================================================================
--- server/physics/SliderJoint.hh	(revision 8976)
+++ server/physics/SliderJoint.hh	(working copy)
@@ -89,7 +89,7 @@
     /// \brief Constructor
     public: SliderJoint( ) : T()
             {
-              this->type = Joint::SLIDER;
+              this->AddType(SLIDER_JOINT);
 
               Param::Begin(&this->parameters);
               this->axisP = new ParamT<Vector3>("axis",Vector3(0,0,1), 0);
Index: server/physics/Shape.cc
===================================================================
--- server/physics/Shape.cc	(revision 8976)
+++ server/physics/Shape.cc	(working copy)
@@ -4,28 +4,22 @@
 
 using namespace gazebo;
 
-std::string Shape::TypeNames[Shape::TYPE_COUNT] = {"box", "cylinder", "heightmap", "map", "sphere", "plane", "ray", "trimesh", "multiray"};
-
 ////////////////////////////////////////////////////////////////////////////////
 // Constructor
 Shape::Shape(Geom *p)
-  : parent(p) 
+  : Common(p) 
 {
-  this->parent->SetShape(this);
+  this->AddType(SHAPE);
+  this->geomParent = p;
+  this->geomParent->SetShape(this);
   this->physicsEngine = World::Instance()->GetPhysicsEngine();
+  this->SetName("shape");
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Destructor
 Shape::~Shape()
 {
-  if (this->parent)
-    this->parent->SetShape(NULL);
+  if (this->geomParent)
+    this->geomParent->SetShape(NULL);
 }
-
-////////////////////////////////////////////////////////////////////////////////
-// Get the type
-Shape::Type Shape::GetType() const
-{
-  return this->type;
-}
Index: server/physics/bullet/BulletPhysics.hh
===================================================================
--- server/physics/bullet/BulletPhysics.hh	(revision 8976)
+++ server/physics/bullet/BulletPhysics.hh	(working copy)
@@ -100,9 +100,9 @@
   /// \brief Initialize the Bullet engine
   public: virtual void Init();
 
-  /// \brief Initialize for separate thread
+  /// \brief Init the engine for threads. 
   public: virtual void InitForThread();
- 
+
   /// \brief Update the Bullet collision
   public: virtual void UpdateCollision();
 
@@ -122,10 +122,10 @@
   public: virtual Body *CreateBody(Entity *parent);
 
   /// \brief Create a new geom
-  public: virtual Geom *CreateGeom(Shape::Type type, Body *body);
+  public: virtual Geom *CreateGeom(std::string type, Body *body);
 
   /// \brief Create a new joint
-  public: virtual Joint *CreateJoint(Joint::Type type);
+  public: virtual Joint *CreateJoint(std::string type);
 
   /// \brief Create a physics based ray sensor
   //public: virtual PhysicsRaySensor *CreateRaySensor(Body *body);
@@ -146,6 +146,9 @@
   public: btDynamicsWorld *GetDynamicsWorld() const
           {return this->dynamicsWorld;}
 
+  /// \brief Set the gavity vector
+  public: virtual void SetGravity(const gazebo::Vector3 &gravity);
+
   //private: btAxisSweep3 *broadPhase;
   private: btBroadphaseInterface *broadPhase;
   private: btDefaultCollisionConfiguration *collisionConfig;
Index: server/physics/bullet/BulletPhysics.cc
===================================================================
--- server/physics/bullet/BulletPhysics.cc	(revision 8976)
+++ server/physics/bullet/BulletPhysics.cc	(working copy)
@@ -128,12 +128,11 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Initialize for separate thread
+/// Init the engine for threads. 
 void BulletPhysics::InitForThread()
 {
-  return;
 }
- 
+
 ////////////////////////////////////////////////////////////////////////////////
 // Update the Bullet collisions, create joints
 void BulletPhysics::UpdateCollision()
@@ -191,7 +190,7 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Create a new geom
-Geom *BulletPhysics::CreateGeom(Shape::Type type, Body *parent)
+Geom *BulletPhysics::CreateGeom(std::string type, Body *parent)
 {
   BulletGeom *geom = NULL;
   Shape *shape = NULL;
@@ -204,29 +203,20 @@
 
   geom = new BulletGeom(parent);
 
-  switch(type)
-  {
-    case Shape::SPHERE:
-      shape = new BulletSphereShape(geom);
-      break;
-    case Shape::BOX:
-      shape = new BulletBoxShape(geom);
-      break;
-    case Shape::CYLINDER:
-      shape = new BulletCylinderShape(geom);
-      break;
-    case Shape::PLANE:
-      shape = new BulletPlaneShape(geom);
-      break;
-    case Shape::TRIMESH:
-      shape = new BulletTrimeshShape(geom);
-      break;
-    case Shape::MAP:
-      shape = new MapShape(geom);
-      break;
-    default:
-      gzthrow("Unable to create a geom of type[" << type << "]");
-  }
+  if (type == "sphere")
+    shape = new BulletSphereShape(geom);
+  if (type == "box")
+    shape = new BulletBoxShape(geom);
+  if (type == "cylinder")
+    shape = new BulletCylinderShape(geom);
+  if (type == "plane")
+    shape = new BulletPlaneShape(geom);
+  if (type == "trimesh")
+    shape = new BulletTrimeshShape(geom);
+  if (type == "map")
+    shape = new MapShape(geom);
+  else 
+    gzthrow("Unable to create a geom of type[" << type << "]");
 
   return geom;
 }
@@ -234,24 +224,20 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 // Create a new joint
-Joint *BulletPhysics::CreateJoint(Joint::Type type)
+Joint *BulletPhysics::CreateJoint(std::string type)
 {
-  switch (type)
-  {
-    case Joint::SLIDER:
-      return new BulletSliderJoint(this->dynamicsWorld);
-    case Joint::HINGE:
-      return new BulletHingeJoint(this->dynamicsWorld);
-    case Joint::HINGE2:
-      return new BulletHinge2Joint(this->dynamicsWorld);
-    case Joint::BALL:
-      return new BulletBallJoint(this->dynamicsWorld);
-    case Joint::UNIVERSAL:
-      return new BulletUniversalJoint(this->dynamicsWorld);
-    default:
-      gzthrow("Unable to create joint of type[" << type << "]");
-      return NULL;
-  }
+  if (type == "slider")
+    return new BulletSliderJoint(this->dynamicsWorld);
+  if (type == "hinge")
+    return new BulletHingeJoint(this->dynamicsWorld);
+  if (type == "hinge2")
+    return new BulletHinge2Joint(this->dynamicsWorld);
+  if (type == "ball")
+    return new BulletBallJoint(this->dynamicsWorld);
+  if (type == "universal")
+    return new BulletUniversalJoint(this->dynamicsWorld);
+  else 
+    gzthrow("Unable to create joint of type[" << type << "]");
 
   return NULL;
 }
@@ -302,3 +288,11 @@
                                    pose.rot.z, pose.rot.u) );
   return trans;
 }
+
+////////////////////////////////////////////////////////////////////////////////
+/// Set the gavity vector
+void BulletPhysics::SetGravity(const gazebo::Vector3 &gravity)
+{
+  this->gravityP->SetValue(gravity);
+  this->dynamicsWorld->setGravity(btVector3(gravity.x, gravity.y, gravity.z));
+}
Index: server/physics/bullet/BulletHingeJoint.cc
===================================================================
--- server/physics/bullet/BulletHingeJoint.cc	(revision 8976)
+++ server/physics/bullet/BulletHingeJoint.cc	(working copy)
@@ -26,6 +26,7 @@
 
 #include "Model.hh"
 #include "GazeboMessage.hh"
+#include "GazeboError.hh"
 #include "World.hh"
 #include "BulletBody.hh"
 #include "BulletPhysics.hh"
Index: server/physics/bullet/BulletHinge2Joint.cc
===================================================================
--- server/physics/bullet/BulletHinge2Joint.cc	(revision 8976)
+++ server/physics/bullet/BulletHinge2Joint.cc	(working copy)
@@ -25,6 +25,8 @@
  */
 
 #include "Global.hh"
+#include "GazeboError.hh"
+#include "GazeboMessage.hh"
 #include "BulletBody.hh"
 #include "XMLConfig.hh"
 #include "BulletPhysics.hh"

Property changes on: server/physics/SurfaceParams.hh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/trunk/server/physics/SurfaceParams.hh:r8900-8978
   Merged /code/gazebo/branches/wx/server/physics/SurfaceParams.hh:r8807-8927


Property changes on: server/physics/TrimeshShape.hh
___________________________________________________________________
Modified: svn:mergeinfo
   Reverse-merged /code/gazebo/branches/bullet2/server/physics/TrimeshShape.hh:r8321-8355
   Merged /code/gazebo/trunk/server/physics/TrimeshShape.hh:r8900-8978
   Merged /code/gazebo/branches/wx/server/physics/TrimeshShape.hh:r8807-8927

Index: server/physics/SphereShape.cc
===================================================================
--- server/physics/SphereShape.cc	(revision 8976)
+++ server/physics/SphereShape.cc	(working copy)
@@ -32,7 +32,7 @@
 /// Constructor
 SphereShape::SphereShape(Geom *parent) : Shape(parent)
 {
-  this->type = Shape::SPHERE;
+  this->AddType(SPHERE_SHAPE);
 
   Param::Begin(&this->parameters);
   this->radiusP = new ParamT<double>("size",1.0,0);
Index: server/physics/PhysicsEngine.cc
===================================================================
--- server/physics/PhysicsEngine.cc	(revision 8976)
+++ server/physics/PhysicsEngine.cc	(working copy)
@@ -26,6 +26,8 @@
 
 #include <boost/thread/recursive_mutex.hpp>
 
+#include "RenderState.hh"
+#include "Events.hh"
 #include "World.hh"
 #include "OgreVisual.hh"
 #include "OgreDynamicLines.hh"
@@ -43,15 +45,21 @@
 {
   Param::Begin(&this->parameters);
   this->gravityP = new ParamT<Vector3>("gravity",Vector3(0.0, -9.80665, 0.0), 0);
+  this->gravityP->Callback(&PhysicsEngine::SetGravity, this);
+
   this->updateRateP = new ParamT<double>("updateRate", 0.0, 0);
   this->stepTimeP = new ParamT<Time>("stepTime",0.025,0);
   Param::End();
 
   this->mutex = new boost::recursive_mutex();
+  this->locked = false;
+
   if (Simulator::Instance()->GetRenderEngineEnabled())
   {
     this->visual = OgreCreator::Instance()->CreateVisual("Physics_Engine_Visual");
     this->visual->SetVisible(false);
+    this->visual->SetCastShadows(false);
+    this->visual->SetUseRTShader(false);
     this->contactLines.resize(5000);
 
     Material *mat = new Material();
@@ -67,7 +75,7 @@
          this->contactLinesIter != this->contactLines.end(); 
          this->contactLinesIter++, i++)
     {
-      (*this->contactLinesIter) = OgreCreator::Instance()->CreateDynamicLine(
+      (*this->contactLinesIter) = this->visual->AddDynamicLine(
           OgreDynamicRenderable::OT_LINE_LIST);
       (*this->contactLinesIter)->AddPoint(Vector3(0,0,0));
       (*this->contactLinesIter)->AddPoint(Vector3(0,0,0));
@@ -86,21 +94,21 @@
       (*this->contactLinesIter)->AddPoint(Vector3(0,0,0));
       (*this->contactLinesIter)->AddPoint(Vector3(0,0,0));
       (*this->contactLinesIter)->setMaterial(matName);
-      this->visual->AttachObject(*this->contactLinesIter);
     }
 
-    World::Instance()->ConnectShowContactsSignal( boost::bind(&PhysicsEngine::ShowVisual, this, _1) );
+    Events::ConnectShowContactsSignal( boost::bind(&PhysicsEngine::ToggleShowVisual, this) );
 
     this->contactLinesIter = this->contactLines.begin();
     delete mat;
   }
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Destructor
 PhysicsEngine::~PhysicsEngine()
 {
-  World::Instance()->DisconnectShowContactsSignal( boost::bind(&PhysicsEngine::ShowVisual, this, _1) );
+  Events::DisconnectShowContactsSignal( boost::bind(&PhysicsEngine::ToggleShowVisual, this) );
 
   if (this->visual)
   {
@@ -130,13 +138,6 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Set the gavity vector
-void PhysicsEngine::SetGravity(Vector3 gravity) const
-{
-  this->gravityP->SetValue(gravity);
-}
-
-////////////////////////////////////////////////////////////////////////////////
 /// Get the time between each update cycle
 double PhysicsEngine::GetUpdateRate() const
 {
@@ -169,6 +170,7 @@
 void PhysicsEngine::LockMutex()
 {
   this->mutex->lock();
+  this->locked = true;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -176,24 +178,14 @@
 void PhysicsEngine::UnlockMutex()
 {
   this->mutex->unlock();
+  this->locked = false;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Create a geom
-Geom *PhysicsEngine::CreateGeom(std::string typeName, Body *body)
-{
-  for (unsigned int i = 0; i < Shape::TYPE_COUNT; i++)
-    if (typeName == Shape::TypeNames[i])
-      return this->CreateGeom( (Shape::Type)i, body );
-
-  return NULL; 
-}
-
-////////////////////////////////////////////////////////////////////////////////
 /// Add a contact visual
 void PhysicsEngine::AddContactVisual(Vector3 pos, Vector3 norm)
 {
-  if (!World::Instance()->GetShowContacts())
+  if (!RenderState::GetShowContacts())
     return;
 
   double cm_size = World::Instance()->contactMarkerSize;
@@ -203,10 +195,13 @@
 
   (*this->contactLinesIter)->SetPoint( 0, pos);
   (*this->contactLinesIter)->SetPoint( 1, pos+(norm*cm_size)+(e1*cm_size*0.25)+(e2*cm_size*0.25));
+
   (*this->contactLinesIter)->SetPoint( 2, pos);
   (*this->contactLinesIter)->SetPoint( 3, pos+(norm*cm_size)+(e1*cm_size*0.25)-(e2*cm_size*0.25));
+
   (*this->contactLinesIter)->SetPoint( 4, pos);
   (*this->contactLinesIter)->SetPoint( 5, pos+(norm*cm_size)-(e1*cm_size*0.25)+(e2*cm_size*0.25));
+
   (*this->contactLinesIter)->SetPoint( 6, pos);
   (*this->contactLinesIter)->SetPoint( 7, pos+(norm*cm_size)-(e1*cm_size*0.25)-(e2*cm_size*0.25));
 
@@ -229,6 +224,16 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+// Toggle whether to show contacts
+void PhysicsEngine::ToggleShowVisual()
+{
+  if (!Simulator::Instance()->GetRenderEngineEnabled())
+    return;
+  this->visual->ToggleVisible();
+  this->contactLinesIter = this->contactLines.begin();
+}
+
+////////////////////////////////////////////////////////////////////////////////
 // Set whether to show contacts
 void PhysicsEngine::ShowVisual(bool show)
 {
@@ -238,3 +243,66 @@
   if (show)
     this->contactLinesIter = this->contactLines.begin();
 }
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the count of the parameters
+unsigned int PhysicsEngine::GetParamCount() const
+{
+  return this->parameters.size();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get a param by index
+Param *PhysicsEngine::GetParam(unsigned int index) const
+{
+  if (index < this->parameters.size())
+    return this->parameters[index];
+  else
+    gzerr(0) << "Invalid index[" << index << "]\n";
+  return NULL;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get a parameter by name
+Param *PhysicsEngine::GetParam(const std::string &key) const
+{
+  std::vector<Param*>::const_iterator iter;
+  Param *result = NULL;
+
+  for (iter = this->parameters.begin(); iter != this->parameters.end(); iter++)
+  {
+    if ((*iter)->GetKey() == key)
+    {
+      result = *iter;
+      break;
+    }
+  }
+
+  if (result == NULL)
+    gzerr(0) << "Unable to find Param using key[" << key << "]\n";
+
+  return result;
+
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Set a parameter by name
+void PhysicsEngine::SetParam(const std::string &key, const std::string &value)
+{
+  std::vector<Param*>::const_iterator iter;
+  Param *result = NULL;
+
+  for (iter = this->parameters.begin(); iter != this->parameters.end(); iter++)
+  {
+    if ((*iter)->GetKey() == key)
+    {
+      result = *iter;
+      break;
+    }
+  }
+
+  if (result == NULL)
+    gzerr(0) << "Unable to find Param using key[" << key << "]\n";
+  else
+    result->SetFromString( value, true );
+}
Index: server/physics/BoxShape.cc
===================================================================
--- server/physics/BoxShape.cc	(revision 8976)
+++ server/physics/BoxShape.cc	(working copy)
@@ -6,7 +6,7 @@
 /// Constructor
 BoxShape::BoxShape(Geom *parent) : Shape(parent)
 {
-  this->type = Shape::BOX;
+  this->AddType(BOX_SHAPE);
 
   Param::Begin(&this->parameters);
   this->sizeP = new ParamT<Vector3>("size",Vector3(1,1,1),1);
Index: server/physics/RayShape.cc
===================================================================
--- server/physics/RayShape.cc	(revision 8976)
+++ server/physics/RayShape.cc	(working copy)
@@ -32,21 +32,19 @@
 /// Constructor
 RayShape::RayShape( Geom *parent, bool displayRays ) : Shape(parent), line(NULL)
 {
-  this->type = Shape::RAY;
+  this->AddType(RAY_SHAPE);
   this->SetName("Ray");
 
   if (displayRays && Simulator::Instance()->GetRenderEngineEnabled() )
   {
-    this->line = OgreCreator::Instance()->CreateDynamicLine(
+    this->line = this->geomParent->GetVisualNode()->AddDynamicLine(
         OgreDynamicRenderable::OT_LINE_LIST);
 
     // Add two points
     this->line->AddPoint(Vector3(0,0,0));
     this->line->AddPoint(Vector3(0,0,0));
 
-    this->parent->GetVisualNode()->AttachObject(this->line);
-
-    this->line->setMaterial("Gazebo/BlueEmissive");
+    this->line->setMaterial("Gazebo/BlueGlow");
     this->line->setVisibilityFlags(GZ_LASER_CAMERA);
   }
 
@@ -54,18 +52,13 @@
   this->contactRetro = 0.0;
   this->contactFiducial = -1;
 
-  this->parent->SetSaveable(false);
+  this->geomParent->SetSaveable(false);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Destructor
 RayShape::~RayShape()
 {
-  if (this->line)
-  {
-    delete this->line;
-    this->line = NULL;
-  }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -75,9 +68,9 @@
   if (Simulator::Instance()->GetRenderEngineEnabled() )
   {
     if (!displayRays)
-      this->parent->GetVisualNode()->DetachObjects();
+      this->geomParent->GetVisualNode()->DetachObjects();
     else
-      this->parent->GetVisualNode()->AttachObject(this->line);
+      this->geomParent->GetVisualNode()->AttachObject(this->line);
   }
 }
  
@@ -90,9 +83,9 @@
   this->relativeStartPos = posStart;
   this->relativeEndPos = posEnd;
 
-  this->globalStartPos = this->parent->GetWorldPose().CoordPositionAdd(
+  this->globalStartPos = this->geomParent->GetWorldPose().CoordPositionAdd(
       this->relativeStartPos);
-  this->globalEndPos = this->parent->GetWorldPose().CoordPositionAdd(
+  this->globalEndPos = this->geomParent->GetWorldPose().CoordPositionAdd(
       this->relativeEndPos);
 
   // Compute the direction of the ray
Index: server/physics/ode/ODERayShape.cc
===================================================================
--- server/physics/ode/ODERayShape.cc	(revision 8976)
+++ server/physics/ode/ODERayShape.cc	(working copy)
@@ -40,7 +40,7 @@
 {
   this->SetName("ODE Ray Shape");
 
-  ODEGeom *geom = (ODEGeom*)this->parent;
+  ODEGeom *geom = (ODEGeom*)this->geomParent;
 
   // Create default ray with unit length
   geom->SetGeom( dCreateRay( geom->GetSpaceId(), 1.0 ),  false );
@@ -56,13 +56,13 @@
 // Update the ray geom
 void ODERayShape::Update()
 {
-  ODEGeom *geom = (ODEGeom*)this->parent;
+  ODEGeom *geom = (ODEGeom*)this->geomParent;
 
   Vector3 dir;
 
-  this->globalStartPos = this->parent->GetBody()->GetWorldPose().CoordPositionAdd(
+  this->globalStartPos = this->geomParent->GetBody()->GetWorldPose().CoordPositionAdd(
       this->relativeStartPos);
-  this->globalEndPos = this->parent->GetBody()->GetWorldPose().CoordPositionAdd(
+  this->globalEndPos = this->geomParent->GetBody()->GetWorldPose().CoordPositionAdd(
       this->relativeEndPos);
 
   dir = this->globalEndPos - this->globalStartPos;
@@ -84,7 +84,7 @@
 void ODERayShape::SetPoints(const Vector3 &posStart, const Vector3 &posEnd)
 {
   Vector3 dir;
-  ODEGeom *geom = (ODEGeom*)this->parent;
+  ODEGeom *geom = (ODEGeom*)this->geomParent;
 
   RayShape::SetPoints(posStart, posEnd);
 
Index: server/physics/ode/ODEMultiRayShape.cc
===================================================================
--- server/physics/ode/ODEMultiRayShape.cc	(revision 8976)
+++ server/physics/ode/ODEMultiRayShape.cc	(working copy)
@@ -24,7 +24,7 @@
   dGeomSetCategoryBits((dGeomID) this->raySpaceId, GZ_SENSOR_COLLIDE);
   dGeomSetCollideBits((dGeomID) this->raySpaceId, ~GZ_SENSOR_COLLIDE);
 
-  ODEBody *pBody = (ODEBody*)(this->parent->GetBody());
+  ODEBody *pBody = (ODEBody*)(this->geomParent->GetBody());
   pBody->SetSpaceId( this->raySpaceId );
   ((ODEGeom*)parent)->SetSpaceId(this->raySpaceId);
 }
@@ -143,7 +143,7 @@
 void ODEMultiRayShape::AddRay(const Vector3 &start, const Vector3 &end )
 {
   MultiRayShape::AddRay(start,end);
-  ODEGeom *odeGeom = new ODEGeom(parent->GetBody());
+  ODEGeom *odeGeom = new ODEGeom(this->geomParent->GetBody());
   odeGeom->SetName("ODE Ray Geom");
 
   ODERayShape *ray = new ODERayShape(odeGeom, **this->displayTypeP == "lines" );
Index: server/physics/ode/ODEPlaneShape.hh
===================================================================
--- server/physics/ode/ODEPlaneShape.hh	(revision 8976)
+++ server/physics/ode/ODEPlaneShape.hh	(working copy)
@@ -17,7 +17,7 @@
     public: void CreatePlane()
             {
               PlaneShape::CreatePlane();
-              ODEGeom *odeParent = (ODEGeom*)(this->parent);
+              ODEGeom *odeParent = (ODEGeom*)(this->geomParent);
   
               double altitude = 0;
 
@@ -30,7 +30,7 @@
     public: void SetAltitude(const Vector3 &pos)
             {
               PlaneShape::SetAltitude(pos);
-              ODEGeom *odeParent = (ODEGeom*)(this->parent);
+              ODEGeom *odeParent = (ODEGeom*)(this->geomParent);
 
               dVector4 vec4;
   
Index: server/physics/ode/ODETrimeshShape.cc
===================================================================
--- server/physics/ode/ODETrimeshShape.cc	(revision 8976)
+++ server/physics/ode/ODETrimeshShape.cc	(working copy)
@@ -50,7 +50,7 @@
 /// Update function.
 void ODETrimeshShape::Update()
 {
-  ODEGeom *ogeom = ((ODEGeom*)this->parent);
+  ODEGeom *ogeom = ((ODEGeom*)this->geomParent);
 
   /// FIXME: use below to update trimesh geometry for collision without using above Ogre codes
   // tell the tri-tri collider the current transform of the trimesh --
@@ -91,12 +91,12 @@
 {
   dMass odeMass;
   Mass mass;
-  ODEGeom *pgeom = (ODEGeom*)this->parent;
+  ODEGeom *pgeom = (ODEGeom*)this->geomParent;
   PhysicsEngine *physics = World::Instance()->GetPhysicsEngine();
 
   TrimeshShape::Load(node);
 
-  mass = this->parent->GetMass();
+  mass = this->geomParent->GetMass();
 
   unsigned int i =0;
 
@@ -141,7 +141,7 @@
     dMassSetTrimeshTotal(&odeMass, mass.GetAsDouble(), pgeom->GetGeomId());
 
   physics->ConvertMass(&mass, &odeMass);
-  this->parent->SetMass(mass);
+  this->geomParent->SetMass(mass);
 
   memset(this->matrix_dblbuff,0,32*sizeof(dReal));
   this->last_matrix_index = 0;
Index: server/physics/ode/ODEPhysics.hh
===================================================================
--- server/physics/ode/ODEPhysics.hh	(revision 8976)
+++ server/physics/ode/ODEPhysics.hh	(working copy)
@@ -28,9 +28,13 @@
 #define ODEPHYSICS_HH
 
 #include <ode/ode.h>
+#include <parallel_quickstep/parallel_quickstep.h>
 
 #include "gazebo_config.h"
 
+#include <tbb/spin_mutex.h>
+#include <tbb/concurrent_vector.h>
+
 #include "Param.hh"
 #include "PhysicsEngine.hh"
 #include "Shape.hh"
@@ -42,7 +46,15 @@
 {
   class Entity;
   class XMLConfigNode;
+  class ODEGeom;
 
+  class ContactFeedback
+  {
+    public: Contact contact;
+    public: std::vector<dJointFeedback> feedbacks;
+  };
+
+
 /// \addtogroup gazebo_physics_engine
 /// \{
 
@@ -100,7 +112,7 @@
   /// \brief Initialize the ODE engine
   public: virtual void Init();
 
-  /// \brief Initialize for separate thread
+  /// \brief Init the engine for threads. 
   public: virtual void InitForThread();
 
   /// \brief Update the ODE collision
@@ -122,10 +134,10 @@
   public: virtual Body *CreateBody(Entity *parent);
 
   /// \brief Create a geom
-  public: virtual Geom *CreateGeom(Shape::Type type, Body *parent);
+  public: virtual Geom *CreateGeom(std::string shapeTypename, Body *parent);
  
   /// \brief Create a new joint
-  public: virtual Joint *CreateJoint(Joint::Type type);
+  public: virtual Joint *CreateJoint(std::string jointTypename);
 
   /// \brief Return the space id 
   public: dSpaceID GetSpaceId() const;
@@ -145,6 +157,9 @@
   /// \brief Set the step type
   public: virtual void SetStepType(const std::string type);
 
+  /// \brief Set the gavity vector
+  public: virtual void SetGravity(const gazebo::Vector3 &gravity);
+
   /// \brief access functions to set ODE parameters
   public: void SetWorldCFM(double cfm);
   /// \brief access functions to set ODE parameters
@@ -179,9 +194,14 @@
   /// \brief access functions to set ODE parameters
   public: double GetMaxContacts();
 
+  public: void CreateContact(ODEGeom *geom1, ODEGeom *geom2);
+
   /// \brief Do collision detection
   private: static void CollisionCallback( void *data, dGeomID o1, dGeomID o2);
 
+  /// \brief Collide two geoms
+  public: void Collide(ODEGeom *geom1, ODEGeom *geom2);
+
   /// \brief Top-level world for all bodies
   private: dWorldID worldId;
 
@@ -208,19 +228,15 @@
   private: ParamT<int>    *quickStepItersP;
   private: ParamT<double> *quickStepWP;
 
-  private: class ContactFeedback
-           {
-             public: Contact contact;
-             public: std::vector<dJointFeedback> feedbacks;
-           };
+  private: tbb::concurrent_vector<ContactFeedback> contactFeedbacks;
 
-  private: std::vector<ContactFeedback> contactFeedbacks;
-  private: std::vector<ContactFeedback>::iterator contactFeedbackIter;
-
   private: std::map<std::string, dSpaceID> spaces;
 
-  private: std::vector<dContactGeom> contactGeoms;
+  private: std::vector< std::pair<ODEGeom*, ODEGeom*> > colliders;
+  private: std::vector< std::pair<ODEGeom*, ODEGeom*> > trimeshColliders;
 
+  private: tbb::spin_mutex collideMutex;
+
 #ifdef QUICKSTEP_EXPERIMENTAL
   /// experimental ode stuff
   private: ParamT<int>    *islandThreadsP; // number of thread pool threads for islands
@@ -232,6 +248,7 @@
 
 };
 
+
 /** \}*/
 /// \}
 }
Index: server/physics/ode/CMakeLists.txt
===================================================================
--- server/physics/ode/CMakeLists.txt	(revision 8976)
+++ server/physics/ode/CMakeLists.txt	(working copy)
@@ -1,5 +1,14 @@
 include (${gazebo_cmake_dir}/GazeboUtils.cmake)
 
+include_directories(
+  ${parallel_quickstep_include_dirs_split}
+)
+
+link_directories(
+ ${parallel_quickstep_library_dirs_split} 
+)
+
+
 SET (sources ODEPhysics.cc
              ODEGeom.cc
              ODEBody.cc
@@ -41,6 +50,7 @@
 
 LIST_TO_STRING(MY_ODE_CFLAGS "${ODE_CFLAGS}")
 
-set_target_properties(gazebo_physics_ode PROPERTIES COMPILE_FLAGS "-fPIC ${MY_ODE_CFLAGS}")
-target_link_libraries( gazebo_physics_ode ${ODE_LIBRARIES})
+add_definitions(${parallel_quickstep_cflags})
+set_target_properties( gazebo_physics_ode PROPERTIES COMPILE_FLAGS "-fPIC ${MY_ODE_CFLAGS}" )
+target_link_libraries( gazebo_physics_ode ${ODE_LIBRARIES} ${parallel_quickstep_lflags} )
 install ( TARGETS gazebo_physics_ode DESTINATION ${CMAKE_INSTALL_PREFIX}/lib )
Index: server/physics/ode/ODEGeom.hh
===================================================================
--- server/physics/ode/ODEGeom.hh	(revision 8976)
+++ server/physics/ode/ODEGeom.hh	(working copy)
@@ -65,9 +65,6 @@
     /// \brief Load the geom
     public: virtual void Save(std::string &prefix, std::ostream &stream);
 
-    /// \brief Update function for geoms
-    public: virtual void Update();
-
     /// \brief Set the encapsulated geometry object
     public: void SetGeom(dGeomID geomId, bool placeable);
   
Index: server/physics/ode/ODECylinderShape.hh
===================================================================
--- server/physics/ode/ODECylinderShape.hh	(revision 8976)
+++ server/physics/ode/ODECylinderShape.hh	(working copy)
@@ -16,22 +16,22 @@
             {
               CylinderShape::SetSize(size);
               PhysicsEngine *physics = World::Instance()->GetPhysicsEngine();
-              ODEGeom *oParent = (ODEGeom*)(this->parent);
+              ODEGeom *oParent = (ODEGeom*)(this->geomParent);
 
               dMass odeMass;
               Pose3d rpose;
     
-              Mass mass = this->parent->GetMass();
+              Mass mass = this->geomParent->GetMass();
   
               // Initialize mass matrix
               dMassSetCylinderTotal(&odeMass, mass.GetAsDouble(), 3, 
                                     size.x, size.y);
-              rpose = this->parent->GetRelativePose();
+              rpose = this->geomParent->GetRelativePose();
               dMassTranslate(&odeMass, rpose.pos.x, rpose.pos.y, rpose.pos.z);
  
               physics->ConvertMass(&mass, &odeMass);
   
-              this->parent->SetMass(mass);
+              this->geomParent->SetMass(mass);
 
               oParent->SetGeom( dCreateCylinder( 0, size.x, size.y ), true );
             }
Index: server/physics/ode/ODESphereShape.hh
===================================================================
--- server/physics/ode/ODESphereShape.hh	(revision 8976)
+++ server/physics/ode/ODESphereShape.hh	(working copy)
@@ -16,21 +16,21 @@
             {
               SphereShape::SetSize(radius);
               PhysicsEngine *physics = World::Instance()->GetPhysicsEngine();
-              ODEGeom *oParent = (ODEGeom*)(this->parent);
+              ODEGeom *oParent = (ODEGeom*)(this->geomParent);
 
               dMass odeMass;
               Pose3d rpose;
   
-              Mass mass = this->parent->GetMass();
+              Mass mass = this->geomParent->GetMass();
   
               // Initialize box mass matrix
               dMassSetSphereTotal(&odeMass, mass.GetAsDouble(), radius);
-              rpose = this->parent->GetRelativePose();
+              rpose = this->geomParent->GetRelativePose();
               dMassTranslate(&odeMass, rpose.pos.x, rpose.pos.y, rpose.pos.z);
   
               physics->ConvertMass(&mass, &odeMass);
               
-              this->parent->SetMass(mass);
+              this->geomParent->SetMass(mass);
   
               // Create the sphere geometry
               oParent->SetGeom( dCreateSphere(0, radius), true);
Index: server/physics/ode/ODEPhysics.cc
===================================================================
--- server/physics/ode/ODEPhysics.cc	(revision 8976)
+++ server/physics/ode/ODEPhysics.cc	(working copy)
@@ -24,8 +24,10 @@
  * SVN: $Id$
  */
 
-#include <assert.h>
+#include <tbb/parallel_for.h>
+#include <tbb/blocked_range.h>
 
+
 #include "Timer.hh"
 #include "PhysicsFactory.hh"
 #include "Global.hh"
@@ -60,12 +62,79 @@
 
 GZ_REGISTER_PHYSICS_ENGINE("ode", ODEPhysics);
 
+class ContactUpdate_TBB
+{
+  public: ContactUpdate_TBB(tbb::concurrent_vector<ContactFeedback> *contacts) 
+          : contacts(contacts) {}
+
+  public: void operator() (const tbb::blocked_range<size_t> &r) const
+  {
+    std::vector<dJointFeedback>::iterator jiter;
+
+    for (size_t i=r.begin(); i != r.end(); i++)
+    {
+      ContactFeedback *feedback = &(*this->contacts)[i];
+
+      if (feedback->contact.geom1 == NULL)
+        gzerr(0) << "collision update Geom1 is null\n";
+
+      if (feedback->contact.geom2 == NULL)
+        gzerr(0) << "Collision update Geom2 is null\n";
+
+      feedback->contact.forces.clear();
+
+      // Copy all the joint forces to the contact
+      for (jiter = feedback->feedbacks.begin(); 
+          jiter != feedback->feedbacks.end(); jiter++)
+      {
+        JointFeedback joint;
+        joint.body1Force.Set( (*jiter).f1[0], (*jiter).f1[1], (*jiter).f1[2] );
+        joint.body2Force.Set( (*jiter).f2[0], (*jiter).f2[1], (*jiter).f2[2] );
+
+        joint.body1Torque.Set((*jiter).t1[0], (*jiter).t1[1], (*jiter).t1[2]);
+        joint.body2Torque.Set((*jiter).t2[0], (*jiter).t2[1], (*jiter).t2[2]);
+
+        feedback->contact.forces.push_back(joint);
+      }
+
+      // Add the contact to each geom
+      feedback->contact.geom1->AddContact( feedback->contact );
+      feedback->contact.geom2->AddContact( feedback->contact );
+    }
+  }
+
+  tbb::concurrent_vector<ContactFeedback> *contacts;
+};
+
+class Colliders_TBB
+{
+  public: Colliders_TBB(
+              std::vector< std::pair<ODEGeom*, ODEGeom*> > *colliders, 
+              ODEPhysics*engine) : 
+    colliders(colliders), engine(engine)
+  { 
+    dAllocateODEDataForThread(dAllocateMaskAll);
+  }
+
+  public: void operator() (const tbb::blocked_range<size_t> &r) const
+  {
+    for (size_t i=r.begin(); i != r.end(); i++)
+    {
+      ODEGeom *geom1 = (*this->colliders)[i].first;
+      ODEGeom *geom2 = (*this->colliders)[i].second;
+      this->engine->Collide(geom1, geom2);
+    }
+  }
+
+  private: std::vector< std::pair<ODEGeom*, ODEGeom*> > *colliders;
+  private: ODEPhysics*engine;
+};
+ 
 ////////////////////////////////////////////////////////////////////////////////
 // Constructor
 ODEPhysics::ODEPhysics()
     : PhysicsEngine()
 {
-
   // Collision detection init
   dInitODE2(0);
 
@@ -116,7 +185,6 @@
   this->quickStepWP     = new ParamT<double>("quickStepW", -1.0, 0, true, "replace quickStepW with stepW");
 
   Param::End();
-
 }
 
 
@@ -220,11 +288,10 @@
   dWorldSetAutoDisableAngularThreshold(this->worldId, 0.001);
   dWorldSetAutoDisableSteps(this->worldId, 50);
 
-  this->contactGeoms.resize(this->maxContactsP->GetValue());
   this->contactFeedbacks.resize(this->contactFeedbacksP->GetValue());
 
   // Reset the contact pointer
-  this->contactFeedbackIter = this->contactFeedbacks.begin();
+  //this->contactFeedbackIter = this->contactFeedbacks.begin();
 
   Vector3 g = this->gravityP->GetValue();
   dWorldSetGravity(this->worldId, g.x, g.y, g.z);
@@ -283,7 +350,7 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// Initialize for separate thread
+// Init the engine for threads
 void ODEPhysics::InitForThread()
 {
   dAllocateODEDataForThread(dAllocateMaskAll);
@@ -293,138 +360,41 @@
 // Update the ODE collisions, create joints
 void ODEPhysics::UpdateCollision()
 {
-  std::vector<ContactFeedback>::iterator iter;
-  std::vector<dJointFeedback>::iterator jiter;
+  this->colliders.clear();
+  this->trimeshColliders.clear();
 
-  /*ODEBody *leftBody = (ODEBody*)World::Instance()->GetEntityByName("pioneer::left_wheel");
-  ODEBody *rightBody = (ODEBody*)World::Instance()->GetEntityByName("pioneer::right_wheel");
-  ODEBody *castorBody = (ODEBody*)World::Instance()->GetEntityByName("pioneer::castor_body");
-  ODEBody *planeBody = (ODEBody*)World::Instance()->GetEntityByName("plane1_model::plane1_body");
+  // Do collision detection; this will add contacts to the contact group
+  //this->LockMutex(); 
+  dSpaceCollide( this->spaceId, this, CollisionCallback );
+  //this->UnlockMutex(); 
 
-  if (leftBody && rightBody && planeBody && castorBody)
-  {
-    ODEGeom *leftGeom = (ODEGeom*)leftBody->GetGeom("left_wheel_geom");
-    ODEGeom *rightGeom = (ODEGeom*)rightBody->GetGeom("right_wheel_geom");
-    ODEGeom *castorGeom = (ODEGeom*)castorBody->GetGeom("castor_geom");
-    ODEGeom *planeGeom = (ODEGeom*)planeBody->GetGeom("plane1_geom");
+  this->contactFeedbacks.clear();
 
-    dContactGeom geomLeft, geomRight, geomCastor;
-    geomLeft.pos[0] = leftBody->GetWorldPose().pos.x;
-    geomLeft.pos[1] = leftBody->GetWorldPose().pos.y;
-    geomLeft.pos[2] = 0;
-    geomLeft.normal[0] = 0;
-    geomLeft.normal[1] = 0;
-    geomLeft.normal[2] = 1;
-    geomLeft.depth = 0;
-    geomLeft.g1 = leftGeom->GetGeomId();
-    geomLeft.g2 = planeGeom->GetGeomId();
+  tbb::parallel_for( tbb::blocked_range<size_t>(0, this->colliders.size(), 10),
+      Colliders_TBB(&this->colliders, this) );
 
-    geomRight.pos[0] = rightBody->GetWorldPose().pos.x;
-    geomRight.pos[1] = rightBody->GetWorldPose().pos.y;
-    geomRight.pos[2] = 0;
-    geomRight.normal[0] = 0;
-    geomRight.normal[1] = 0;
-    geomRight.normal[2] = 1;
-    geomRight.depth = 0;
-    geomRight.g1 = rightGeom->GetGeomId();
-    geomRight.g2 = planeGeom->GetGeomId();
-
-    geomCastor.pos[0] = castorBody->GetWorldPose().pos.x;
-    geomCastor.pos[1] = castorBody->GetWorldPose().pos.y;
-    geomCastor.pos[2] = 0;
-    geomCastor.normal[0] = 0;
-    geomCastor.normal[1] = 0;
-    geomCastor.normal[2] = 1;
-    geomCastor.depth =0;
-    geomCastor.g1 = castorGeom->GetGeomId();
-    geomCastor.g2 = planeGeom->GetGeomId();
-
-    dContact contact;
-    contact.geom = geomLeft;
-    contact.surface.mode = dContactSoftERP | dContactSoftCFM; 
-    contact.surface.mu = 0; 
-    contact.surface.mu2 = 0;
-    contact.surface.slip1 = 0.1;
-    contact.surface.slip2 = 0.1;
-    contact.surface.bounce =  0;
-    dJointID c = dJointCreateContact(this->worldId, this->contactGroup, &contact);
-    dJointAttach (c, leftBody->GetODEId(), planeBody->GetODEId());
-
-    dContact contact2;
-    contact2.geom = geomRight;
-    contact2.surface.mode = dContactSoftERP | dContactSoftCFM; 
-    contact2.surface.mu = 0; 
-    contact2.surface.mu2 = 0;
-    contact2.surface.slip1 = 0.1;
-    contact2.surface.slip2 = 0.1;
-    contact2.surface.bounce =  0;
-    dJointID c2 = dJointCreateContact(this->worldId, this->contactGroup, &contact2);
-    dJointAttach (c2, rightBody->GetODEId(), planeBody->GetODEId());
-
-    dContact contact3;
-    contact3.geom = geomCastor;
-    contact3.surface.mode = dContactSoftERP | dContactSoftCFM; 
-    contact3.surface.mu = 0; 
-    contact3.surface.mu2 = 0;
-    contact3.surface.slip1 = 0.1;
-    contact3.surface.slip2 = 0.1;
-    contact3.surface.bounce =  0;
-    dJointID c3 = dJointCreateContact(this->worldId, this->contactGroup, &contact3);
-    dJointAttach (c3, castorBody->GetODEId(), planeBody->GetODEId());
-  }
-*/
-
-
-  // Do collision detection; this will add contacts to the contact group
-  this->LockMutex(); 
+  // Trimesh collision must happen in this thread sequentially
+  for (int i=0; i<this->trimeshColliders.size(); i++)
   {
     DIAGNOSTICTIMER(timer("ODEPhysics Collision dSpaceCollide",6));
-    dSpaceCollide( this->spaceId, this, CollisionCallback );
+    //dSpaceCollide( this->spaceId, this, CollisionCallback );
+
+    ODEGeom *geom1 = this->trimeshColliders[i].first;
+    ODEGeom *geom2 = this->trimeshColliders[i].second;
+    this->Collide(geom1, geom2);
   }
-  this->UnlockMutex(); 
 
   // Process all the contacts, get the feedback info, and call the geom
   // callbacks
-  for (iter = this->contactFeedbacks.begin(); 
-       iter != this->contactFeedbackIter; iter++)
-  {
-    if ((*iter).contact.geom1 == NULL)
-      gzerr(0) << "collision update Geom1 is null\n";
-
-    if ((*iter).contact.geom2 == NULL)
-      gzerr(0) << "Collision update Geom2 is null\n";
-
-    (*iter).contact.forces.clear();
-
-    // Copy all the joint forces to the contact
-    for (jiter = (*iter).feedbacks.begin(); jiter != (*iter).feedbacks.end();
-        jiter++)
-    {
-      JointFeedback feedback;
-      feedback.body1Force.Set( (*jiter).f1[0], (*jiter).f1[1], (*jiter).f1[2] );
-      feedback.body2Force.Set( (*jiter).f2[0], (*jiter).f2[1], (*jiter).f2[2] );
-
-      feedback.body1Torque.Set((*jiter).t1[0], (*jiter).t1[1], (*jiter).t1[2]);
-      feedback.body2Torque.Set((*jiter).t2[0], (*jiter).t2[1], (*jiter).t2[2]);
-
-      (*iter).contact.forces.push_back(feedback);
-    }
-
-    // Add the contact to each geom
-    (*iter).contact.geom1->AddContact( (*iter).contact );
-    (*iter).contact.geom2->AddContact( (*iter).contact );
-  }
-
-  // Reset the contact pointer
-  this->contactFeedbackIter = this->contactFeedbacks.begin();
+  tbb::parallel_for( tbb::blocked_range<size_t>(0, 
+        this->contactFeedbacks.size(), 10), 
+        ContactUpdate_TBB(&this->contactFeedbacks) );
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Update the ODE engine
 void ODEPhysics::UpdatePhysics()
 {
-  PhysicsEngine::UpdatePhysics();
-
   {
     DIAGNOSTICTIMER(timer("ODEPhysics: UpdateCollision",6));
     this->UpdateCollision();
@@ -432,7 +402,7 @@
 
   {
     DIAGNOSTICTIMER(timer("ODEPhysics: LockMutex",6));
-    this->LockMutex(); 
+    //this->LockMutex(); 
   }
 
   // Update the dynamical model
@@ -445,6 +415,8 @@
       dWorldQuickStep(this->worldId, (**this->stepTimeP).Double());
     else if (**this->stepTypeP == "world")
       dWorldStep( this->worldId, (**this->stepTimeP).Double() );
+    else if (**this->stepTypeP == "parallel_quick")
+      dWorldParallelQuickStep(this->worldId, (**this->stepTimeP).Double());  
     else
       gzthrow(std::string("Invalid step type[") + **this->stepTypeP);
 
@@ -452,7 +424,7 @@
     dJointGroupEmpty( this->contactGroup );
   }
 
-  this->UnlockMutex(); 
+  //this->UnlockMutex(); 
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -495,40 +467,29 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 // Create a new geom
-Geom *ODEPhysics::CreateGeom(Shape::Type type, Body *body)
+Geom *ODEPhysics::CreateGeom(std::string type, Body *body)
 {
   ODEGeom *geom = new ODEGeom(body);
   Shape *shape = NULL;
 
-  switch (type)
-  {
-    case Shape::SPHERE:
-      shape = new ODESphereShape(geom);
-      break;
-    case Shape::PLANE:
-      shape = new ODEPlaneShape(geom);
-      break;
-    case Shape::BOX:
-      shape = new ODEBoxShape(geom);
-      break;
-    case Shape::CYLINDER:
-      shape = new ODECylinderShape(geom);
-      break;
-    case Shape::MULTIRAY:
-      shape = new ODEMultiRayShape(geom);
-      break;
-    case Shape::TRIMESH:
-      shape = new ODETrimeshShape(geom);
-      break;
-    case Shape::HEIGHTMAP:
-      shape = new ODEHeightmapShape(geom);
-      break;
-    case Shape::MAP:
-      shape = new MapShape(geom);
-      break;
-    default:
-      gzerr(0) << "Unable to create geom of type["<<type<<"]\n";
-  }
+  if ( type == "sphere")
+    shape = new ODESphereShape(geom);
+  else if ( type == "plane")
+    shape = new ODEPlaneShape(geom);
+  else if ( type == "box")
+    shape = new ODEBoxShape(geom);
+  else if ( type == "cylinder")
+    shape = new ODECylinderShape(geom);
+  else if ( type == "multiray")
+    shape = new ODEMultiRayShape(geom);
+  else if ( type == "trimesh")
+    shape = new ODETrimeshShape(geom);
+  else if ( type == "heightmap")
+    shape = new ODEHeightmapShape(geom);
+  else if ( type == "map")
+    shape = new MapShape(geom);
+  else
+    gzerr(0) << "Unable to create geom of type["<<type<<"]\n";
 
   return geom;
 }
@@ -606,9 +567,6 @@
 void ODEPhysics::SetMaxContacts(double max_contacts)
 {
   this->maxContactsP->SetValue(max_contacts);
-  // @todo: FIXME: resizes contactGeoms, but can we do this on the fly?
-  //               this might need to be done on a new time step
-  this->contactGeoms.resize(this->maxContactsP->GetValue());
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -681,23 +639,20 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 // Create a new joint
-Joint *ODEPhysics::CreateJoint(Joint::Type type)
+Joint *ODEPhysics::CreateJoint(std::string type)
 {
-  switch (type)
-  {
-    case Joint::SLIDER:
-      return new ODESliderJoint(this->worldId);
-    case Joint::HINGE:
-      return new ODEHingeJoint(this->worldId);
-    case Joint::HINGE2:
-      return new ODEHinge2Joint(this->worldId);
-    case Joint::BALL:
-      return new ODEBallJoint(this->worldId);
-    case Joint::UNIVERSAL:
-      return new ODEUniversalJoint(this->worldId);
-    default:
-      return NULL;
-  }
+  if (type == "slider")
+    return new ODESliderJoint(this->worldId);
+  if (type == "hinge")
+    return new ODEHingeJoint(this->worldId);
+  if (type == "hinge2")
+    return new ODEHinge2Joint(this->worldId);
+  if (type == "ball")
+    return new ODEBallJoint(this->worldId);
+  if (type == "universal")
+    return new ODEUniversalJoint(this->worldId);
+  else
+    return NULL;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -730,6 +685,14 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+/// Set the gavity vector
+void ODEPhysics::SetGravity(const gazebo::Vector3 &gravity)
+{
+  this->gravityP->SetValue(gravity);
+  dWorldSetGravity(this->worldId, gravity.x, gravity.y, gravity.z);
+}
+
+////////////////////////////////////////////////////////////////////////////////
 // Handle a collision
 void ODEPhysics::CollisionCallback( void *data, dGeomID o1, dGeomID o2)
 {
@@ -779,105 +742,141 @@
     else
       geom2 = (ODEGeom*) dGeomGetData(o2);
 
+    if (geom1->GetShapeType() == TRIMESH_SHAPE ||
+        geom2->GetShapeType() == TRIMESH_SHAPE )
+      self->trimeshColliders.push_back( std::make_pair(geom1, geom2) );
+    else
+      self->colliders.push_back( std::make_pair(geom1, geom2) );
+    return;
+  }
+}
 
-    int maxContacts = self->maxContactsP->GetValue();
-    int numContacts = 100;
-    int i;
-    int numc = 0;
-    dContact contact;
 
-    // for now, only use maxContacts if both geometries are trimeshes
-    // other types of geometries do not need too many contacts
-    if (geom1->GetShapeType() == Shape::TRIMESH && 
-        geom2->GetShapeType()==Shape::TRIMESH)
-    {
-      numContacts = maxContacts;
-    }
+////////////////////////////////////////////////////////////////////////////////
+// Collide two geoms
+void ODEPhysics::Collide(ODEGeom *geom1, ODEGeom *geom2)
+{
+  int numContacts = 100;
+  int j;
+  int numc = 0;
+  dContact contact;
 
-    numc = dCollide(o1,o2,numContacts, &self->contactGeoms[0], 
-                    sizeof(self->contactGeoms[0]));
+  dContactGeom contactGeoms[**this->maxContactsP];
 
-    if (numc != 0)
+  // for now, only use maxContacts if both geometries are trimeshes
+  // other types of geometries do not need too many contacts
+  if (geom1->GetShapeType() == TRIMESH_SHAPE && 
+      geom2->GetShapeType() == TRIMESH_SHAPE)
+  {
+    numContacts = **this->maxContactsP;
+  }
+
+  {
+    tbb::spin_mutex::scoped_lock lock(this->collideMutex);
+    numc = dCollide(geom1->GetGeomId(), geom2->GetGeomId(), 
+        numContacts, contactGeoms, sizeof(contactGeoms[0]) );
+  }
+
+  if (numc != 0)
+  {
+    ContactFeedback contactFeedback;
+
+    contactFeedback.contact.Reset();
+    contactFeedback.contact.geom1 = geom1;
+    contactFeedback.contact.geom2 = geom2;
+    contactFeedback.feedbacks.resize(numc);
+
+    double h, kp, kd;
+    for (j=0; j<numc; j++)
     {
-      (*self->contactFeedbackIter).contact.Reset();
-      (*self->contactFeedbackIter).contact.geom1 = geom1;
-      (*self->contactFeedbackIter).contact.geom2 = geom2;
-      (*self->contactFeedbackIter).feedbacks.resize(numc);
+      // skip negative depth contacts
+      if(contactGeoms[j].depth < 0)
+        continue;
 
-      double h, kp, kd;
-      for (i=0; i<numc; i++)
-      {
-        // skip negative depth contacts
-        if(self->contactGeoms[i].depth < 0)
-          continue;
+      contact.geom = contactGeoms[j];
+      //contact.geom = self->contactGeoms[i];
 
-        contact.geom = self->contactGeoms[i];
-        contact.surface.mode = dContactSoftERP | dContactSoftCFM | dContactApprox1;
+      contact.surface.mode = dContactSoftERP | dContactSoftCFM | dContactApprox1;
 
-        // Compute the CFM and ERP by assuming the two bodies form a
-        // spring-damper system.
-        h = (**self->stepTimeP).Double();
-        kp = 1.0 / (1.0 / geom1->surface->kp + 1.0 / geom2->surface->kp);
-        kd = geom1->surface->kd + geom2->surface->kd;
-        contact.surface.soft_erp = h * kp / (h * kp + kd);
-        contact.surface.soft_cfm = 1.0 / (h * kp + kd);
+      //contact.surface.mode = dContactSlip1 | dContactSlip2 | 
+      //  dContactSoftERP | dContactSoftCFM |  
+      //  dContactBounce | dContactMu2 | dContactApprox1;
 
-        if (geom1->surface->enableFriction && geom2->surface->enableFriction)
-        {
-          contact.surface.mu = std::min(geom1->surface->mu1, 
-              geom2->surface->mu1);
-          contact.surface.mu2 = std::min(geom1->surface->mu2, 
-              geom2->surface->mu2);
-          contact.surface.slip1 = std::min(geom1->surface->slip1, 
-              geom2->surface->slip1);
-          contact.surface.slip2 = std::min(geom1->surface->slip2, 
-              geom2->surface->slip2);
-        }
-        else
-        {
-          contact.surface.mu = 0; 
-          contact.surface.mu2 = 0;
-          contact.surface.slip1 = 0.1;
-          contact.surface.slip2 = 0.1;
-        }
+      //contact.surface.mode = dContactSoftERP | dContactSoftCFM | dContactApprox1 | dContactSlip1 | dContactSlip2;
+      // with dContactSoftERP | dContactSoftCFM the test_pr2_collision overshoots the cup
 
-        contact.surface.bounce = std::min(geom1->surface->bounce, 
-                                     geom2->surface->bounce);
-        contact.surface.bounce_vel = std::min(geom1->surface->bounceVel, 
-                                         geom2->surface->bounceVel);
-        dJointID c = dJointCreateContact (self->worldId,
-                                          self->contactGroup, &contact);
+      // Compute the CFM and ERP by assuming the two bodies form a
+      // spring-damper system.
+      h = (**this->stepTimeP).Double();
+      kp = 1.0 / (1.0 / geom1->surface->kp + 1.0 / geom2->surface->kp);
+      kd = geom1->surface->kd + geom2->surface->kd;
+      contact.surface.soft_erp = h * kp / (h * kp + kd);
+      contact.surface.soft_cfm = 1.0 / (h * kp + kd);
 
-        Vector3 contactPos(contact.geom.pos[0], contact.geom.pos[1], 
-                           contact.geom.pos[2]);
-        Vector3 contactNorm(contact.geom.normal[0], contact.geom.normal[1], 
-                            contact.geom.normal[2]);
+      if (geom1->surface->enableFriction && geom2->surface->enableFriction)
+      {
+        contact.surface.mu = std::min(geom1->surface->mu1, 
+            geom2->surface->mu1);
+        contact.surface.mu2 = std::min(geom1->surface->mu2, 
+            geom2->surface->mu2);
+        contact.surface.slip1 = std::min(geom1->surface->slip1, 
+            geom2->surface->slip1);
+        contact.surface.slip2 = std::min(geom1->surface->slip2, 
+            geom2->surface->slip2);
+      }
+      else
+      {
+        contact.surface.mu = 0; 
+        contact.surface.mu2 = 0;
+        contact.surface.slip1 = 0.1;
+        contact.surface.slip2 = 0.1;
+      }
 
-        self->AddContactVisual(contactPos, contactNorm);
+      contact.surface.bounce = std::min(geom1->surface->bounce, 
+          geom2->surface->bounce);
+      contact.surface.bounce_vel = std::min(geom1->surface->bounceVel, 
+          geom2->surface->bounceVel);
 
-        // Store the contact info 
-        if (geom1->GetContactsEnabled() ||
-            geom2->GetContactsEnabled())
-        {
-          (*self->contactFeedbackIter).contact.depths.push_back(
-              contact.geom.depth);
-          (*self->contactFeedbackIter).contact.positions.push_back(contactPos);
-          (*self->contactFeedbackIter).contact.normals.push_back(contactNorm);
-          (*self->contactFeedbackIter).contact.time = 
-            Simulator::Instance()->GetSimTime();
-          dJointSetFeedback(c, &((*self->contactFeedbackIter).feedbacks[i]));
-        }
+      dJointID c;
 
-        dJointAttach (c, b1, b2);
+      Vector3 contactPos;
+      Vector3 contactNorm;
+
+      {
+        tbb::spin_mutex::scoped_lock lock(this->collideMutex);
+        c = dJointCreateContact (this->worldId, this->contactGroup, &contact);
+
+        contactPos.Set(contact.geom.pos[0], contact.geom.pos[1], 
+            contact.geom.pos[2]);
+        contactNorm.Set(contact.geom.normal[0], contact.geom.normal[1], 
+            contact.geom.normal[2]);
+
+        this->AddContactVisual( contactPos, contactNorm );
       }
 
-      if (geom1->GetContactsEnabled() || geom2->GetContactsEnabled())
+
+      // Store the contact info 
+      if (geom1->GetContactsEnabled() ||
+          geom2->GetContactsEnabled())
       {
-        self->contactFeedbackIter++;
-        if (self->contactFeedbackIter == self->contactFeedbacks.end())
-          self->contactFeedbacks.resize( self->contactFeedbacks.size() + 100);
+        contactFeedback.contact.depths.push_back(
+            contact.geom.depth);
+        contactFeedback.contact.positions.push_back(contactPos);
+        contactFeedback.contact.normals.push_back(contactNorm);
+        contactFeedback.contact.time = 
+          Simulator::Instance()->GetSimTime();
+        dJointSetFeedback(c, &(contactFeedback.feedbacks[j]));
       }
+
+      dBodyID b1 = dGeomGetBody(geom1->GetGeomId());
+      dBodyID b2 = dGeomGetBody(geom2->GetGeomId());
+
+      dJointAttach (c, b1, b2);
     }
+
+    if (geom1->GetContactsEnabled() || geom2->GetContactsEnabled())
+    {
+      this->contactFeedbacks.push_back( contactFeedback );
+    }
   }
 }
-
Index: server/physics/ode/ODEBoxShape.hh
===================================================================
--- server/physics/ode/ODEBoxShape.hh	(revision 8976)
+++ server/physics/ode/ODEBoxShape.hh	(working copy)
@@ -16,23 +16,23 @@
             {
               BoxShape::SetSize(size);
               PhysicsEngine *physics = World::Instance()->GetPhysicsEngine();
-              ODEGeom *oParent = (ODEGeom*)(this->parent);
+              ODEGeom *oParent = (ODEGeom*)(this->geomParent);
 
               Pose3d rpose;
 
               dMass odeMass;
 
-              Mass mass = this->parent->GetMass();
+              Mass mass = this->geomParent->GetMass();
   
               // Initialize box mass matrix
               dMassSetBoxTotal(&odeMass, mass.GetAsDouble(), 
                                size.x, size.y, size.z);
-              rpose = this->parent->GetRelativePose();
+              rpose = this->geomParent->GetRelativePose();
               dMassTranslate(&odeMass, rpose.pos.x, rpose.pos.y, rpose.pos.z);
  
               physics->ConvertMass(&mass, &odeMass);
 
-              this->parent->SetMass(mass);
+              this->geomParent->SetMass(mass);
   
               // Create a box geometry with box mass matrix
               oParent->SetGeom( dCreateBox( 0, size.x, size.y, size.z), true );
Index: server/physics/ode/ODEHeightmapShape.cc
===================================================================
--- server/physics/ode/ODEHeightmapShape.cc	(revision 8976)
+++ server/physics/ode/ODEHeightmapShape.cc	(working copy)
@@ -84,7 +84,7 @@
 void ODEHeightmapShape::Load(XMLConfigNode *node)
 {
   HeightmapShape::Load(node);
-  ODEGeom *oParent = (ODEGeom*)(this->parent);
+  ODEGeom *oParent = (ODEGeom*)(this->geomParent);
 
   // sampling size along image width and height
   this->odeVertSize = this->img.GetWidth() * 4;
Index: server/physics/ode/ODEGeom.cc
===================================================================
--- server/physics/ode/ODEGeom.cc	(revision 8976)
+++ server/physics/ode/ODEGeom.cc	(working copy)
@@ -21,7 +21,6 @@
 /* Desc: ODEGeom class
  * Author: Nate Koenig
  * Date: 13 Feb 2006
- * SVN: $Id:$
  */
 
 #include <sstream>
@@ -138,20 +137,13 @@
 // Save the body based on our XMLConfig node
 void ODEGeom::Save(std::string &prefix, std::ostream &stream)
 {
-  if (this->GetShapeType() == Shape::RAY)
+  if (this->GetShapeType() == RAY_SHAPE)
     return;
 
   Geom::Save(prefix, stream);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// Update
-void ODEGeom::Update()
-{
-  Geom::Update();
-}
-
-////////////////////////////////////////////////////////////////////////////////
 // Set the encapsulated geometry object
 void ODEGeom::SetGeom(dGeomID geomId, bool placeable)
 {
Index: server/physics/ode/ODEBody.cc
===================================================================
--- server/physics/ode/ODEBody.cc	(revision 8976)
+++ server/physics/ode/ODEBody.cc	(working copy)
@@ -110,14 +110,11 @@
   pose.pos.Set(p[0], p[1], p[2]);
   pose.rot.Set(r[0], r[1], r[2], r[3] );
 
-  Pose3d pp = self->comEntity->GetRelativePose().GetInverse() + pose;
+  self->newPose = self->comEntity->GetRelativePose().GetInverse() + pose;
+  self->newPose.Correct();
+  self->poseDirty = true;
 
-  pp.Correct();
-
-  if ( isnan(pp.pos.x) || isnan(pp.pos.y) || isnan(pp.pos.z) )
-    printf("NAN!!!\n");
-
-  self->SetWorldPose(pp, false);
+  //self->SetWorldPose(pp, false);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -389,11 +386,9 @@
 /// \brief Set the force applied to the body
 void ODEBody::SetForce(const Vector3 &force)
 {
-  if (this->bodyId)
+  if (this->bodyId && this->physicsEngine->Locked())
   {
-    this->physicsEngine->LockMutex();
     dBodyAddForce(this->bodyId, force.x, force.y, force.z);
-    this->physicsEngine->UnlockMutex();
   }
 }
 
@@ -424,12 +419,10 @@
 /// \brief Set the torque applied to the body
 void ODEBody::SetTorque(const Vector3 &torque)
 {
-  if (this->bodyId)
+  if (this->bodyId && this->physicsEngine->Locked())
   {
     this->SetEnabled(true);
-    this->physicsEngine->LockMutex();
     dBodyAddRelTorque(this->bodyId, torque.x, torque.y, torque.z);
-    this->physicsEngine->UnlockMutex();
   }
 }
 
Index: server/physics/Joint.cc
===================================================================
--- server/physics/Joint.cc	(revision 8976)
+++ server/physics/Joint.cc	(working copy)
@@ -24,10 +24,13 @@
  * CVS: $Id$
  */
 
+#include "Events.hh"
 #include "PhysicsEngine.hh"
 #include "OgreVisual.hh"
 #include "OgreCreator.hh"
 #include "OgreDynamicLines.hh"
+#include "GazeboError.hh"
+#include "GazeboMessage.hh"
 #include "Global.hh"
 #include "Body.hh"
 #include "Model.hh"
@@ -36,13 +39,12 @@
 
 using namespace gazebo;
 
-std::string Joint::TypeNames[Joint::TYPE_COUNT] = {"slider", "hinge", "hinge2", "ball", "universal"};
-
 //////////////////////////////////////////////////////////////////////////////
 // Constructor
 Joint::Joint()
-  : Common()
+  : Common(NULL)
 {
+  this->AddType(JOINT);
   this->visual = NULL;
   this->model = NULL;
 
@@ -64,8 +66,7 @@
 
   this->physics = World::Instance()->GetPhysicsEngine();
 
-  World::Instance()->ConnectShowJointsSignal( 
-      boost::bind(&Joint::ShowJoints, this, _1) );
+  Events::ConnectShowJointsSignal(boost::bind(&Joint::ToggleShowJoints, this) );
 }
 
 
@@ -73,8 +74,7 @@
 // Desctructor
 Joint::~Joint()
 {
-  World::Instance()->DisconnectShowJointsSignal( 
-      boost::bind(&Joint::ShowJoints, this, _1) );
+  Events::DisconnectShowJointsSignal(boost::bind(&Joint::ToggleShowJoints, this));
 
   if (this->visual)
   {
@@ -94,15 +94,7 @@
   delete this->fudgeFactorP;
 }
 
-
 //////////////////////////////////////////////////////////////////////////////
-// Get the type of the joint
-Joint::Type Joint::GetType() const
-{
-  return this->type;
-}
-
-//////////////////////////////////////////////////////////////////////////////
 // Load a joint
 void Joint::Load(XMLConfigNode *node)
 {
@@ -133,9 +125,9 @@
   else
   {
     visname << this->GetName() << "_VISUAL";
-    this->body1 = dynamic_cast<Body*>(World::Instance()->GetEntityByName( **(this->body1NameP) ));
-    this->body2 = dynamic_cast<Body*>(World::Instance()->GetEntityByName( **(this->body2NameP) ));
-    this->anchorBody = dynamic_cast<Body*>(World::Instance()->GetEntityByName( **(this->anchorBodyNameP) ));
+    this->body1 = dynamic_cast<Body*>(Common::GetByName( **(this->body1NameP) ));
+    this->body2 = dynamic_cast<Body*>(Common::GetByName( **(this->body2NameP) ));
+    this->anchorBody = dynamic_cast<Body*>(Common::GetByName( **(this->anchorBodyNameP) ));
   }
 
   if (!this->body1 && this->body1NameP->GetValue() != std::string("world"))
@@ -161,15 +153,12 @@
     this->visual->SetMaterial("Gazebo/JointAnchor");
     this->visual->SetVisible(false);
 
-    this->line1 = OgreCreator::Instance()->CreateDynamicLine(OgreDynamicRenderable::OT_LINE_LIST);
-    this->line2 = OgreCreator::Instance()->CreateDynamicLine(OgreDynamicRenderable::OT_LINE_LIST);
+    this->line1 = this->visual->AddDynamicLine(OgreDynamicRenderable::OT_LINE_LIST);
+    this->line2 = this->visual->AddDynamicLine(OgreDynamicRenderable::OT_LINE_LIST);
 
-    this->line1->setMaterial("Gazebo/BlueEmissive");
-    this->line2->setMaterial("Gazebo/BlueEmissive");
+    this->line1->setMaterial("Gazebo/BlueGlow");
+    this->line2->setMaterial("Gazebo/BlueGlow");
 
-    this->visual->AttachObject(this->line1);
-    this->visual->AttachObject(this->line2);
-
     this->line1->AddPoint(Vector3(0,0,0));
     this->line1->AddPoint(Vector3(0,0,0));
     this->line2->AddPoint(Vector3(0,0,0));
@@ -187,30 +176,8 @@
 /// Save a joint to a stream in XML format
 void Joint::Save(std::string &prefix, std::ostream &stream)
 {
-  std::string typeName;
+  std::string typeName = EntityTypename[ (int)this->GetLeafType() ];
 
-  switch (this->type)
-  {
-    case SLIDER: 
-      typeName="slider"; 
-      break;
-    case HINGE: 
-      typeName = "hinge"; 
-      break;
-    case HINGE2: 
-      typeName = "hinge2"; 
-      break;
-    case BALL: 
-      typeName = "ball"; 
-      break;
-    case UNIVERSAL: 
-      typeName = "universal"; 
-      break;
-    default:
-      gzthrow("Unable to save joint of type[" << this->type << "]\n");
-      break;
-  }
-
   stream << prefix << "<joint:" << typeName << " name=\"" << **(this->nameP) << "\">\n";
   stream << prefix << "  " << *(this->body1NameP) << "\n";
   stream << prefix << "  " << *(this->body2NameP) << "\n";
@@ -253,6 +220,14 @@
 }
 
 //////////////////////////////////////////////////////////////////////////////
+// Toggle joint visibility
+void Joint::ToggleShowJoints()
+{
+  if (this->visual)
+    this->visual->ToggleVisible();
+}
+
+//////////////////////////////////////////////////////////////////////////////
 // Set the joint to show visuals
 void Joint::ShowJoints(bool s)
 {
Index: server/physics/UniversalJoint.hh
===================================================================
--- server/physics/UniversalJoint.hh	(revision 8976)
+++ server/physics/UniversalJoint.hh	(working copy)
@@ -97,7 +97,7 @@
   /// \brief Constructor
   public: UniversalJoint() : T()
           {
-            this->type = Joint::UNIVERSAL;
+            this->AddType(UNIVERSAL_JOINT);
 
             Param::Begin(&this->parameters);
             this->axis1P = new ParamT<Vector3>("axis1",Vector3(0,0,1),0);
Index: server/physics/MultiRayShape.cc
===================================================================
--- server/physics/MultiRayShape.cc	(revision 8976)
+++ server/physics/MultiRayShape.cc	(working copy)
@@ -7,23 +7,17 @@
 /// Constructor
 MultiRayShape::MultiRayShape(Geom *parent) : Shape(parent)
 {
-  this->type = Shape::MULTIRAY;
+  this->AddType(MULTIRAY_SHAPE);
 
-  this->rayFan = OgreCreator::Instance()->CreateDynamicLine(
+  this->rayFan = this->geomParent->GetVisualNode()->AddDynamicLine(
       OgreDynamicRenderable::OT_TRIANGLE_FAN);
 
-  this->rayFanOutline = OgreCreator::Instance()->CreateDynamicLine(
+  this->rayFanOutline = this->geomParent->GetVisualNode()->AddDynamicLine(
       OgreDynamicRenderable::OT_LINE_STRIP);
 
-  if (this->rayFan && this->rayFanOutline)
-  {
-    this->parent->GetVisualNode()->AttachObject(this->rayFan);
-    this->parent->GetVisualNode()->AttachObject(this->rayFanOutline);
+  this->rayFan->setMaterial("Gazebo/BlueLaser");
+  this->rayFanOutline->setMaterial("Gazebo/BlueGlow");
 
-    this->rayFan->setMaterial("Gazebo/BlueLaser");
-    this->rayFanOutline->setMaterial("Gazebo/BlueEmissive");
-  }
-
   Param::Begin(&this->parameters);
   this->rayCountP = new ParamT<int>("rayCount",0,1);
   this->rangeCountP = new ParamT<int>("rangeCount",0,1);
@@ -47,12 +41,6 @@
 /// Destructor
 MultiRayShape::~MultiRayShape()
 {
-  if (this->rayFan)
-    delete this->rayFan;
-
-  if (this->rayFanOutline)
-    delete this->rayFanOutline;
-
   std::vector< RayShape* >::iterator iter;
 
   for (iter=this->rays.begin(); iter!=this->rays.end(); iter++)
Index: server/Factory.cc
===================================================================
--- server/Factory.cc	(revision 8976)
+++ server/Factory.cc	(working copy)
@@ -25,6 +25,7 @@
  * SVN info: $Id: Factory.cc 7748 2009-05-30 09:46:23Z robotos $
  */
 
+#include "Events.hh"
 #include "Global.hh"
 #include "XMLConfig.hh"
 #include "Model.hh"
@@ -112,7 +113,7 @@
   if (strcmp((const char*)this->factoryIface->data->deleteEntity,"")!=0)
   {
     const std::string e = (const char*)this->factoryIface->data->deleteEntity;
-    World::Instance()->DeleteEntity(e);
+    Events::deleteEntitySignal(e);
 
     strcpy((char*)this->factoryIface->data->deleteEntity,"");
   }
Index: server/Global.hh
===================================================================
--- server/Global.hh	(revision 8976)
+++ server/Global.hh	(working copy)
@@ -27,16 +27,8 @@
 #ifndef GZGLOBAL_HH
 #define GZGLOBAL_HH
 
-/////////////////////////////////////////////////////////////////////////////
-// Includes
-/////////////////////////////////////////////////////////////////////////////
+#include <string>
 
-#include <math.h>
-
-#include "GazeboError.hh"
-#include "GazeboMessage.hh"
-
-
 /////////////////////////////////////////////////////////////////////////////
 // Defines
 /////////////////////////////////////////////////////////////////////////////
@@ -65,6 +57,17 @@
 // Macros
 /////////////////////////////////////////////////////////////////////////////
 
+#if defined(__GNUC__)
+#define GAZEBO_DEPRECATED __attribute__((deprecated))
+#define GAZEBO_FORCEINLINE __attribute__((always_inline))
+#elif defined(MSVC)
+#define GAZEBO_DEPRECATED
+#define GAZEBO_FORCEINLINE __forceinline
+#else
+#define GAZEBO_DEPRECATED
+#define GAZEBO_FORCEINLINE
+#endif
+
 // Convert radians to degrees
 #define RTOD(r) ((r) * 180 / M_PI)
 
@@ -80,6 +83,8 @@
 
 #define ROUND(x) ( (int)( floor((x)+0.5) ) )
 
-#undef USE_THREADPOOL
+enum EntityType{COMMON, ENTITY, MODEL, BODY, GEOM, BALL_JOINT, BOX_SHAPE, CYLINDER_SHAPE, HEIGHTMAP_SHAPE, HINGE2_JOINT, HINGE_JOINT, JOINT, MAP_SHAPE, MULTIRAY_SHAPE, RAY_SHAPE, PLANE_SHAPE, SHAPE, SLIDER_JOINT, SPHERE_SHAPE, TRIMESH_SHAPE, UNIVERSAL_JOINT, LIGHT, VISUAL};
 
+static std::string EntityTypename[] = { "common", "entity", "model", "body", "geom", "ball", "box", "cylinder", "heightmap", "hinge2", "hinge", "joint", "map", "multiray", "ray", "plane", "shape", "slider", "sphere", "trimesh", "universal", "light","visual" };
+
 #endif
Index: server/Param.hh
===================================================================
--- server/Param.hh	(revision 8976)
+++ server/Param.hh	(working copy)
@@ -33,6 +33,7 @@
 #include <boost/any.hpp>
 #include <boost/bind.hpp>
 #include <boost/signal.hpp>
+#include <boost/algorithm/string.hpp>
 #include <typeinfo>
 #include <string>
 
@@ -40,6 +41,8 @@
 
 namespace gazebo
 {
+
+
   class Param
   {
     /// \brief Constructor
@@ -72,6 +75,18 @@
     /// \brief Get the help string
     public: std::string GetHelp() const {return this->help;}
 
+    public: bool IsBool() const;
+    public: bool IsInt() const;
+    public: bool IsUInt() const;
+    public: bool IsFloat() const;
+    public: bool IsDouble() const;
+    public: bool IsChar() const;
+    public: bool IsStr() const;
+    public: bool IsVector3() const;
+    public: bool IsVector4() const;
+    public: bool IsQuatern() const;
+    public: bool IsPose3d() const;
+
     /// List of created parameters
     private: static std::vector<Param*> *params;
 
@@ -103,7 +118,7 @@
     public: T GetValue() const;
 
     /// \brief Set the value of the parameter
-    public: void SetValue(const T &value);
+    public: void SetValue(const T &value, bool callback=false);
 
     public: inline T operator*() const {return value;}
 
@@ -183,11 +198,13 @@
   void ParamT<T>::SetFromString(const std::string &str, bool callback)
   {
     std::string tmp = str;
+    std::string lower_tmp = str;
+    boost::to_lower(lower_tmp);
 
     // "true" and "false" doesn't work properly
-    if (tmp == "true")
+    if (lower_tmp == "true")
       tmp = "1";
-    else if (str == "false")
+    else if (lower_tmp == "false")
       tmp = "0";
 
     try
@@ -222,9 +239,12 @@
   //////////////////////////////////////////////////////////////////////////////
   /// Set the value of the parameter
   template<typename T>
-  void ParamT<T>::SetValue(const T &v)
+  void ParamT<T>::SetValue(const T &v, bool callback)
   {
     this->value = v;
+
+    if (callback)
+      this->changeSignal(this->value);
   }
 
 }
Index: server/Vector3.cc
===================================================================
--- server/Vector3.cc	(revision 8976)
+++ server/Vector3.cc	(working copy)
@@ -93,6 +93,25 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+/// Round to near whole number 
+Vector3 Vector3::Round()
+{
+  this->x = nearbyint(this->x);
+  this->y = nearbyint(this->y);
+  this->z = nearbyint(this->z);
+  return *this;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get a rounded version of this vector
+Vector3 Vector3::GetRounded() const
+{
+  Vector3 result = *this;
+  result.Round();
+  return result;
+}
+
+////////////////////////////////////////////////////////////////////////////////
 // Set the contents of the vector
 void Vector3::Set(double x, double y, double z)
 {
Index: server/XMLConfig.cc
===================================================================
--- server/XMLConfig.cc	(revision 8976)
+++ server/XMLConfig.cc	(working copy)
@@ -36,8 +36,10 @@
 #include <libxml/xpointer.h>
 
 #include <boost/algorithm/string.hpp>
+#include <boost/lexical_cast.hpp>
 
 #include "GazeboError.hh"
+#include "GazeboMessage.hh"
 #include "Global.hh"
 #include "XMLConfig.hh"
 
Index: server/rendering/RTShaderSystem.hh
===================================================================
--- server/rendering/RTShaderSystem.hh	(revision 8976)
+++ server/rendering/RTShaderSystem.hh	(working copy)
@@ -35,12 +35,13 @@
 #include <RTShaderSystem/OgreRTShaderSystem.h>
 #endif
 
+#include "OgreCamera.hh"
 #include "SingletonT.hh"
 
 namespace gazebo
 {
-  class ShaderGeneratorTechniqueResolverListener;
   class OgreVisual;
+  class Scene;
 
   class RTShaderSystem : public SingletonT<RTShaderSystem>
   {
@@ -64,6 +65,9 @@
     /// \brief Finalize the shader system
     public: void Fini();
 
+    /// \brief Add a scene manager
+    public: void AddScene(Scene *scene);
+
     /// \brief Update the shaders
     public: void UpdateShaders();
 
@@ -74,21 +78,20 @@
     public: void DetachEntity(OgreVisual *vis);
 
     /// \brief Set a viewport to use shaders
-    public: static void AttachViewport(Ogre::Viewport *vp)
-            {
-#if OGRE_VERSION_MAJOR == 1 && OGRE_VERSION_MINOR >= 7
-              vp->setMaterialScheme(
-                  Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME);
-#endif
-            }
+    public: static void AttachViewport(OgreCamera *camera);
 
     /// Set the lighting model to per pixel or per vertex
     public: void SetPerPixelLighting( bool s);
 
     /// \brief Generate shaders for an entity
-    private: void GenerateShaders(OgreVisual *vis);
+    public: void GenerateShaders(OgreVisual *vis);
 
     /// \brief Get paths for the shader system
+    //private: bool GetPaths(std::string &coreLibsPath, std::string &cachePath);
+
+    public: void ApplyShadows();
+
+    /// \brief Get paths for the shader system
     private: bool GetPaths(std::string &coreLibsPath, std::string &cachePath);
 
 #if OGRE_VERSION_MAJOR == 1 && OGRE_VERSION_MINOR >= 7
@@ -101,6 +104,7 @@
     private: friend class DestroyerT<RTShaderSystem>;
     private: friend class SingletonT<RTShaderSystem>;
   };
+
 }
 
 #endif
Index: server/rendering/Image.hh
===================================================================
--- server/rendering/Image.hh	(revision 8976)
+++ server/rendering/Image.hh	(working copy)
@@ -86,10 +86,15 @@
     /// \brief Returns whether this is a valid image
     public: bool Valid() const;
 
+    /// \brief Get the full filename of the image
+    public: std::string GetFilename() const;
+
     /// Count the number of images created. Used for initialising free image
     private: static int count;
 
     private: FIBITMAP *bitmap;
+
+    private: std::string fullName;
   };
 }
 
Index: server/rendering/OgreHeightmap.hh
===================================================================
--- server/rendering/OgreHeightmap.hh	(revision 8976)
+++ server/rendering/OgreHeightmap.hh	(working copy)
@@ -34,12 +34,13 @@
 
 namespace gazebo
 {
+  class Scene;
 
   /// \brief Height map geom
   class OgreHeightmap : public Ogre::RaySceneQueryListener
   {
     /// \brief Constructor
-    public: OgreHeightmap();
+    public: OgreHeightmap(unsigned int sceneIndex);
 
     /// \brief Destructor
     public: virtual ~OgreHeightmap();
@@ -65,6 +66,7 @@
     private: Ogre::RaySceneQuery *rayQuery;
 
     private: double distToTerrain;
+    private: Scene *scene;
   };
 }
 
Index: server/rendering/FPSViewController.hh
===================================================================
--- server/rendering/FPSViewController.hh	(revision 8976)
+++ server/rendering/FPSViewController.hh	(working copy)
@@ -16,6 +16,9 @@
     /// \brief Update
     public: virtual void Update();
 
+    /// \brief Get the type name of this view controller
+    public: static std::string GetTypeString() {return "FPSViewController";}
+
     /// \brief Handle a mouse event
     public: virtual void HandleMouseEvent(const MouseEvent &event);
 
Index: server/rendering/OgreCamera.cc
===================================================================
--- server/rendering/OgreCamera.cc	(revision 8976)
+++ server/rendering/OgreCamera.cc	(working copy)
@@ -29,6 +29,7 @@
 #include <Ogre.h>
 #include <dirent.h>
 
+#include "Events.hh"
 #include "FPSViewController.hh"
 #include "OrbitViewController.hh"
 #include "PhysicsEngine.hh"
@@ -42,6 +43,7 @@
 #include "Model.hh"
 #include "Body.hh"
 
+#include "Scene.hh"
 #include "OgreAdaptor.hh"
 #include "CameraManager.hh"
 #include "OgreCamera.hh"
@@ -52,10 +54,10 @@
 
 //////////////////////////////////////////////////////////////////////////////
 // Constructor
-OgreCamera::OgreCamera(const std::string &namePrefix)
+OgreCamera::OgreCamera(const std::string &namePrefix, unsigned int sceneIndex)
 {
-  this->name = "DefaultCameraName";
-  this->lastRenderTime = Simulator::Instance()->GetSimTime();
+  this->scene = OgreAdaptor::Instance()->GetScene(sceneIndex);
+  this->lastUpdate = Simulator::Instance()->GetSimTime();
 
   this->animState = NULL;
   this->textureWidth = this->textureHeight = 0;
@@ -68,14 +70,14 @@
 
   std::ostringstream stream;
   stream << namePrefix << "(" << this->myCount << ")";
-  this->cameraName = stream.str();
+  this->name = stream.str();
 
   this->renderTarget = NULL;
   this->userMovable = true;
 
   Param::Begin(&this->camParameters);
-  this->nearClipP = new ParamT<double>("nearClip",0.1,0);
-  this->farClipP = new ParamT<double>("farClip",50,0);
+  this->nearClipP = new ParamT<double>("nearClip",1,0);
+  this->farClipP = new ParamT<double>("farClip",100,0);
   this->saveFramesP = new ParamT<bool>("saveFrames",false,0);
   this->savePathnameP = new ParamT<std::string>("saveFramePath","",0);
   this->imageSizeP = new ParamT< Vector2<int> >("imageSize", Vector2<int>(320, 240),0);
@@ -89,10 +91,11 @@
   this->captureData = false;
 
   this->camera = NULL;
+  this->viewport = NULL;
 
   this->renderingEnabled = true;
 
-  World::Instance()->ConnectShowWireframeSignal( boost::bind(&OgreCamera::ShowWireframe, this, _1) );
+  Events::ConnectShowWireframeSignal( boost::bind(&OgreCamera::ToggleShowWireframe, this) );
 
   this->pitchNode = NULL;
   this->sceneNode = NULL;
@@ -124,20 +127,20 @@
 
   if (this->pitchNode)
   {
-    this->sceneNode->removeAndDestroyChild( this->cameraName + "PitchNode");
+    this->sceneNode->removeAndDestroyChild( this->name + "PitchNode");
     this->pitchNode = NULL;
   }
   if (this->camera)
   {
-    OgreCreator::DeleteCamera(this->camera);
+    this->scene->GetManager()->destroyCamera(this->name);
     this->camera = NULL;
   }
-  OgreAdaptor::Instance()->UnregisterCamera(this);
+  this->scene->UnregisterCamera(this);
 }
 
 //////////////////////////////////////////////////////////////////////////////
 // Load the camera
-void OgreCamera::LoadCam( XMLConfigNode *node )
+void OgreCamera::Load( XMLConfigNode *node )
 {
   // This should be last in the constructor
   CameraManager::Instance()->AddCamera(this);
@@ -173,6 +176,10 @@
       this->imageFormat = Ogre::PF_B8G8R8;
     else if (this->imageFormatP->GetValue() == "B8G8R8")
       this->imageFormat = Ogre::PF_R8G8B8;
+    else if (this->imageFormatP->GetValue() == "FLOAT32")
+      this->imageFormat = Ogre::PF_FLOAT32_R;
+    else if (this->imageFormatP->GetValue() == "FLOAT16")
+      this->imageFormat = Ogre::PF_FLOAT16_R;
     else if ( (this->imageFormatP->GetValue() == "BAYER_RGGB8") ||
               (this->imageFormatP->GetValue() == "BAYER_BGGR8") ||
               (this->imageFormatP->GetValue() == "BAYER_GBRG8") ||
@@ -208,13 +215,11 @@
     gzthrow("near clipping plane (min depth) <= zero");
   }
 
-  this->lastUpdate = Simulator::Instance()->GetSimTime();
-
 }
 
 //////////////////////////////////////////////////////////////////////////////
 /// Save camera info in xml format
-void OgreCamera::SaveCam(std::string &prefix, std::ostream &stream)
+void OgreCamera::Save(std::string &prefix, std::ostream &stream)
 {
   stream << prefix << (*this->nearClipP) << "\n";
   stream << prefix << (*this->farClipP) << "\n";
@@ -228,39 +233,42 @@
  
 //////////////////////////////////////////////////////////////////////////////
 // Initialize the camera
-void OgreCamera::InitCam()
+void OgreCamera::Init()
 {
   if (!Simulator::Instance()->GetRenderEngineEnabled())
     return;
 
-  this->camera = OgreCreator::CreateCamera(this->cameraName, 
-      **this->nearClipP, **this->farClipP, *(**this->hfovP), 
-      this->renderTarget );
+  this->CreateOgreCamera();
 
   // Create a scene node to control pitch motion
-  this->pitchNode = this->sceneNode->createChildSceneNode( this->cameraName + "PitchNode");
+  this->pitchNode = this->sceneNode->createChildSceneNode( this->name + "PitchNode");
   this->pitchNode->pitch(Ogre::Degree(0));
   this->pitchNode->attachObject(this->camera);
   this->camera->setAutoAspectRatio(true);
 
   this->saveCount = 0;
 
-  OgreAdaptor::Instance()->RegisterCamera(this);
-
   this->origParentNode = (Ogre::SceneNode*)this->sceneNode->getParent();
 
+  Ogre::Real left, right ,top, bottom;
+
+  //Ogre::Frustum *frustum = this->camera->getFrustum();
+  //this->camera->getFrustumExtents(left, right, top, bottom);
+  //this->camera->setFrustumExtents(-100, 100, 100, -100);
+  //printf("F Extents[%f %f %f %f]\n", left, right ,top ,bottom);
+
   this->lastUpdate = Simulator::Instance()->GetSimTime();
 }
 
 //////////////////////////////////////////////////////////////////////////////
 // Finalize the camera
-void OgreCamera::FiniCam()
+void OgreCamera::Fini()
 {
 }
 
 //////////////////////////////////////////////////////////////////////////////
 // Update the drawing
-void OgreCamera::UpdateCam()
+void OgreCamera::Update()
 {
   this->viewController->Update();
 
@@ -271,8 +279,8 @@
     {
       this->animState = NULL;
 
-      OgreAdaptor::Instance()->sceneMgr->destroyAnimation("cameratrack");
-      OgreAdaptor::Instance()->sceneMgr->destroyAnimationState("cameratrack");
+      this->scene->GetManager()->destroyAnimation("cameratrack");
+      this->scene->GetManager()->destroyAnimationState("cameratrack");
     }
   }
 
@@ -343,62 +351,83 @@
       DIAGNOSTICTIMER(timer("OgreCamera::Render(): renderTarget update",6));
       //boost::recursive_mutex::scoped_lock md_lock(*Simulator::Instance()->GetMDMutex());
       this->lastRenderTime = Simulator::Instance()->GetSimTime();
-      this->renderTarget->update();
+
+      this->lastUpdate = Simulator::Instance()->GetSimTime();
+      this->newData = true;
+      this->renderTarget->update(false);
     }
+  }
+}
 
-    if (this->captureData)
-    {
-      //boost::recursive_mutex::scoped_lock mr_lock(*Simulator::Instance()->GetMRMutex());
+void OgreCamera::PostRender()
+{
+  if (this->newData && this->captureData)
+  {
+    boost::recursive_mutex::scoped_lock mr_lock(*Simulator::Instance()->GetMRMutex());
 
-      Ogre::HardwarePixelBufferSharedPtr pixelBuffer;
-      Ogre::RenderTexture *rTexture;
-      Ogre::Viewport* renderViewport;
+    Ogre::HardwarePixelBufferSharedPtr pixelBuffer;
+    Ogre::RenderTexture *rTexture;
+    Ogre::Viewport* renderViewport;
 
-      size_t size;
+    size_t size;
 
-      // Get access to the buffer and make an image and write it to file
-      pixelBuffer = this->renderTexture->getBuffer();
-      rTexture = pixelBuffer->getRenderTarget();
+    // Get access to the buffer and make an image and write it to file
+    pixelBuffer = this->renderTexture->getBuffer();
+    rTexture = pixelBuffer->getRenderTarget();
 
-      Ogre::PixelFormat format = pixelBuffer->getFormat();
-      renderViewport = rTexture->getViewport(0);
+    Ogre::PixelFormat format = pixelBuffer->getFormat();
+    renderViewport = rTexture->getViewport(0);
 
-      size = Ogre::PixelUtil::getMemorySize((**this->imageSizeP).x,
-          (**this->imageSizeP).y, 
-          1, 
-          format);
+    size = Ogre::PixelUtil::getMemorySize((**this->imageSizeP).x,
+        (**this->imageSizeP).y, 
+        1, 
+        format);
 
-      // Allocate buffer
-      if (!this->saveFrameBuffer)
-        this->saveFrameBuffer = new unsigned char[size];
+    // Allocate buffer
+    if (!this->saveFrameBuffer)
+      this->saveFrameBuffer = new unsigned char[size];
 
-      memset(this->saveFrameBuffer,128,size);
+    memset(this->saveFrameBuffer,128,size);
 
-      Ogre::PixelBox box((**this->imageSizeP).x, (**this->imageSizeP).y,
-          1, this->imageFormat, this->saveFrameBuffer);
+    Ogre::PixelBox box((**this->imageSizeP).x, (**this->imageSizeP).y,
+        1, this->imageFormat, this->saveFrameBuffer);
 
-      pixelBuffer->blitToMemory( box );
+    pixelBuffer->blitToMemory( box );
 
-      if (this->saveFramesP->GetValue())
-      {
-        this->SaveFrame();
-      }
+    if (this->saveFramesP->GetValue())
+    {
+      this->SaveFrame();
     }
-
-    this->lastUpdate = Simulator::Instance()->GetSimTime();
   }
 
+  this->newData = false;
 }
 
 
 ////////////////////////////////////////////////////////////////////////////////
 // Get the global pose of the camera
-Pose3d OgreCamera::GetCameraWorldPose() const
+Pose3d OgreCamera::GetWorldPose() const
 {
+  Ogre::Vector3 camPos = this->camera->getRealPosition();
+  Ogre::Quaternion camOrient = this->camera->getRealOrientation();
+
+  Pose3d pose;
+  pose.pos.x = camPos.x;
+  pose.pos.y = camPos.y;
+  pose.pos.z = camPos.z;
+
   return this->pose;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+/// Get the camera position in the world
+Vector3 OgreCamera::GetWorldPosition() const
+{
+  Ogre::Vector3 camPos = this->camera->getRealPosition();
+  return Vector3(camPos.x,camPos.y,camPos.z);
+}
+
+////////////////////////////////////////////////////////////////////////////////
 /// Set the global pose of the camera
 void OgreCamera::SetWorldPose(const Pose3d &pose)
 {
@@ -413,34 +442,30 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Set the world position
-void OgreCamera::SetPosition(const Vector3 &pos)
+void OgreCamera::SetWorldPosition(const Vector3 &pos)
 {
   if (!Simulator::Instance()->GetRenderEngineEnabled())
     return;
 
-
   this->pose.pos = pos;
   this->pose.Correct();
   
   this->sceneNode->setPosition( this->pose.pos.x, this->pose.pos.y, this->pose.pos.z);
 }
- 
+
 ////////////////////////////////////////////////////////////////////////////////
-/// Set the clip distances
-void OgreCamera::SetClipDist(float near, float far)
+/// Set the world orientation
+void OgreCamera::SetWorldRotation(const Quatern &quant)
 {
-  this->nearClipP->SetValue(near);
-  this->farClipP->SetValue(far);
-}
+  if (!Simulator::Instance()->GetRenderEngineEnabled())
+    return;
 
-////////////////////////////////////////////////////////////////////////////////
-/// Set the camera FOV (horizontal)  
-void OgreCamera::SetFOV( float radians )
-{
-  this->hfovP->SetValue(radians);
+  this->pose.rot = quant;
+  this->pose.Correct();
+ 
+  this->pitchNode->setOrientation( this->pose.rot.u, this->pose.rot.x, this->pose.rot.y, this->pose.rot.z);
 }
 
-
 ////////////////////////////////////////////////////////////////////////////////
 // Translate the camera
 void OgreCamera::Translate( const Vector3 &direction )
@@ -465,6 +490,29 @@
   this->pitchNode->yaw(Ogre::Radian(angle));
 }
 
+
+////////////////////////////////////////////////////////////////////////////////
+/// Set the clip distances
+void OgreCamera::SetClipDist(float near, float far)
+{
+  this->nearClipP->SetValue(near);
+  this->farClipP->SetValue(far);
+
+  if (camera)
+  {
+    this->camera->setNearClipDistance(.001);
+    this->camera->setFarClipDistance(1000);
+  }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Set the camera FOV (horizontal)  
+void OgreCamera::SetFOV( float radians )
+{
+  this->hfovP->SetValue(radians);
+}
+
+
 //////////////////////////////////////////////////////////////////////////////
 /// Get the horizontal field of view of the camera
 Angle OgreCamera::GetHFOV() const
@@ -526,14 +574,14 @@
 /// Get the width of the texture
 unsigned int OgreCamera::GetTextureWidth() const
 {
-  return this->textureWidth;
+  return this->renderTexture->getBuffer(0,0)->getWidth();
 }
 
 //////////////////////////////////////////////////////////////////////////////
 /// \brief Get the height of the texture
 unsigned int OgreCamera::GetTextureHeight() const
 {
-  return this->textureHeight;
+  return this->renderTexture->getBuffer(0,0)->getHeight();
 }
 
 
@@ -631,9 +679,7 @@
 /// Get the viewport up vector
 Vector3 OgreCamera::GetUp()
 {
-  //std::cout << "ogre cam position " <<  this->camera->getRealPosition() << std::endl;
   Ogre::Vector3 up = this->camera->getRealUp();
-  //std::cout << "ogre up " <<  up << std::endl;
   return Vector3(up.x,up.y,up.z);
 }
 
@@ -642,18 +688,11 @@
 Vector3 OgreCamera::GetRight()
 {
   Ogre::Vector3 right = this->camera->getRealRight();
-  //std::cout << "ogre right " <<  right << std::endl;
   return Vector3(right.x,right.y,right.z);
 }
 
-////////////////////////////////////////////////////////////////////////////////
-/// Get the camera position in the world
-Vector3 OgreCamera::GetCameraPosition()
-{
-  Ogre::Vector3 camPos = this->camera->getRealPosition();
-  return Vector3(camPos.x,camPos.y,camPos.z);
-}
 
+
 ////////////////////////////////////////////////////////////////////////////////
 /// Set whether the user can move the camera via the GUI
 void OgreCamera::SetUserMovable( bool movable )
@@ -669,17 +708,17 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Get the name of the camera
-std::string OgreCamera::GetCameraName()
+/// Set the camera's scene node
+void OgreCamera::SetSceneNode( Ogre::SceneNode *node )
 {
-  return this->cameraName;
+  this->sceneNode = node;
 }
 
-////////////////////////////////////////////////////////////////////////////////
-/// Set the camera's scene node
-void OgreCamera::SetCameraSceneNode( Ogre::SceneNode *node )
+//////////////////////////////////////////////////////////////////////////////
+/// Get the camera's scene node
+Ogre::SceneNode *OgreCamera::GetSceneNode() const
 {
-  this->sceneNode = node;
+  return this->pitchNode;
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -709,20 +748,12 @@
 
 //////////////////////////////////////////////////////////////////////////////
 /// Get the camera's name
-std::string OgreCamera::GetCamName()
+std::string OgreCamera::GetName() const
 {
   return this->name;
 }
 
 //////////////////////////////////////////////////////////////////////////////
-/// Set the camera's name
-void OgreCamera::SetCamName( const std::string &_name )
-{
-  this->name = _name;
-}
-
-
-//////////////////////////////////////////////////////////////////////////////
 // Save the current frame to disk
 void OgreCamera::SaveFrame()
 {
@@ -767,11 +798,11 @@
     int sec = (int)(simTime - min*60);
     int msec = (int)(simTime*1000 - min*60000 - sec*1000);
 
-    sprintf(tmp, "%s/%s-%04d-%03dm_%02ds_%03dms.jpg", this->savePathnameP->GetValue().c_str(), this->GetCamName().c_str(), this->saveCount, min, sec, msec);
+    sprintf(tmp, "%s/%s-%04d-%03dm_%02ds_%03dms.jpg", this->savePathnameP->GetValue().c_str(), this->GetName().c_str(), this->saveCount, min, sec, msec);
   }
   else
   {
-    sprintf(tmp, "%s-%04d.jpg", this->GetCamName().c_str(), this->saveCount);
+    sprintf(tmp, "%s-%04d.jpg", this->GetName().c_str(), this->saveCount);
   }
 
   // Get codec
@@ -799,19 +830,19 @@
   if (!entity)
     return;
 
-  if (OgreAdaptor::Instance()->sceneMgr->hasAnimation("cameratrack"))
+  if (this->scene->GetManager()->hasAnimation("cameratrack"))
   {
-    OgreAdaptor::Instance()->sceneMgr->destroyAnimation("cameratrack");
-    OgreAdaptor::Instance()->sceneMgr->destroyAnimationState("cameratrack");
+    this->scene->GetManager()->destroyAnimation("cameratrack");
+    this->scene->GetManager()->destroyAnimationState("cameratrack");
   }
 
-  Ogre::Animation *anim = OgreAdaptor::Instance()->sceneMgr->createAnimation("cameratrack",.5);
+  Ogre::Animation *anim = this->scene->GetManager()->createAnimation("cameratrack",.5);
   anim->setInterpolationMode(Ogre::Animation::IM_SPLINE);
 
   Ogre::NodeAnimationTrack *strack = anim->createNodeTrack(0,this->sceneNode);
   Ogre::NodeAnimationTrack *ptrack = anim->createNodeTrack(1,this->pitchNode);
 
-  Vector3 start = this->GetCameraWorldPose().pos;
+  Vector3 start = this->GetWorldPose().pos;
   start.Correct();
   Vector3 end = entity->GetWorldPose().pos;
   end.Correct();
@@ -859,7 +890,7 @@
   key = ptrack->createNodeKeyFrame(.5);
   key->setRotation(pitchFinal);
 
-  this->animState = OgreAdaptor::Instance()->sceneMgr->createAnimationState("cameratrack");
+  this->animState = this->scene->GetManager()->createAnimationState("cameratrack");
   this->animState->setEnabled(true);
   this->animState->setLoop(false);
 }
@@ -886,6 +917,19 @@
 }
 
 //////////////////////////////////////////////////////////////////////////////
+// Toggle whether to view the world in wireframe
+void OgreCamera::ToggleShowWireframe()
+{
+   if (this->camera)
+  {
+    if (this->camera->getPolygonMode() == Ogre::PM_WIREFRAME)
+      this->camera->setPolygonMode(Ogre::PM_SOLID);
+    else
+      this->camera->setPolygonMode(Ogre::PM_WIREFRAME);
+  } 
+}
+
+//////////////////////////////////////////////////////////////////////////////
 // Set whether to view the world in wireframe
 void OgreCamera::ShowWireframe(bool s)
 {
@@ -1063,7 +1107,94 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Get the time of the last render update
-gazebo::Time OgreCamera::GetLastRenderTime() const
+gazebo::Time OgreCamera::GetLastUpdateTime() const
 {
-  return this->lastRenderTime;
+  return this->lastUpdate;
 }
+
+
+////////////////////////////////////////////////////////////////////////////////
+// Set view controller
+void OgreCamera::SetViewController( const std::string type )
+{
+  delete this->viewController;
+  this->viewController = NULL;
+
+  if (type == OrbitViewController::GetTypeString())
+    this->viewController = new OrbitViewController(this);
+  else if (type == FPSViewController::GetTypeString())
+    this->viewController = new FPSViewController(this);
+  else
+    gzthrow("Invalid view controller type: " + type );
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Set whether to capture data
+void OgreCamera::SetCaptureData( bool value )
+{
+  this->captureData = value;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Set the render target
+void OgreCamera::CreateRenderTexture( const std::string &textureName )
+{
+  // Create the render texture
+  this->renderTexture = Ogre::TextureManager::getSingleton().createManual(
+      textureName,
+      "General",
+      Ogre::TEX_TYPE_2D,
+      this->GetImageWidth(), 
+      this->GetImageHeight(),
+      0,
+      this->imageFormat,
+      Ogre::TU_RENDERTARGET);
+
+  this->renderTarget = this->renderTexture->getBuffer()->getRenderTarget();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Return this scene
+Scene *OgreCamera::GetScene() const
+{
+  return this->scene;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Create the ogre camera
+void OgreCamera::CreateOgreCamera()
+{
+  if (!Simulator::Instance()->GetRenderEngineEnabled())
+    return;
+
+  Ogre::Viewport *cviewport;
+
+  this->camera = this->scene->GetManager()->createCamera(this->name);
+
+  // Use X/Y as horizon, Z up
+  this->camera->pitch(Ogre::Degree(90));
+
+  // Don't yaw along variable axis, causes leaning
+  this->camera->setFixedYawAxis(true, Ogre::Vector3::UNIT_Z);
+
+  this->camera->setDirection(1,0,0);
+
+  this->camera->setNearClipDistance(.001);//**this->nearClipP);
+  this->camera->setFarClipDistance(1000);//**this->farClipP);
+
+  if (this->renderTarget)
+  {
+    // Setup the viewport to use the texture
+    this->viewport = this->renderTarget->addViewport(this->camera);
+    this->viewport->setClearEveryFrame(true);
+    this->viewport->setBackgroundColour( this->scene->GetBackgroundColor().GetOgreColor() );
+
+    double ratio = (double)this->viewport->getActualWidth() / 
+                   (double)this->viewport->getActualHeight();
+    double vfov = 2.0 * atan(tan( (**this->hfovP).GetAsRadian() / 2.0) / ratio);
+    this->camera->setAspectRatio(ratio);
+    this->camera->setFOVy(Ogre::Radian(vfov));
+  }
+
+  this->scene->RegisterCamera(this);
+}
Index: server/rendering/OgreAdaptor.cc
===================================================================
--- server/rendering/OgreAdaptor.cc	(revision 8976)
+++ server/rendering/OgreAdaptor.cc	(working copy)
@@ -37,6 +37,9 @@
 
 #include "gazebo_config.h"
 
+#include "Events.hh"
+#include "Scene.hh"
+#include "Grid.hh"
 #include "OgreVisual.hh"
 #include "UserCamera.hh"
 #include "OgreMovableText.hh"
@@ -57,8 +60,6 @@
 
 using namespace gazebo;
 
-enum SceneTypes{SCENE_BSP, SCENE_EXT};
-
 ////////////////////////////////////////////////////////////////////////////////
 /// Constructor
 OgreAdaptor::OgreAdaptor()
@@ -67,22 +68,11 @@
   this->logManager = new Ogre::LogManager();
   this->logManager->createLog("Ogre.log", true, false, false);
 
-  this->backgroundColor=NULL;
   this->logManager=NULL;
-  this->sceneMgr=NULL;
   this->root=NULL;
+  //this->frameListener = NULL;
 
-  this->frameListener = NULL;
-
   this->dummyDisplay = false;
-
-  Param::Begin(&this->parameters);
-  this->ambientP = new ParamT<Vector4>("ambient",Vector4(.1,.1,.1,.1),0);
-  this->shadowsP = new ParamT<bool>("shadows", true, 0);
-  this->skyMaterialP = new ParamT<std::string>("material","",1);
-  this->backgroundColorP = new ParamT<Vector3>("backgroundColor",Vector3(0.5,0.5,0.5), 0);
-
-  Param::End();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -95,27 +85,22 @@
     XDestroyWindow(this->dummyDisplay, this->dummyWindowId);
     XCloseDisplay(this->dummyDisplay);
   }
-
-  delete this->ambientP;
-  delete this->shadowsP;
-  delete this->backgroundColorP;
-  delete this->skyMaterialP;
-
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Closes and free
 void OgreAdaptor::Close()
 {
-  if (this->frameListener)
-    delete this->frameListener;
-  this->frameListener = NULL;
+  this->Fini();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Load the parameters for Ogre
 void OgreAdaptor::Load(XMLConfigNode *rootNode)
 {
+  if (this->root)
+    return;
+
   // Make the root
   try
   {
@@ -129,14 +114,27 @@
   // Load all the plugins
   this->LoadPlugins();
 
-  // Setup the available resources
-  this->SetupResources();
-
   // Setup the rendering system, and create the context
   this->SetupRenderSystem();
 
   // Initialize the root node, and don't create a window
   this->root->initialise(false);
+
+  // Setup the available resources
+  this->SetupResources();
+
+  Scene *scene = new Scene("primary_scene");
+  scene->Load(rootNode->GetChild("ogre", "rendering"));
+  scene->CreateGrid( 10, 1, 0.03, Color(1,1,1,1));
+  this->scenes.push_back( scene );  
+
+  scene = new Scene("viewer_scene");
+  scene->SetType(Scene::GENERIC);
+  scene->SetAmbientColor(Color(0.5, 0.5, 0.5));
+  scene->SetBackgroundColor(Color(0.5, 0.5, 0.5, 1.0));
+  scene->CreateGrid( 10, 1, 0.03, Color(1,1,1,1));
+
+  this->scenes.push_back( scene );  
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -174,45 +172,26 @@
 
     glXMakeCurrent(this->dummyDisplay, this->dummyWindowId, this->dummyContext);
 
-    OgreCreator::Instance()->CreateWindow(this->dummyDisplay, screen, 
-                                          (int32_t)this->dummyWindowId,1,1);
+    std::stringstream stream;
+    stream << (int32_t)this->dummyWindowId;
+    OgreCreator::Instance()->CreateWindow( stream.str(), 1,1);
   }
 
   // Set default mipmap level (NB some APIs ignore this)
   Ogre::TextureManager::getSingleton().setDefaultNumMipmaps( 5 );
-
-  // Get the SceneManager, in this case a generic one
-  if (node && node->GetChild("bsp"))
-  {
-    this->sceneType= SCENE_BSP;
-    this->sceneMgr = this->root->createSceneManager("BspSceneManager");
-  }
-  else
-  {
-    this->sceneType= SCENE_EXT;
-    //this->sceneMgr = this->root->createSceneManager(Ogre::ST_EXTERIOR_FAR);
-    this->sceneMgr = this->root->createSceneManager(Ogre::ST_EXTERIOR_CLOSE);
-    //this->sceneMgr = this->root->createSceneManager(Ogre::ST_GENERIC);
-  }
-
-  // Load Resources
+  
+  // init the resources
   Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups();
 
-  this->ambientP->Load(node);
-  this->shadowsP->Load(node);
-  this->backgroundColorP->Load(node);
+  Ogre::MaterialManager::getSingleton().setDefaultTextureFiltering(Ogre::TFO_ANISOTROPIC);
 
-  ambient.r = (**(this->ambientP)).x;
-  ambient.g = (**(this->ambientP)).y;
-  ambient.b = (**(this->ambientP)).z;
-  ambient.a = (**(this->ambientP)).w;
+  if (this->HasGLSL())
+    RTShaderSystem::Instance()->Init();
 
-  // Default background color
-  this->backgroundColor = new Ogre::ColourValue(Ogre::ColourValue(
-          (**this->backgroundColorP).x,
-          (**this->backgroundColorP).y,
-          (**this->backgroundColorP).z));
+  for (unsigned int i=0; i < 1; i++)
+    this->scenes[i]->Init(this->root);
 
+/*
   // Ambient lighting
   this->sceneMgr->setAmbientLight(ambient);
 
@@ -261,16 +240,16 @@
   this->raySceneQuery = this->sceneMgr->createRayQuery( Ogre::Ray() );
   this->raySceneQuery->setSortByDistance(true);
   this->raySceneQuery->setQueryMask(Ogre::SceneManager::ENTITY_TYPE_MASK);
+*/
 
   if (this->HasGLSL())
   {
-    RTShaderSystem::Instance()->Init();
+    //RTShaderSystem::Instance()->Init();
     RTShaderSystem::Instance()->UpdateShaders();
   }
 }
 
 
-
 ////////////////////////////////////////////////////////////////////////////////
 /// Finalize
 void OgreAdaptor::Fini()
@@ -284,21 +263,10 @@
 void OgreAdaptor::Save(std::string &prefix, std::ostream &stream)
 {
   stream << prefix << "<rendering:ogre>\n";
-  stream << prefix << "  " << *(this->ambientP) << "\n";
-
-  if ((**this->skyMaterialP).size())
-  {
-    stream << prefix << "  <sky>\n";
-    stream << prefix << "    " << *(this->skyMaterialP) << "\n";
-    stream << prefix << "  </sky>\n";
-  }
-
-  OgreCreator::SaveFog(prefix, stream);
-  stream << prefix << "  " << *(this->shadowsP) << "\n";
+  this->scenes[0]->Save(prefix,stream);
   stream << prefix << "</rendering:ogre>\n";
 }
 
-
 ////////////////////////////////////////////////////////////////////////////////
 // Load plugins
 void OgreAdaptor::LoadPlugins()
@@ -325,6 +293,7 @@
     plugins.push_back(path+"/Plugin_ParticleFX.so");
     plugins.push_back(path+"/Plugin_BSPSceneManager.so");
     plugins.push_back(path+"/Plugin_OctreeSceneManager.so");
+    plugins.push_back(path+"/Plugin_CgProgramManager.so");
 
     for (piter=plugins.begin(); piter!=plugins.end(); piter++)
     {
@@ -335,10 +304,10 @@
       }
       catch (Ogre::Exception e)
       {
-        std::string description("Unable to load Ogre Plugins on directory ");
-        description.append(path);
-        description.append("\n Make sure the plugins path in the gazebo configuration file are set correctly.\n");
-        gzthrow( description + e.getDescription() );
+        std::string description("Unable to load Ogre Plugin[");
+        description.append(*piter);
+        description.append("]...Skipping.");
+        gzerr(0) << description << "\n";
       }
     }
   }
@@ -374,7 +343,6 @@
     archNames.push_back((*iter)+"/Media/sets");
     archNames.push_back((*iter)+"/Media/maps");
 
-
     //we want to add all the material files of the sets
     if ((dir=opendir(((*iter)+"/Media/sets").c_str()))!= NULL)
     {
@@ -400,6 +368,7 @@
       }
     }
   }
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -460,20 +429,15 @@
 
 }
 
-
 ////////////////////////////////////////////////////////////////////////////////
-// Update the user cameras
-void OgreAdaptor::UpdateCameras()
+/// Get a scene 
+Scene *OgreAdaptor::GetScene(unsigned int index)
 {
-  UserCamera *userCam;
-
-  std::vector<OgreCamera*>::iterator iter;
-
-  OgreCreator::Instance()->Update();
-  this->root->_fireFrameStarted();
-
-  // Draw all the non-user cameras within the same sim time step
+  if (index < this->scenes.size())
+    return this->scenes[index];
+  else
   {
+/*
     DIAGNOSTICTIMER(timer("UpdateCameras: Non-UserCamera update",6));
     boost::recursive_mutex::scoped_lock model_render_lock(*Simulator::Instance()->GetMRMutex());
     boost::recursive_mutex::scoped_lock model_delete_lock(*Simulator::Instance()->GetMDMutex());
@@ -482,8 +446,11 @@
       if (dynamic_cast<UserCamera*>((*iter)) == NULL)
         (*iter)->Render();
     }
+*/
+    std::cerr << "Invalid Scene Index[" << index << "]\n";
+    return NULL;
   }
-
+/*
   // Must update the user camera's last.
   {
     DIAGNOSTICTIMER(timer("UpdateCameras: UserCamera update",6));
@@ -499,12 +466,14 @@
     DIAGNOSTICTIMER(timer("UpdateCameras: _fireFrameEnded",6));
     this->root->_fireFrameEnded();
   }
+*/
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Get an entity at a pixel location using a camera. Used for mouse picking. 
-Entity *OgreAdaptor::GetEntityAt(OgreCamera *camera, Vector2<int> mousePos, std::string &mod) 
+/// Get the number of scene 
+unsigned int OgreAdaptor::GetSceneCount() const
 {
+/*
   Entity *entity = NULL;
   Ogre::Camera *ogreCam = camera->GetOgreCamera();
   Ogre::Vector3 camPos = ogreCam->getPosition();
@@ -597,73 +566,30 @@
   }
 
   return NULL;
+*/
+  return this->scenes.size();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Get the world pos of a the first contact at a pixel location
-Vector3 OgreAdaptor::GetFirstContact(OgreCamera *camera, Vector2<int> mousePos)
+/// Update all the scenes 
+void OgreAdaptor::UpdateScenes()
 {
-  Ogre::Camera *ogreCam = camera->GetOgreCamera();
-  Ogre::Real closest_distance = -1.0f;
-  Ogre::Ray mouseRay = ogreCam->getCameraToViewportRay(
-      (float)mousePos.x / ogreCam->getViewport()->getActualWidth(), 
-      (float)mousePos.y / ogreCam->getViewport()->getActualHeight() );
+  Events::renderStartSignal();
 
-  this->raySceneQuery->setRay( mouseRay );
+  this->root->_fireFrameStarted();
 
-  // Perform the scene query
-  Ogre::RaySceneQueryResult &result = this->raySceneQuery->execute();
-  Ogre::RaySceneQueryResult::iterator iter = result.begin();
+  OgreCreator::Instance()->Update();
 
-  Ogre::Vector3 pt = mouseRay.getPoint(iter->distance);
+  for (unsigned int i=0; i < this->scenes.size(); i++)
+    this->scenes[i]->UpdateCameras();
 
-  return Vector3(pt.x, pt.y, pt.z);
-}
+  this->root->_fireFrameRenderingQueued();
 
-////////////////////////////////////////////////////////////////////////////////
-/// Register a user camera
-void OgreAdaptor::RegisterCamera( OgreCamera *cam )
-{
-  this->cameras.push_back( cam );
+  this->root->_fireFrameEnded();
 }
 
-////////////////////////////////////////////////////////////////////////////////
-/// Unregister a user camera
-void OgreAdaptor::UnregisterCamera( OgreCamera *cam )
-{
-  std::vector<OgreCamera*>::iterator iter;
-  for(iter=this->cameras.begin();iter != this->cameras.end();iter++)
-  {
-    if ((*iter) == cam)
-    {
-      this->cameras.erase(iter);
-      break;
-    }
-  }
-}
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Print scene graph
-void OgreAdaptor::PrintSceneGraph()
-{
-  this->PrintSceneGraphHelper("", this->sceneMgr->getRootSceneNode());
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Print scene graph
-void OgreAdaptor::PrintSceneGraphHelper(std::string prefix, 
-                                         Ogre::Node *node)
-{
-  std::cout << prefix << node->getName() << std::endl;
-
-  prefix += "  ";
-  for (unsigned int i=0; i < node->numChildren(); i++)
-  {
-    this->PrintSceneGraphHelper( prefix, node->getChild(i) );
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
 // Returns true if the graphics card support GLSL
 bool OgreAdaptor::HasGLSL()
 {
@@ -674,15 +600,14 @@
   capabilities = this->root->getRenderSystem()->getCapabilities();
   profiles = capabilities->getSupportedShaderProfiles();
 
-  iter = std::find(profiles.begin(), profiles.end(), "glsl2");
+  iter = std::find(profiles.begin(), profiles.end(), "glsl");
 
   // Print all the shader profiles
   /*std::cout << "Shader profiles:\n";
   for (iter = profiles.begin(); iter != profiles.end(); iter++)
   {
     std::cout << *iter << "\n";
-  }
-  */
+  }*/
 
   return iter != profiles.end();
 }

Property changes on: server/rendering/Material.hh
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/branches/wx/server/rendering/Material.hh:r8807-8927

Index: server/rendering/OgreCreator.cc
===================================================================
--- server/rendering/OgreCreator.cc	(revision 8976)
+++ server/rendering/OgreCreator.cc	(working copy)
@@ -29,12 +29,11 @@
 #include <iostream>
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
-#include <FL/Fl.H>
-#include <FL/x.H>
 
 #include "gazebo_config.h"
 
 #include "RTShaderSystem.hh"
+#include "RenderControl.hh"
 #include "Light.hh"
 #include "Material.hh"
 #include "Simulator.hh"
@@ -107,7 +106,7 @@
     parent->AttachMesh(resultName);
     parent->SetMaterial(material);
 
-    parent->SetCastShadows(castShadows);
+    parent->SetCastShadows(true);
   }
   catch (Ogre::ItemIdentityException e)
   {
@@ -117,242 +116,7 @@
   return resultName;
 }
 
-
 ////////////////////////////////////////////////////////////////////////////////
-/// Create a light source and attach it to the visual node
-Light *OgreCreator::CreateLight(Entity *parent)
-{
-  Light *newLight = new Light(parent);
-  this->lights.push_back(newLight);
-  return newLight;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Remove a light
-void OgreCreator::DeleteLight(Light *light)
-{
-  if (!light)
-    return;
-
-  std::list<Light*>::iterator iter;
-  for (iter = this->lights.begin(); iter != this->lights.end(); iter++)
-  {
-    if (*iter == light)
-    {
-      delete *iter;
-      this->lights.erase(iter);
-      break;
-    }
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Helper function to create a camera
-Ogre::Camera *OgreCreator::CreateCamera(const std::string &name, 
-    double nearClip, double farClip, double hfov, 
-    Ogre::RenderTarget *renderTarget)
-{
-  if (!Simulator::Instance()->GetRenderEngineEnabled())
-    return NULL;
-
-  Ogre::Camera *camera;
-  Ogre::Viewport *cviewport;
-
-  camera = OgreAdaptor::Instance()->sceneMgr->createCamera(name);
-
-  // Use X/Y as horizon, Z up
-  camera->pitch(Ogre::Degree(90));
-
-  // Don't yaw along variable axis, causes leaning
-  camera->setFixedYawAxis(true, Ogre::Vector3::UNIT_Z);
-
-  camera->setDirection(1,0,0);
-
-  camera->setNearClipDistance(nearClip);
-  camera->setFarClipDistance(farClip);
-
-  if (renderTarget)
-  {
-    // Setup the viewport to use the texture
-    cviewport = renderTarget->addViewport(camera);
-    cviewport->setClearEveryFrame(true);
-    cviewport->setBackgroundColour( *OgreAdaptor::Instance()->backgroundColor );
-
-    double ratio = (double)cviewport->getActualWidth() / (double)cviewport->getActualHeight();
-    double vfov = 2.0 * atan(tan(hfov / 2.0) / ratio);
-    camera->setAspectRatio(ratio);
-    camera->setFOVy(Ogre::Radian(vfov));
-
-    RTShaderSystem::Instance()->AttachViewport(cviewport);
-  }
-
-  return camera;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Helper function to delete a camera
-void OgreCreator::DeleteCamera(Ogre::Camera* camera)
-{
-  OgreAdaptor::Instance()->sceneMgr->destroyCamera(camera);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-void OgreCreator::CreateFog(XMLConfigNode *cnode)
-{
-  if (!Simulator::Instance()->GetRenderEngineEnabled())
-    return;
-
-  if (cnode)
-  {
-    Ogre::ColourValue backgroundColor;
-    Ogre::FogMode fogType = Ogre::FOG_NONE;
-    std::string type;
-    double density;
-    double linearStart, linearEnd;
-
-    backgroundColor.r = cnode->GetTupleDouble("color",0,0);
-    backgroundColor.g = cnode->GetTupleDouble("color",1,0);
-    backgroundColor.b = cnode->GetTupleDouble("color",2,0);
-    type = cnode->GetString("type","linear",0);
-    density = cnode->GetDouble("density",0,0);
-    linearStart = cnode->GetDouble("linearStart",0,0);
-    linearEnd = cnode->GetDouble("linearEnd",1.0,0);
-
-    if (type == "linear")
-      fogType = Ogre::FOG_LINEAR;
-    else if (type == "exp")
-      fogType = Ogre::FOG_EXP;
-    else if (type == "exp2")
-      fogType = Ogre::FOG_EXP2;
-
-    if (type != "none")
-    {
-      OgreAdaptor::Instance()->sceneMgr->setFog(fogType, backgroundColor, density, linearStart, linearEnd);
-      //OgreAdaptor::Instance()->sceneMgr->setFog(Ogre::FOG_LINEAR, backgroundColor, 0, linearStart, linearEnd);
-    }
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-void OgreCreator::SaveFog(std::string &prefix, std::ostream &stream)
-{
-  if (!Simulator::Instance()->GetRenderEngineEnabled())
-    return;
-
-  Ogre::ColourValue color=OgreAdaptor::Instance()->sceneMgr->getFogColour();
-  Ogre::Real start = OgreAdaptor::Instance()->sceneMgr->getFogStart();
-  Ogre::Real end = OgreAdaptor::Instance()->sceneMgr->getFogEnd();
-  Ogre::Real density = OgreAdaptor::Instance()->sceneMgr->getFogDensity();
-  std::string fogMode="";
-
-  switch (OgreAdaptor::Instance()->sceneMgr->getFogMode())
-  {
-    case Ogre::FOG_EXP:
-      fogMode="exp";
-      break;
-    case Ogre::FOG_EXP2:
-      fogMode="exp2";
-      break;
-    case Ogre::FOG_LINEAR:
-      //case default:
-      fogMode="linear";
-      break;
-    case Ogre::FOG_NONE:
-      fogMode="none";
-      break;
-  }
-
-  stream << prefix << "  <fog>\n";
-  stream << prefix << "    <type>" << fogMode << "</type>\n";
-  stream << prefix << "    <color>" << color.r << " " << color.g << " " << color.b << " " << color.a << "</color>\n";
-  stream << prefix << "    <linearStart>" << start << "</linearStart>\n";
-  stream << prefix << "    <linearEnd>" << end << "</linearEnd>\n";
-  stream << prefix << "    <density>" << density << "</density>\n";
-  stream << prefix << "  </fog>\n";
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Create a sky
-void OgreCreator::CreateSky(std::string material)
-{
-  if (!Simulator::Instance()->GetRenderEngineEnabled())
-    return;
-
-  if (!material.empty())
-  {
-    try
-    {
-      /*if (node->GetChild("fog"))
-        {
-        Ogre::Plane plane;
-        plane.d = 49;
-        plane.normal = Ogre::Vector3::NEGATIVE_UNIT_Z;
-        OgreAdaptor::Instance()->sceneMgr->setSkyPlane(true, plane, material, 500, 100, true, 0.5, 150, 150);
-        }
-        else
-        {*/
-      Ogre::Quaternion orientation;
-      orientation.FromAngleAxis( Ogre::Degree(90), Ogre::Vector3(1,0,0));
-      //OgreAdaptor::Instance()->sceneMgr->setSkyDome(true,material,5,8, 4000, true, orientation);
-      OgreAdaptor::Instance()->sceneMgr->setSkyDome(true,material,10,8, 4, true, orientation);
-      //}
-
-    }
-    catch (int)
-    {
-      gzmsg(0) << "Unable to set sky dome to material[" << material << "]\n";
-    }
-
-  }
-}
-
-
-////////////////////////////////////////////////////////////////////////////////
-/// Draw a named line
-void OgreCreator::DrawLine(const Vector3 &start, const Vector3 &end, 
-                           const std::string &name)
-{
-  Ogre::SceneNode *node = NULL;
-  Ogre::ManualObject *obj = NULL;
-  bool attached = false;
-
-  if ( OgreAdaptor::Instance()->sceneMgr->hasManualObject(name))
-  {
-    node = OgreAdaptor::Instance()->sceneMgr->getSceneNode(name);
-    obj = OgreAdaptor::Instance()->sceneMgr->getManualObject(name);
-    attached = true;
-  }
-  else
-  {
-    node = OgreAdaptor::Instance()->sceneMgr->getRootSceneNode()->createChildSceneNode(name);
-    obj = OgreAdaptor::Instance()->sceneMgr->createManualObject(name); 
-  }
-
-  node->setVisible(true);
-  obj->setVisible(true);
-
-  obj->clear();
-  obj->begin("Gazebo/Red", Ogre::RenderOperation::OT_LINE_LIST); 
-  obj->position(start.x, start.y, start.z); 
-  obj->position(end.x, end.y, end.z); 
-  obj->end(); 
-
-  if (!attached)
-    node->attachObject(obj);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Hide a visual
-void OgreCreator::SetVisible(const std::string &name, bool visible)
-{
-  if (OgreAdaptor::Instance()->sceneMgr->hasSceneNode(name))
-    OgreAdaptor::Instance()->sceneMgr->getSceneNode(name)->setVisible(visible);
-
-  if ( OgreAdaptor::Instance()->sceneMgr->hasManualObject(name))
-    OgreAdaptor::Instance()->sceneMgr->getManualObject(name)->setVisible(visible);
-}
-
-////////////////////////////////////////////////////////////////////////////////
 /// Remove a mesh by name
 void OgreCreator::RemoveMesh(const std::string &name)
 {
@@ -365,19 +129,18 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 // Create a window for Ogre
-Ogre::RenderWindow *OgreCreator::CreateWindow(Fl_Window *flWindow, unsigned int width, unsigned int height)
+Ogre::RenderWindow *OgreCreator::CreateWindow(RenderControl *wxWindow, unsigned int width, unsigned int height)
 {
   if (!Simulator::Instance()->GetRenderEngineEnabled())
     return NULL;
 
   Ogre::RenderWindow *win = NULL;
 
-  if (flWindow)
+  if (wxWindow)
   {
-    XSync(fl_display, false);
+    //XSync(fl_display, false);
+    win = OgreCreator::CreateWindow( wxWindow->GetOgreHandle(), width, height);
 
-    win = OgreCreator::CreateWindow( fl_display, fl_visual->screen, 
-        (int32_t)(Fl_X::i(flWindow)->xid), width, height);
     if (win)
       this->windows.push_back(win);
   }
@@ -387,37 +150,18 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 // Create a window for Ogre
-Ogre::RenderWindow *OgreCreator::CreateWindow(Display *display, int screen, 
-                                              int32_t winId, unsigned int width,                                              unsigned int height)
+Ogre::RenderWindow *OgreCreator::CreateWindow( const std::string ogreHandle,
+                                               unsigned int width,                                                             unsigned int height)
 {
   if (!Simulator::Instance()->GetRenderEngineEnabled())
     return NULL;
 
-  std::stringstream ogreHandle;
-
   Ogre::StringVector paramsVector;
   Ogre::NameValuePairList params;
   Ogre::RenderWindow *window = NULL;
 
-  /*std::string screenStr = DisplayString((long)display);
-  std::string::size_type dotPos = screenStr.find(".");
-  screenStr = screenStr.substr(dotPos+1, screenStr.size());
+  params["parentWindowHandle"] = ogreHandle;
 
-  int attrList[] = {GLX_RGBA, GLX_DOUBLEBUFFER, GLX_DEPTH_SIZE, 16, 
-                    GLX_STENCIL_SIZE, 16, None };
-  XVisualInfo *vi = glXChooseVisual(display, DefaultScreen((long)display), 
-                                    attrList);
-
-  ogreHandle << (unsigned long)display 
-             << ":" << screenStr 
-             << ":" << (unsigned long)winId 
-             << ":" << (unsigned long)vi;
-  */
-
-  ogreHandle << winId;
-
-  params["parentWindowHandle"] = ogreHandle.str();
-
   std::ostringstream stream;
   stream << "OgreWindow(" << windowCounter++ << ")";
 
@@ -442,8 +186,8 @@
   }
 
   window->setActive(true);
-  window->setVisible(true);
-  window->setAutoUpdated(true);
+  //window->setVisible(true);
+  window->setAutoUpdated(false);
 
   this->windows.push_back(window);
 
@@ -537,57 +281,20 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// Create a dynamic line
-OgreDynamicLines *OgreCreator::CreateDynamicLine(OgreDynamicRenderable::OperationType opType)
-{
-  if (!Simulator::Instance()->GetRenderEngineEnabled())
-    return NULL;
-
-  OgreDynamicLines *line = new OgreDynamicLines(opType);
-
-  this->lines.push_back( line );
-
-  return line;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Create a dynamic line
-void OgreCreator::DeleteDynamicLine(OgreDynamicLines* line)
-{
-  if (!Simulator::Instance()->GetRenderEngineEnabled())
-    return;
-
-  // delete instance from lines vector
-  for (std::list<OgreDynamicLines*>::iterator iter=this->lines.begin();iter!=this->lines.end();iter++)
-  {
-    if (*iter == line)
-    {
-      this->lines.erase(iter);
-      break;
-    }
-  }
-}
-
-////////////////////////////////////////////////////////////////////////////////
 // Update all the entities
 void OgreCreator::Update()
 {
   if (!Simulator::Instance()->GetRenderEngineEnabled())
     return;
 
-  std::list<OgreDynamicLines*>::iterator iter;
   std::list<OgreMovableText*>::iterator titer;
   std::list<Ogre::RenderWindow*>::iterator witer;
-  std::map<std::string, OgreVisual*>::iterator viter;
+  std::list<OgreVisual*>::iterator viter;
 
   // Update the text
   for (titer = this->text.begin(); titer != this->text.end(); titer++)
     (*titer)->Update();
 
-  // Update the lines
-  for (iter = this->lines.begin(); iter != this->lines.end(); iter++)
-    (*iter)->Update();
-
   // We only need this loop because we are using threads. The physics engine
   // can't reliably set the pose of the visuals when it's running in a 
   // separate thread.
@@ -597,13 +304,11 @@
     // Update the visuals
     for (viter = this->visuals.begin(); viter != this->visuals.end(); viter++)
     {
-      if (viter->second)
+      if (*viter)
       {
-        // lock in case the visual is being dynamically destroyed
-        //boost::recursive_mutex::scoped_lock lock(*Simulator::Instance()->GetMDMutex());
-        if (!viter->second->IsDirty())
+        if ( !(*viter)->IsDirty() )
           continue;
-        viter->second->SetToDirtyPose();
+        (*viter)->SetToDirtyPose();
       }
     }
   }
@@ -612,26 +317,34 @@
 ////////////////////////////////////////////////////////////////////////////////
 /// Create a new ogre visual 
 OgreVisual *OgreCreator::CreateVisual( const std::string &name,
-    OgreVisual *parent, Entity *owner)
+    OgreVisual *parent, Entity *owner, Scene *scene)
 {
   if (!Simulator::Instance()->GetRenderEngineEnabled())
     return NULL;
 
   OgreVisual *newVis = NULL;
-  std::map<std::string, OgreVisual*>::iterator iter;
+  std::list<OgreVisual*>::iterator iter;
 
-  iter = this->visuals.find(name);
-
-  if (iter == this->visuals.end())
+  std::string vis_name;
+  if (name.empty())
   {
-    newVis = new OgreVisual(parent, owner);
-    newVis->SetName(name);
-
-    this->visuals[name] = newVis;
+    unsigned int index = 0;
+    std::stringstream stream;
+    do 
+    {
+      stream.str("");
+      stream << "generic_visual_" << index++;
+    } while (this->GetVisual(stream.str()) != NULL);
+    vis_name = stream.str();
   }
   else
-    gzthrow(std::string("Name of ogre visual already exists: ") + name);
+    vis_name = name;
 
+  newVis = new OgreVisual(parent, owner, scene);
+  newVis->SetName(vis_name);
+
+  this->visuals.push_back( newVis );
+
   return newVis;
 }
 
@@ -639,12 +352,11 @@
 // Get a visual
 OgreVisual *OgreCreator::GetVisual( const std::string &name )
 {
-  std::map<std::string, OgreVisual*>::iterator iter;
-  iter = this->visuals.find(name);
+  std::list<OgreVisual*>::iterator iter;
+  for (iter = this->visuals.begin(); iter != this->visuals.end(); iter++)
+    if ( (*iter)->GetName() == name)
+      return (*iter);
 
-  if (iter != this->visuals.end())
-    return iter->second;
-
   return NULL;
 }
 
@@ -655,21 +367,8 @@
   if (!Simulator::Instance()->GetRenderEngineEnabled())
     return;
 
-  std::map<std::string, OgreVisual*>::iterator iter;
-
-  iter = this->visuals.find(visual->GetName());
-
-  if (iter != this->visuals.end() && iter->second != NULL)
-  {
-    delete iter->second;
-    iter->second = NULL;
-    this->visuals.erase(iter);
-  }
-  else
-  {
-    gzerr(0) << "Unknown visual[" << visual->GetName() << "]\n";
-  }
-
+  this->visuals.remove(visual);
+  delete visual;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: server/rendering/ViewController.cc
===================================================================
--- server/rendering/ViewController.cc	(revision 8976)
+++ server/rendering/ViewController.cc	(working copy)
@@ -5,8 +5,8 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 // Constructor
-ViewController::ViewController(OgreCamera *camera)
-  : camera(camera)
+ViewController::ViewController(OgreCamera *cam)
+  : camera(cam)
 {
 }
 
@@ -14,4 +14,5 @@
 /// Destructor
 ViewController::~ViewController()
 {
+  this->camera = NULL;
 }
Index: server/rendering/OgreVisual.cc
===================================================================
--- server/rendering/OgreVisual.cc	(revision 8976)
+++ server/rendering/OgreVisual.cc	(working copy)
@@ -26,6 +26,9 @@
 
 #include <boost/thread/recursive_mutex.hpp>
 
+#include "Events.hh"
+#include "OgreDynamicLines.hh"
+#include "Scene.hh"
 #include "SelectionObj.hh"
 #include "RTShaderSystem.hh"
 #include "MeshManager.hh"
@@ -46,17 +49,26 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 // Constructor
-OgreVisual::OgreVisual(OgreVisual *node, Entity *_owner)
-  : Common()
+OgreVisual::OgreVisual(OgreVisual *node, Entity *_owner, Scene *scene)
+  : Common(_owner)
 {
+  this->AddType(VISUAL);
+  this->transparency = 0.0;
+
   bool isStatic = false;
   Ogre::SceneNode *pnode = NULL;
   this->owner = _owner;
+  this->useRTShader = true;
 
+  if (scene == NULL)
+    this->scene = OgreAdaptor::Instance()->GetScene(0);
+  else
+    this->scene = scene;
+
   if (Simulator::Instance()->GetRenderEngineEnabled())
   {
     if (!node)
-      pnode = OgreAdaptor::Instance()->sceneMgr->getRootSceneNode();
+      pnode = this->scene->GetManager()->getRootSceneNode();
     else
       pnode = node->GetSceneNode();
   }
@@ -70,21 +82,24 @@
   this->visible = true;
   this->ConstructorHelper(pnode, isStatic);
 
-  this->ribbonTrail = (Ogre::RibbonTrail*)OgreAdaptor::Instance()->sceneMgr->createMovableObject("RibbonTrail");
+  this->ribbonTrail = (Ogre::RibbonTrail*)this->scene->GetManager()->createMovableObject("RibbonTrail");
   this->ribbonTrail->setMaterialName("Gazebo/Red");
   this->ribbonTrail->setTrailLength(200);
   this->ribbonTrail->setMaxChainElements(1000);
   this->ribbonTrail->setNumberOfChains(1);
   this->ribbonTrail->setVisible(false);
   this->ribbonTrail->setInitialWidth(0,0.05);
-  OgreAdaptor::Instance()->sceneMgr->getRootSceneNode()->attachObject(this->ribbonTrail);
+  this->scene->GetManager()->getRootSceneNode()->attachObject(this->ribbonTrail);
 
   RTShaderSystem::Instance()->AttachEntity(this);
+
+  this->updateTime = Simulator::Instance()->GetRealTime();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Constructor
 OgreVisual::OgreVisual (Ogre::SceneNode *node, bool isStatic)
+  : Common(NULL)
 {
   this->owner = NULL;
   this->ConstructorHelper(node, isStatic);
@@ -171,12 +186,37 @@
   delete this->materialNameP;
   delete this->castShadowsP;
 
+  // delete instance from lines vector
+  for (std::list<OgreDynamicLines*>::iterator iter=this->lines.begin();
+       iter!=this->lines.end();iter++)
+    delete *iter;
+  this->lines.clear();
+
   RTShaderSystem::Instance()->DetachEntity(this);
 
+  if (this->sceneNode != NULL)
+  {
+    if (this->boundingBoxNode != NULL)
+      this->sceneNode->removeAndDestroyChild( this->boundingBoxNode->getName() );
 
+    // loop through sceneNode an delete attached objects
+    for (int i = 0; i < this->sceneNode->numAttachedObjects(); i++)
+    {
+      Ogre::MovableObject* obj = this->sceneNode->getAttachedObject(i);
+      if (obj) delete obj;
+      obj = NULL;
+    }
+    this->sceneNode->detachAllObjects();
+
+    // delete works, but removeAndDestroyChild segfaults
+    delete this->sceneNode;
+    this->sceneNode = NULL;
+    //this->parentNode->removeAndDestroyChild( this->sceneNode->getName() );
+  }
+
   // Having this chunk of code causes a segfault when closing the
   // application.
-  if (this->parentNode != NULL)
+  /*if (this->parentNode != NULL)
   {
     if (this->sceneNode != NULL)
     {
@@ -197,7 +237,7 @@
       this->sceneNode = NULL;
       //this->parentNode->removeAndDestroyChild( this->sceneNode->getName() );
     }
-  }
+  }*/
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -311,7 +351,27 @@
 
 }
 
+////////////////////////////////////////////////////////////////////////////////
+/// Update the visual.
+void OgreVisual::Update()
+{
+  if (!this->visible)
+    return;
 
+  if (Simulator::Instance()->GetRealTime() - this->updateTime <= Time(0.2))
+    return;
+
+  std::list<OgreDynamicLines*>::iterator iter;
+
+  // Update the lines
+  for (iter = this->lines.begin(); iter != this->lines.end(); iter++)
+    (*iter)->Update();
+
+  this->updateTime = Simulator::Instance()->GetRealTime();
+}
+
+
+
 ////////////////////////////////////////////////////////////////////////////////
 // Save the visual in XML format
 void OgreVisual::Save(std::string &prefix, std::ostream &stream)
@@ -393,7 +453,7 @@
     return;
 
   if (!this->staticGeom)
-    this->staticGeom = OgreAdaptor::Instance()->sceneMgr->createStaticGeometry(this->sceneNode->getName() + "_Static");
+    this->staticGeom = this->scene->GetManager()->createStaticGeometry(this->sceneNode->getName() + "_Static");
 
   // Add the scene node to the static geometry
   this->staticGeom->addSceneNode(this->sceneNode);
@@ -511,7 +571,7 @@
 
   /*Ogre::Material::TechniqueIterator techniqueIt = this->myMaterial->getTechniqueIterator ();
 
-  while (techniqueIt.hasMoreElements ())
+  /*while (techniqueIt.hasMoreElements ())
   {
     Ogre::Technique *t = techniqueIt.getNext ();
     Ogre::Technique::PassIterator passIt = t->getPassIterator ();
@@ -608,7 +668,7 @@
     Ogre::MovableObject *obj = this->sceneNode->getAttachedObject(i);
 
     entity = dynamic_cast<Ogre::Entity*>(obj);
-    //simple = dynamic_cast<Ogre::SimpleRenderable*>(obj);
+
     if (!entity)
       continue;
 
@@ -621,7 +681,7 @@
       unsigned int techniqueCount, passCount;
       Ogre::Technique *technique;
       Ogre::Pass *pass;
-      Ogre::ColourValue sc, dc;
+      Ogre::ColourValue dc;
 
       for (techniqueCount = 0; techniqueCount < material->getNumTechniques(); 
            techniqueCount++)
@@ -648,6 +708,13 @@
 
 }
 
+////////////////////////////////////////////////////////////////////////////////
+/// Get the transparency
+float OgreVisual::GetTransparency()
+{
+  return this->transparency;
+}
+
 void OgreVisual::SetHighlight(bool highlight)
 {
   boost::recursive_mutex::scoped_lock lock(*this->mutex);
@@ -655,42 +722,6 @@
   // Stop here if the rendering engine has been disabled
   if (!Simulator::Instance()->GetRenderEngineEnabled())
     return;
-
-  /*
-  #include <OgreParticleSystem.h>
-  #include <iostream>
-  Ogre::ParticleSystem *effect =OgreAdaptor::Instance()->sceneMgr->createParticleSystem(this->parentNode->getName(), "Gazebo/Aureola");
-  OgreAdaptor::Instance()->sceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(effect);
-  //this->sceneNode->createChildSceneNode()->attachObject(effect);
-  Ogre::ParticleSystem::setDefaultNonVisibleUpdateTimeout(5);
-  std::cout << this->parentNode->getName() << std::endl;
-  */
-
-//FIXME:  Modifying selfIllumination is invasive to the material definition of the user
-// Choose other effect.
-/*
-  Ogre::Technique *t;
-  Ogre::Material::TechniqueIterator techniqueIt = this->myMaterial->getTechniqueIterator();
-  while ( techniqueIt.hasMoreElements() )
-  {
-    t = techniqueIt.getNext ();
-    Ogre::Technique::PassIterator passIt = t->getPassIterator ();
-
-    while (passIt.hasMoreElements ())
-    {
-      if (highlight)
-      {
-        passIt.peekNext ()->setSelfIllumination (1,1,1);
-      }
-      else
-      {
-        passIt.peekNext ()->setSelfIllumination (0,0,0);
-      }
-      passIt.moveNext ();
-    }
-  }
-  */
-
 }
 
 
@@ -729,6 +760,13 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+/// Toggle whether this visual is visible
+void OgreVisual::ToggleVisible()
+{
+  this->SetVisible( !this->GetVisible() );
+}
+
+////////////////////////////////////////////////////////////////////////////////
 /// Get whether the visual is visible
 bool OgreVisual::GetVisible() const
 {
@@ -785,6 +823,7 @@
 {
   boost::recursive_mutex::scoped_lock lock(*this->mutex);
 
+
   // Stop here if the rendering engine has been disabled
   if (!Simulator::Instance()->GetRenderEngineEnabled())
     return;
@@ -1070,6 +1109,7 @@
   RTShaderSystem::Instance()->UpdateShaders();
 }
 
+////////////////////////////////////////////////////////////////////////////////
 void OgreVisual::SetRibbonTrail(bool value)
 {
   if (value)
@@ -1086,3 +1126,57 @@
   }
   this->ribbonTrail->setVisible(value);
 }
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the size of the bounding box
+Vector3 OgreVisual::GetBoundingBoxSize() const
+{
+  this->sceneNode->_updateBounds();
+  Ogre::AxisAlignedBox box = this->sceneNode->_getWorldAABB();
+  Ogre::Vector3 size = box.getSize();
+  return Vector3(size.x, size.y, size.z);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Set whether to use the RT Shader system
+void OgreVisual::SetUseRTShader(bool value)
+{
+  this->useRTShader = value;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get whether to user the RT shader system
+bool OgreVisual::GetUseRTShader() const
+{
+  return this->useRTShader;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Add a line to the visual
+OgreDynamicLines *OgreVisual::AddDynamicLine(OgreDynamicRenderable::OperationType opType)
+{
+  Events::ConnectRenderStartSignal( boost::bind(&OgreVisual::Update, this) );
+
+  OgreDynamicLines *line = new OgreDynamicLines(opType);
+  this->lines.push_back(line);
+  this->AttachObject(line);
+  return line;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Delete a dynamic line
+void OgreVisual::DeleteDynamicLine(OgreDynamicLines *line)
+{
+  // delete instance from lines vector
+  for (std::list<OgreDynamicLines*>::iterator iter=this->lines.begin();iter!=this->lines.end();iter++)
+  {
+    if (*iter == line)
+    {
+      this->lines.erase(iter);
+      break;
+    }
+  }
+
+  if (this->lines.size() == 0)
+    Events::DisconnectRenderStartSignal( boost::bind(&OgreVisual::Update, this) );
+}
Index: server/rendering/SelectionObj.cc
===================================================================
--- server/rendering/SelectionObj.cc	(revision 8976)
+++ server/rendering/SelectionObj.cc	(working copy)
@@ -1,5 +1,6 @@
 #include <Ogre.h>
 #include <boost/lexical_cast.hpp>
+#include "Scene.hh"
 #include "OgreCreator.hh"
 #include "MeshManager.hh"
 #include "Simulator.hh"
@@ -20,14 +21,14 @@
 SelectionObj::~SelectionObj()
 {
   if (this->node != NULL)
-    OgreAdaptor::Instance()->sceneMgr->getRootSceneNode()->removeAndDestroyChild( this->node->getName() );
+    OgreAdaptor::Instance()->GetScene(0)->GetManager()->getRootSceneNode()->removeAndDestroyChild( this->node->getName() );
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Load
 void SelectionObj::Load()
 {
-  Ogre::SceneNode *pnode = OgreAdaptor::Instance()->sceneMgr->getRootSceneNode();
+  Ogre::SceneNode *pnode = OgreAdaptor::Instance()->GetScene(0)->GetManager()->getRootSceneNode();
   this->node = pnode->createChildSceneNode("selection_node");
 
   Ogre::SceneNode *rotNode = this->node->createChildSceneNode("rot_node");
Index: server/rendering/RTShaderSystem.cc
===================================================================
--- server/rendering/RTShaderSystem.cc	(revision 8976)
+++ server/rendering/RTShaderSystem.cc	(working copy)
@@ -28,6 +28,7 @@
 #include <sys/stat.h>
 #include <iostream>
 
+#include "Scene.hh"
 #include "OgreVisual.hh"
 #include "World.hh"
 #include "GazeboError.hh"
@@ -50,6 +51,7 @@
 /// Destructor
 RTShaderSystem::~RTShaderSystem()
 {
+  this->Fini();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -83,16 +85,32 @@
       this->shaderGenerator->addSceneManager(
           OgreAdaptor::Instance()->GetSceneMgr(s));
     }*/
+
+    /*for (unsigned int s=0; s < OgreAdaptor::Instance()->GetSceneMgrCount();s++)
+    {
+      std::string sceneName = OgreAdaptor::Instance()->GetSceneMgr(s)->getName() + Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME;
+      std::cout << "SceneName[" << sceneName << "]\n";
+
+      // Set the scene manager
+      this->shaderGenerator->addSceneManager(
+          OgreAdaptor::Instance()->GetSceneMgr(s));
+    }*/
+
+    this->initialized = true;
   }
   else
     gzerr(0) << "RT Shader system failed to initialize\n";
-
 #endif
 }
 
+////////////////////////////////////////////////////////////////////////////////
+// Finalize
 void RTShaderSystem::Fini()
 {
 #if INCLUDE_RTSHADER && OGRE_VERSION_MAJOR >= 1 && OGRE_VERSION_MINOR >= MINOR_VERSION
+  if (!this->initialized)
+    return;
+
   // Restore default scheme.
   Ogre::MaterialManager::getSingleton().setActiveScheme(Ogre::MaterialManager::DEFAULT_SCHEME_NAME);
 
@@ -106,14 +124,25 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+// Add a scene manager
+void RTShaderSystem::AddScene(Scene *scene)
+{
+#if INCLUDE_RTSHADER && OGRE_VERSION_MAJOR >= 1 && OGRE_VERSION_MINOR >= MINOR_VERSION
+  // Set the scene manager
+  this->shaderGenerator->addSceneManager( scene->GetManager() );
+  this->shaderGenerator->createScheme( scene->GetName() +Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME  );
+#endif
+}
+
+////////////////////////////////////////////////////////////////////////////////
 // Set an Ogre::Entity to use RT shaders
 void RTShaderSystem::AttachEntity(OgreVisual *vis)
 {
   if (!this->initialized)
     return;
 
+  this->entities.push_back(vis);
   this->GenerateShaders(vis);
-  this->entities.push_back(vis);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -127,6 +156,19 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+/// Set a viewport to use shaders
+void RTShaderSystem::AttachViewport(OgreCamera *camera)
+{
+#if OGRE_VERSION_MAJOR == 1 && OGRE_VERSION_MINOR >= 7
+  camera->GetOgreCamera()->getViewport()->setMaterialScheme(
+      camera->GetScene()->GetName() +
+      Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME);
+
+#endif
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
 /// Update the shaders
 void RTShaderSystem::UpdateShaders()
 {
@@ -145,6 +187,8 @@
 void RTShaderSystem::GenerateShaders(OgreVisual *vis)
 {
 #if INCLUDE_RTSHADER && OGRE_VERSION_MAJOR >= 1 && OGRE_VERSION_MINOR >= MINOR_VERSION
+  if (!this->initialized || !vis->GetUseRTShader())
+    return;
 
   for (unsigned int k=0; k < vis->sceneNode->numAttachedObjects(); k++)
   {
@@ -159,17 +203,21 @@
       const Ogre::String& curMaterialName = curSubEntity->getMaterialName();
       bool success;
 
+      for (unsigned int s=0; s < OgreAdaptor::Instance()->GetSceneCount(); s++)
+      {
+
         // Create the shader based technique of this material.
         success = this->shaderGenerator->createShaderBasedTechnique(
             curMaterialName,
             Ogre::MaterialManager::DEFAULT_SCHEME_NAME,
+            OgreAdaptor::Instance()->GetScene(s)->GetName() + 
             Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME);
 
 
         // Setup custom shader sub render states according to current setup.
         if (success)
         {
-          Ogre::MaterialPtr curMaterial =
+          Ogre::MaterialPtr curMaterial = 
             Ogre::MaterialManager::getSingleton().getByName(curMaterialName);
 
           Ogre::Pass* curPass = curMaterial->getTechnique(0)->getPass(0);
@@ -177,9 +225,10 @@
           // Grab the first pass render state. 
           // NOTE:For more complicated samples iterate over the passes and build
           // each one of them as desired.
-          Ogre::RTShader::RenderState* renderState =
+          Ogre::RTShader::RenderState* renderState = 
             this->shaderGenerator->getRenderState(
-                Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME,
+                OgreAdaptor::Instance()->GetScene(s)->GetName() + 
+                Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME, 
                 curMaterialName, 0);
 
           // Remove all sub render states.
@@ -227,7 +276,9 @@
 
       // Invalidate this material in order to re-generate its shaders.
       this->shaderGenerator->invalidateMaterial(
-          Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME, curMaterialName);
+          OgreAdaptor::Instance()->GetScene(s)->GetName() + 
+          Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME, curMaterialName); 
+      }
     }
   }
 #endif
@@ -318,4 +369,86 @@
 }
 
 
+void RTShaderSystem::ApplyShadows()
+{
+  Ogre::SceneManager *sceneMgr;
+  Ogre::RTShader::RenderState* schemeRenderState;
 
+  sceneMgr = this->shaderGenerator->getActiveSceneManager();
+
+	schemeRenderState = this->shaderGenerator->getRenderState(
+      OgreAdaptor::Instance()->GetScene(0)->GetName() + 
+      Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME);
+
+  sceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED);
+  sceneMgr->setShadowFarDistance(1000);
+  sceneMgr->setShadowTexturePixelFormat(Ogre::PF_FLOAT16_R);
+  sceneMgr->setShadowColour(Ogre::ColourValue(0.5, 0.5, 0.5));
+
+
+  Ogre::MaterialManager::getSingleton().setDefaultTextureFiltering(Ogre::TFO_ANISOTROPIC);
+
+  // 3 textures per directional light
+  sceneMgr->setShadowTextureCountPerLightType(Ogre::Light::LT_POINT, 3);
+  sceneMgr->setShadowTextureSettings(1024, 3, Ogre::PF_FLOAT16_R);
+  sceneMgr->setShadowTextureSelfShadow(true);
+
+  // Disable fog on the caster pass.
+  /*Ogre::MaterialPtr passCaterMaterial
+    //= Ogre::MaterialManager::getSingleton().getByName("PSSM/shadow_caster");
+    = Ogre::MaterialManager::getSingleton().getByName("pssm_vsm_caster");
+  Ogre::Pass* pssmCasterPass
+    = passCaterMaterial->getTechnique(0)->getPass(0);
+  pssmCasterPass->setFog(true);
+*/
+    
+  // shadow camera setup
+  Ogre::PSSMShadowCameraSetup* pssmSetup = new Ogre::PSSMShadowCameraSetup();
+  pssmSetup->calculateSplitPoints(3, 0.1, 1000);
+  pssmSetup->setSplitPadding(.5);
+  pssmSetup->setUseSimpleOptimalAdjust(true);
+  pssmSetup->setOptimalAdjustFactor(0, 3);
+  pssmSetup->setOptimalAdjustFactor(1, 1);
+  pssmSetup->setOptimalAdjustFactor(2, 0.5);
+
+  sceneMgr->setShadowCameraSetup(Ogre::ShadowCameraSetupPtr(pssmSetup));
+
+  // Set up caster material - this is just a standard depth/shadow map caster
+  //sceneMgr->setShadowTextureCasterMaterial("PSSM/shadow_caster");
+  sceneMgr->setShadowTextureCasterMaterial("pssm_vsm_caster");
+  sceneMgr->setShadowCasterRenderBackFaces(false);
+
+  Ogre::RTShader::SubRenderState *subRenderState;
+  Ogre::RTShader::IntegratedPSSM3 *pssm3SubRenderState;
+  Ogre::RTShader::IntegratedPSSM3::SplitPointList dstSplitPoints;
+
+  subRenderState = this->shaderGenerator->createSubRenderState(Ogre::RTShader::IntegratedPSSM3::Type);	
+  pssm3SubRenderState = static_cast<Ogre::RTShader::IntegratedPSSM3*>(subRenderState);
+  const Ogre::PSSMShadowCameraSetup::SplitPointList& srcSplitPoints = pssmSetup->getSplitPoints();
+
+  for (unsigned int i=0; i < srcSplitPoints.size(); ++i)
+  {
+    dstSplitPoints.push_back(srcSplitPoints[i]);
+  }
+
+  pssm3SubRenderState->setSplitPoints(dstSplitPoints);
+  schemeRenderState->addTemplateSubRenderState(subRenderState);		
+
+  // set the receiver params for any materials that need the split point information
+  Ogre::Vector4 splitPoints;
+  for (int i = 0; i < srcSplitPoints.size(); ++i)
+  {
+    splitPoints[i] = srcSplitPoints[i];
+  }
+
+  Ogre::MaterialPtr mat = Ogre::MaterialManager::getSingleton().getByName("Gazebo/GrayGrid");
+  for(int i = 0; i < mat->getNumTechniques(); ++i) 
+  {
+    mat->getTechnique(i)->getPass(1)->getFragmentProgramParameters()->setNamedConstant("pssmSplitPoints", splitPoints);
+  }
+
+  this->shaderGenerator->invalidateScheme(
+      OgreAdaptor::Instance()->GetScene(0)->GetName() + 
+      Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME);
+
+}
Index: server/rendering/Light.hh
===================================================================
--- server/rendering/Light.hh	(revision 8976)
+++ server/rendering/Light.hh	(working copy)
@@ -1,3 +1,28 @@
+/*
+ *  Gazebo - Outdoor Multi-Robot Simulator
+ *  Copyright (C) 2003
+ *     Nate Koenig & Andrew Howard
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/* Desc: A Light
+ * Author: Nate Koenig
+ * Date: 15 July 2003
+ */
+
 #ifndef LIGHT_HH
 #define LIGHT_HH
 
@@ -4,12 +29,14 @@
 #include <string>
 #include <iostream>
 
+#include "Color.hh"
 #include "Param.hh"
 #include "Entity.hh"
 
 namespace Ogre
 {
   class Light;
+  class SceneManager;
 }
 
 namespace gazebo
@@ -17,15 +44,16 @@
   class OgreVisual;
   class XMLConfigNode;
   class OgreDynamicLines;
+  class Scene;
 
   /// \brief Wrapper around an ogre light source
   class Light : public Entity
   {
     /// \brief Constructor
-    private: Light(Entity *parent);
+    public: Light(Entity *parent, unsigned int sceneIndex);
 
     /// \brief Destructor
-    private: virtual ~Light();
+    public: virtual ~Light();
 
     /// \brief Load the light
     public: void Load(XMLConfigNode *node);
@@ -37,6 +65,9 @@
     ///        the gui
     public: virtual bool SetSelected( bool s );
 
+    // \brief Toggle light visual visibility
+    public: void ToggleShowVisual();
+
     /// \brief Set whether to show the visual
     public: void ShowVisual(bool s);
 
@@ -44,10 +75,10 @@
     public: void SetLightType(const std::string &type);
 
     /// \brief Set the diffuse
-    public: void SetDiffuseColor(const Vector3 &color);
+    public: void SetDiffuseColor(const Color &color);
 
     /// \brief Set the specular color
-    public: void SetSpecularColor(const Vector3 &color);
+    public: void SetSpecularColor(const Color &color);
 
     /// \brief Set the direction
     public: void SetDirection(const Vector3 &dir);
@@ -73,6 +104,10 @@
     /// \private Helper node to create a visual representation of the light
     private: void CreateVisual();
 
+    private: void SetupShadows();
+
+    protected: virtual void OnPoseChange() {}
+
     /// The OGRE light source
     private: Ogre::Light *light;
 
@@ -81,8 +116,8 @@
     private: OgreDynamicLines *line;
 
     private: ParamT<std::string> *lightTypeP;
-    private: ParamT<Vector3> *diffuseP;
-    private: ParamT<Vector3> *specularP;
+    private: ParamT<Color> *diffuseP;
+    private: ParamT<Color> *specularP;
     private: ParamT<Vector3> *directionP;
     private: ParamT<Vector3> *attenuationP;
     private: ParamT<double> *rangeP;
@@ -92,8 +127,7 @@
     private: ParamT<double> *spotFalloffP;
 
     private: static unsigned int lightCounter;
-
-    private: friend class OgreCreator;
+    private: Scene *scene;
   };
 }
 #endif
Index: server/rendering/Image.cc
===================================================================
--- server/rendering/Image.cc	(revision 8976)
+++ server/rendering/Image.cc	(working copy)
@@ -103,26 +103,25 @@
       {
         closedir(dir);
 
-        std::string fullName = (((*piter)+"/")+filename);
-        //std::cout << "searching file[" << fullName << "]\n";
+        this->fullName = (((*piter)+"/")+filename);
         // if file exist
-        if (stat(fullName.c_str(), &st) == 0)
+        if (stat(this->fullName.c_str(), &st) == 0)
         {
-          FREE_IMAGE_FORMAT fifmt = FreeImage_GetFIFFromFilename(fullName.c_str());
+          FREE_IMAGE_FORMAT fifmt = FreeImage_GetFIFFromFilename(this->fullName.c_str());
 
           if (this->bitmap)
             FreeImage_Unload(this->bitmap);
           this->bitmap = NULL;
 
           if (fifmt == FIF_PNG)
-            this->bitmap = FreeImage_Load(fifmt, fullName.c_str(), PNG_DEFAULT);
+            this->bitmap = FreeImage_Load(fifmt, this->fullName.c_str(), PNG_DEFAULT);
           else if (fifmt == FIF_JPEG)
-            this->bitmap = FreeImage_Load(fifmt, fullName.c_str(), JPEG_DEFAULT);
+            this->bitmap = FreeImage_Load(fifmt, this->fullName.c_str(), JPEG_DEFAULT);
           else if (fifmt == FIF_BMP)
-            this->bitmap = FreeImage_Load(fifmt, fullName.c_str(), BMP_DEFAULT);
+            this->bitmap = FreeImage_Load(fifmt, this->fullName.c_str(), BMP_DEFAULT);
           else
           {
-            gzerr(5) << "Unknown image format[" << fullName << "]\n";
+            gzerr(5) << "Unknown image format[" << this->fullName << "]\n";
             return -1;
           }
 
@@ -395,3 +394,12 @@
 {
   return this->bitmap != NULL;
 }
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the full filename of the image
+std::string Image::GetFilename() const
+{
+  return this->fullName;
+}
+
+
Index: server/rendering/CameraManager.cc
===================================================================
--- server/rendering/CameraManager.cc	(revision 8976)
+++ server/rendering/CameraManager.cc	(working copy)
@@ -92,7 +92,7 @@
 
   for (iter = this->cameras.begin(); iter != this->cameras.end(); iter++)
   {
-    if ((*iter)->GetCameraName() == cameraName)
+    if ((*iter)->GetName() == cameraName)
       return (*iter);
   }
 
Index: server/rendering/OgreHeightmap.cc
===================================================================
--- server/rendering/OgreHeightmap.cc	(revision 8976)
+++ server/rendering/OgreHeightmap.cc	(working copy)
@@ -29,6 +29,7 @@
 #include <string.h>
 #include <math.h>
 
+#include "Scene.hh"
 #include "Image.hh"
 #include "GazeboError.hh"
 #include "OgreAdaptor.hh"
@@ -39,8 +40,9 @@
 
 //////////////////////////////////////////////////////////////////////////////
 // Constructor
-OgreHeightmap::OgreHeightmap()
+OgreHeightmap::OgreHeightmap(unsigned int sceneIndex)
 {
+  this->scene = OgreAdaptor::Instance()->GetScene(sceneIndex);
 }
 
 
@@ -48,7 +50,7 @@
 // Destructor
 OgreHeightmap::~OgreHeightmap()
 {
-  Simulator::Instance()->GetRenderEngine()->sceneMgr->destroyQuery(this->rayQuery);
+  this->scene->GetManager()->destroyQuery(this->rayQuery);
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -160,17 +162,17 @@
     new Ogre::MemoryDataStream(mstr,strlen(mstr)) );
 
   // Set the static terrain in Ogre
-  OgreAdaptor::Instance()->sceneMgr->setWorldGeometry(dataStream);
+  this->scene->GetManager()->setWorldGeometry(dataStream);
 
   // HACK to make the terrain oriented properly
-  Ogre::SceneNode *tnode = OgreAdaptor::Instance()->sceneMgr->getSceneNode("Terrain");
+  Ogre::SceneNode *tnode = this->scene->GetManager()->getSceneNode("Terrain");
   tnode->pitch(Ogre::Degree(90));
   tnode->translate(Ogre::Vector3(-this->terrainSize.x*0.5, this->terrainSize.y*0.5, 0));
 
   // Setup the ray scene query, which is used to determine the heights of
   // the vertices for ODE
   this->ray = Ogre::Ray(Ogre::Vector3::ZERO, Ogre::Vector3::NEGATIVE_UNIT_Y);
-  this->rayQuery = OgreAdaptor::Instance()->sceneMgr->createRayQuery(this->ray);
+  this->rayQuery = this->scene->GetManager()->createRayQuery(this->ray);
   this->rayQuery->setQueryTypeMask(Ogre::SceneManager::WORLD_GEOMETRY_TYPE_MASK);
   this->rayQuery->setWorldFragmentType(Ogre::SceneQuery::WFT_SINGLE_INTERSECTION);
 
Index: server/rendering/OrbitViewController.hh
===================================================================
--- server/rendering/OrbitViewController.hh	(revision 8976)
+++ server/rendering/OrbitViewController.hh	(working copy)
@@ -6,6 +6,8 @@
 
 namespace gazebo
 {
+  class OgreVisual;
+
   class OrbitViewController : public ViewController
   {
     /// \brief Constructor
@@ -20,9 +22,23 @@
     /// \brief Handle a mouse event
     public: virtual void HandleMouseEvent(const MouseEvent &event);
 
+    /// \brief Get the type name of this view controller
+    public: static std::string GetTypeString() {return "OrbitViewController";}
+
+    /// \brief Translate the focal point
+    private: void Translate(Vector3 vec);
+
+    /// \brief Normalize yaw value
+    private: void NormalizeYaw(float &v);
+
+    /// \brief Normalize pitch value
+    private: void NormalizePitch(float &v);
+
     private: float yaw, pitch;
     private: float distance;
     private: Vector3 focalPoint;
+
+    private: OgreVisual *refVisual;
   };
 }
 
Index: server/rendering/Color.hh
===================================================================
--- server/rendering/Color.hh	(revision 8976)
+++ server/rendering/Color.hh	(working copy)
@@ -30,6 +30,8 @@
 #include <iostream>
 #include "Vector3.hh"
 
+#include <OGRE/OgreColourValue.h>
+
 namespace gazebo
 {
 
@@ -72,16 +74,19 @@
     public: float operator[](unsigned int index);
 
     /// \brief Get the red color
-    public: float R();
+    public: float R() const;
 
     /// \brief Get the green color
-    public: float G();
+    public: float G() const;
 
     /// \brief Get the blue color
-    public: float B();
+    public: float B() const;
 
     /// \brief Get the alpha color
-    public: float A();
+    public: float A() const;
+
+    /// \brief Return the equivalent ogre color
+    public: Ogre::ColourValue GetOgreColor() const;
   
     // Addition operators
     public: Color operator+( const Color &pt ) const;
@@ -110,13 +115,21 @@
     /// Clamp the color values
     private: void Clamp();
 
- 
     // Ostream operator
-    public: friend std::ostream &operator<< (std::ostream &out, const Color &pt) {
+    public: friend std::ostream &operator<< (std::ostream &out, const Color &pt)    {
       out << pt.r << " " << pt.g << " " << pt.b << " " << pt.a;
       return out; 
     }
 
+    // Istream operator
+    public: friend std::istream &operator>> (std::istream &in, Color &pt)
+    { 
+      // Skip white spaces
+      in.setf( std::ios_base::skipws );
+      in >> pt.r >> pt.g >> pt.b >> pt.a;
+      return in; 
+    }
+
     // The values
     private: float r, g, b, a;
   };
Index: server/rendering/CMakeLists.txt
===================================================================
--- server/rendering/CMakeLists.txt	(revision 8976)
+++ server/rendering/CMakeLists.txt	(working copy)
@@ -26,6 +26,9 @@
              ViewController.cc
              FPSViewController.cc
              OrbitViewController.cc
+             Grid.cc
+             Scene.cc
+             RenderState.cc
 )
 
 set (headers OgreMovableText.hh
@@ -49,6 +52,9 @@
              ViewController.hh
              FPSViewController.hh
              OrbitViewController.hh
+             Grid.hh
+             Scene.hh
+             RenderState.hh
 )
 
 add_library(gazebo_rendering SHARED ${sources})
@@ -60,6 +66,6 @@
     ${CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE}})
 endif (CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE})
 
-target_link_libraries( gazebo_rendering ${OGRE_LIBRARIES} X11)
+target_link_libraries( gazebo_rendering ${OGRE_LIBRARIES} X11 glut profiler)
 install ( TARGETS gazebo_rendering DESTINATION ${CMAKE_INSTALL_PREFIX}/lib )
 APPEND_TO_SERVER_HEADERS(${headers})
Index: server/rendering/OgreDynamicLines.cc
===================================================================
--- server/rendering/OgreDynamicLines.cc	(revision 8976)
+++ server/rendering/OgreDynamicLines.cc	(working copy)
@@ -32,7 +32,6 @@
 
 #include "GazeboError.hh"
 #include "OgreDynamicLines.hh"
-#include "OgreCreator.hh"
 
 using namespace gazebo;
 
@@ -47,7 +46,6 @@
 
 OgreDynamicLines::~OgreDynamicLines()
 {
-  OgreCreator::Instance()->DeleteDynamicLine(this);
 }
 
 /// Returns "gazebo::ogredynamicslines"

Property changes on: server/rendering/Material.cc
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /code/gazebo/branches/wx/server/rendering/Material.cc:r8807-8927

Index: server/rendering/UserCamera.hh
===================================================================
--- server/rendering/UserCamera.hh	(revision 8976)
+++ server/rendering/UserCamera.hh	(working copy)
@@ -37,14 +37,14 @@
 
 namespace gazebo
 {
-  class GLWindow;
+  class RenderControl;
   class XMLConfigNode;
   class OgreVisual;
 
   class UserCamera : public OgreCamera
   {
     /// \brief Constructor
-    public: UserCamera( GLWindow *parentWindow);
+    public: UserCamera( RenderControl *parentWindow, unsigned int sceneIndex);
 
     /// \brief Destructor
     public: virtual ~UserCamera();
@@ -55,17 +55,15 @@
     /// \brief Initialize
     public: void Init();
 
-    public: void SetCamera( OgreCamera *cam );
+    /// \brief Render the camera
+    public: virtual void Render();
 
-    /// \brief Update
-    public: void Update();
+    /// \brief Post render
+    public: virtual void PostRender();
 
     /// \brief Finialize
     public: void Fini();
   
-    /// \brief Get the name of the camera
-    public: std::string GetName() const;
-
     /// \brief Resize the camera
     public: void Resize(unsigned int w, unsigned int h);
 
@@ -81,12 +79,12 @@
     /// \brief Get the ogre window
     public: Ogre::RenderWindow *GetWindow();
 
+    /// \brief Toggle whether to show the visual
+    private: void ToggleShowVisual();
+
     /// \brief Set whether to show the visual
     private: void ShowVisual(bool s);
 
-    /// Pointer to the viewport
-    protected: Ogre::Viewport *viewport;
-
     /// Pointer to the render window
     private: Ogre::RenderWindow *window;
 
Index: server/rendering/Light.cc
===================================================================
--- server/rendering/Light.cc	(revision 8976)
+++ server/rendering/Light.cc	(working copy)
@@ -1,6 +1,34 @@
+/*
+ *  Gazebo - Outdoor Multi-Robot Simulator
+ *  Copyright (C) 2003
+ *     Nate Koenig & Andrew Howard
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+/* Desc: A Light
+ * Author: Nate Koenig
+ * Date: 15 July 2003
+ */
+
 #include <Ogre.h>
 #include <boost/bind.hpp>
 
+#include "Events.hh"
+#include "Scene.hh"
+#include "RTShaderSystem.hh"
 #include "World.hh"
 #include "Model.hh"
 #include "OgreDynamicLines.hh"
@@ -19,14 +47,17 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Constructor
-Light::Light(Entity *parent)
+Light::Light(Entity *parent, unsigned int sceneIndex)
   : Entity(parent)
 {
-  this->type = Entity::LIGHT;
+  this->AddType(LIGHT);
+  this->scene = OgreAdaptor::Instance()->GetScene(sceneIndex);
 
   std::ostringstream stream;
 
-  stream << this->parent->GetName() << "_LIGHT" << this->lightCounter;
+  if (parent)
+    stream << parent->GetName() << "_";
+  stream << "LIGHT" << this->lightCounter;
   this->SetName(stream.str());
 
   this->lightCounter++;
@@ -35,10 +66,10 @@
   this->lightTypeP = new ParamT<std::string>("type", std::string("point"), 1);
   this->lightTypeP->Callback(&Light::SetLightType, this);
 
-  this->diffuseP  = new ParamT<Vector3>("diffuseColor", Vector3(.5, .5, .5), 0);
+  this->diffuseP  = new ParamT<Color>("diffuseColor", Color(.5, .5, .5, 1), 0);
   this->diffuseP->Callback(&Light::SetDiffuseColor, this);
 
-  this->specularP = new ParamT<Vector3>("specularColor", Vector3(.1, .1, .1), 0);
+  this->specularP = new ParamT<Color>("specularColor", Color(.1, .1, .1), 0);
   this->specularP->Callback(&Light::SetSpecularColor, this);
 
   this->directionP  = new ParamT<Vector3>("direction", Vector3(0, 0, -1), 0);
@@ -50,7 +81,7 @@
   this->spotInnerAngleP = new ParamT<double>("innerAngle", 10, 0);
   this->spotInnerAngleP->Callback(&Light::SetSpotInnerAngle, this);
 
-  this->spotOutterAngleP = new ParamT<double>("outterAngle", 5, 0);
+  this->spotOutterAngleP = new ParamT<double>("outerAngle", 20, 0);
   this->spotOutterAngleP->Callback(&Light::SetSpotOutterAngle, this);
 
   this->spotFalloffP = new ParamT<double>("falloff", 1, 0);
@@ -63,8 +94,20 @@
   this->castShadowsP->Callback(&Light::SetCastShadows, this);
   Param::End();
 
+  Events::ConnectShowLightsSignal(boost::bind(&Light::ToggleShowVisual, this));
 
-  World::Instance()->ConnectShowLightsSignal( boost::bind(&Light::ShowVisual, this, _1) );
+  try
+  {
+    this->light = this->scene->GetManager()->createLight(this->GetName());
+  }
+  catch (Ogre::Exception e)
+  {
+
+    gzthrow("Ogre Error:" << e.getFullDescription() << "\n" << \
+        "Unable to create a light");
+  }
+
+  RTShaderSystem::Instance()->UpdateShaders();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -72,10 +115,9 @@
 Light::~Light()
 {
   if (this->light)
-    OgreAdaptor::Instance()->sceneMgr->destroyLight(this->GetName());
-    
-  delete this->line;
-  delete this->visual;
+  {
+    this->scene->GetManager()->destroyLight(this->GetName());
+  }
 
   delete this->lightTypeP;
   delete this->diffuseP;
@@ -87,6 +129,7 @@
   delete this->spotInnerAngleP;
   delete this->spotOutterAngleP;
   delete this->spotFalloffP;
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -96,17 +139,6 @@
   Vector3 vec;
   double range,constant,linear,quad;
 
-  try
-  {
-    this->light = OgreAdaptor::Instance()->sceneMgr->createLight(
-        this->GetName());
-  }
-  catch (Ogre::Exception e)
-  {
-    gzthrow("Ogre Error:" << e.getFullDescription() << "\n" << \
-        "Unable to create a light on " + this->parent->GetName());
-  }
-
   this->lightTypeP->Load(node);
   this->diffuseP->Load(node);
   this->specularP->Load(node);
@@ -129,18 +161,23 @@
   this->SetSpotOutterAngle(**this->spotOutterAngleP);
   this->SetSpotFalloff(**this->spotFalloffP);
 
+  //this->light->setSpotlightRange(Ogre::Radian(20), Ogre::Radian(40),32.0), 
+  //this->light->setSpotlightInnerAngle( Ogre::Radian(Ogre::Degree(20)) );
+  //this->light->setSpotlightOuterAngle( Ogre::Radian(Ogre::Degree(40)) ); 
+
   // TODO: More options for Spot lights, etc.
   //  options for spotlights
   /*if ((**this->lightTypeP) == "spot")
   {
-    vec = node->GetVector3("spotCone", Vector3(5.0, 10.0, 1.0));
-    this->light->setSpotlightRange(Ogre::Radian(Ogre::Degree(vec.x)), 
-        Ogre::Radian(Ogre::Degree(vec.y)), vec.z);
+    vec = node->GetVector3("spotCone", Vector3(30.0, 65.0, 1.0));
+    this->light->setSpotlightRange(Ogre::Degree(vec.x), 
+                                   Ogre::Degree(vec.y), vec.z);
   }*/
 
-  this->parent->GetVisualNode()->AttachObject(light);
+  this->visualNode->AttachObject(light);
 
   this->CreateVisual();
+  this->SetupShadows();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -169,60 +206,96 @@
   if (this->light->getType() == Ogre::Light::LT_DIRECTIONAL)
     return;
 
-  this->visual = new OgreVisual(this->parent->GetVisualNode());
-
   // The lines draw a visualization of the camera
-  this->line = OgreCreator::Instance()->CreateDynamicLine(
+  this->line = this->visualNode->AddDynamicLine(
       OgreDynamicRenderable::OT_LINE_LIST);
 
-  float s=0.1;
-  this->line->AddPoint(Vector3(-s,-s,0));
-  this->line->AddPoint(Vector3(-s,s,0));
+  if ( **this->lightTypeP == "point" )
+  {
+    float s=0.1;
+    this->line->AddPoint(Vector3(-s,-s,0));
+    this->line->AddPoint(Vector3(-s,s,0));
 
-  this->line->AddPoint(Vector3(-s,s,0));
-  this->line->AddPoint(Vector3(s,s,0));
+    this->line->AddPoint(Vector3(-s,s,0));
+    this->line->AddPoint(Vector3(s,s,0));
 
-  this->line->AddPoint(Vector3(s,s,0));
-  this->line->AddPoint(Vector3(s,-s,0));
+    this->line->AddPoint(Vector3(s,s,0));
+    this->line->AddPoint(Vector3(s,-s,0));
 
-  this->line->AddPoint(Vector3(s,-s,0));
-  this->line->AddPoint(Vector3(-s,-s,0));
+    this->line->AddPoint(Vector3(s,-s,0));
+    this->line->AddPoint(Vector3(-s,-s,0));
 
 
+    this->line->AddPoint(Vector3(-s,-s,0));
+    this->line->AddPoint(Vector3(0,0,s));
 
-  this->line->AddPoint(Vector3(-s,-s,0));
-  this->line->AddPoint(Vector3(0,0,s));
+    this->line->AddPoint(Vector3(-s,s,0));
+    this->line->AddPoint(Vector3(0,0,s));
 
-  this->line->AddPoint(Vector3(-s,s,0));
-  this->line->AddPoint(Vector3(0,0,s));
+    this->line->AddPoint(Vector3(s,s,0));
+    this->line->AddPoint(Vector3(0,0,s));
 
-  this->line->AddPoint(Vector3(s,s,0));
-  this->line->AddPoint(Vector3(0,0,s));
+    this->line->AddPoint(Vector3(s,-s,0));
+    this->line->AddPoint(Vector3(0,0,s));
 
-  this->line->AddPoint(Vector3(s,-s,0));
-  this->line->AddPoint(Vector3(0,0,s));
 
 
+    this->line->AddPoint(Vector3(-s,-s,0));
+    this->line->AddPoint(Vector3(0,0,-s));
 
-  this->line->AddPoint(Vector3(-s,-s,0));
-  this->line->AddPoint(Vector3(0,0,-s));
+    this->line->AddPoint(Vector3(-s,s,0));
+    this->line->AddPoint(Vector3(0,0,-s));
 
-  this->line->AddPoint(Vector3(-s,s,0));
-  this->line->AddPoint(Vector3(0,0,-s));
+    this->line->AddPoint(Vector3(s,s,0));
+    this->line->AddPoint(Vector3(0,0,-s));
 
-  this->line->AddPoint(Vector3(s,s,0));
-  this->line->AddPoint(Vector3(0,0,-s));
+    this->line->AddPoint(Vector3(s,-s,0));
+    this->line->AddPoint(Vector3(0,0,-s));
 
-  this->line->AddPoint(Vector3(s,-s,0));
-  this->line->AddPoint(Vector3(0,0,-s));
+  }
+  else if ( this->light->getType() == Ogre::Light::LT_SPOTLIGHT )
+  {
+    double innerAngle = this->light->getSpotlightInnerAngle().valueRadians();
+    double outerAngle = this->light->getSpotlightOuterAngle().valueRadians();
 
-  this->line->setMaterial("Gazebo/WhiteEmissive");
+    double angles[2];
+    double range = 0.2;
+    angles[0] = range * tan(outerAngle);
+    angles[1] = range * tan(innerAngle);
+    for (unsigned int i=0; i < 2; i++)
+    {
+      this->line->AddPoint(Vector3(0,0,0));
+      this->line->AddPoint(Vector3(angles[i],angles[i], -range));
+
+      this->line->AddPoint(Vector3(0,0,0));
+      this->line->AddPoint(Vector3(-angles[i],-angles[i], -range));
+
+      this->line->AddPoint(Vector3(0,0,0));
+      this->line->AddPoint(Vector3(angles[i],-angles[i], -range));
+
+      this->line->AddPoint(Vector3(0,0,0));
+      this->line->AddPoint(Vector3(-angles[i],angles[i], -range));
+
+      this->line->AddPoint(Vector3(angles[i],angles[i], -range));
+      this->line->AddPoint(Vector3(-angles[i],angles[i], -range));
+
+      this->line->AddPoint(Vector3(-angles[i],angles[i], -range));
+      this->line->AddPoint(Vector3(-angles[i],-angles[i], -range));
+
+      this->line->AddPoint(Vector3(-angles[i],-angles[i], -range));
+      this->line->AddPoint(Vector3(angles[i],-angles[i], -range));
+
+      this->line->AddPoint(Vector3(angles[i],-angles[i], -range));
+      this->line->AddPoint(Vector3(angles[i],angles[i], -range));
+    }
+    
+  }
+
+  this->line->setMaterial("Gazebo/WhiteGlow");
   this->line->setVisibilityFlags(GZ_LASER_CAMERA);
 
-  this->visual->AttachObject(line);
-
   // turn off light source box visuals by default
-  this->visual->SetVisible(true);
+  this->visualNode->SetVisible(true);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -234,19 +307,26 @@
   if (this->light->getType() != Ogre::Light::LT_DIRECTIONAL)
   {
     if (s)
-      this->line->setMaterial("Gazebo/PurpleEmissive");
+      this->line->setMaterial("Gazebo/PurpleGlow");
     else
-      this->line->setMaterial("Gazebo/WhiteEmissive");
+      this->line->setMaterial("Gazebo/WhiteGlow");
   }
 
   return true;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+// Toggle light visual visibility
+void Light::ToggleShowVisual()
+{
+  this->visualNode->ToggleVisible();
+}
+
+////////////////////////////////////////////////////////////////////////////////
 // Set whether to show the visual
 void Light::ShowVisual(bool s)
 {
-  this->visual->SetVisible(s);
+  this->visualNode->SetVisible(s);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -259,7 +339,8 @@
   else if (type == "directional")
   {
     this->light->setType(Ogre::Light::LT_DIRECTIONAL);
-    this->parent->GetParentModel()->SetStatic(true);
+    if (this->parent && this->parent->HasType(MODEL))
+      this->parent->GetParentModel()->SetStatic(true);
   }
   else if (type == "spot")
     this->light->setType(Ogre::Light::LT_SPOTLIGHT);
@@ -270,22 +351,22 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Set the diffuse
-void Light::SetDiffuseColor(const Vector3 &color)
+void Light::SetDiffuseColor(const Color &color)
 {
   if (**this->diffuseP != color)
     this->diffuseP->SetValue( color );
 
-  this->light->setDiffuseColour(color.x, color.y, color.z);
+  this->light->setDiffuseColour(color.R(), color.G(), color.B());
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Set the specular color
-void Light::SetSpecularColor(const Vector3 &color)
+void Light::SetSpecularColor(const Color &color)
 {
   if (**this->specularP != color)
     this->specularP->SetValue( color );
 
-  this->light->setSpecularColour(color.x, color.y, color.z);
+  this->light->setSpecularColour(color.R(), color.G(), color.B());
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -343,10 +424,15 @@
 /// Set cast shadowsj
 void Light::SetCastShadows(const bool &cast)
 {
-  if (**this->castShadowsP != cast)
-    this->castShadowsP->SetValue( cast );
+  if (this->light->getType() == Ogre::Light::LT_POINT)
+    this->light->setCastShadows(false);
+  else
+  {
+    if (**this->castShadowsP != cast)
+      this->castShadowsP->SetValue( cast );
 
-  this->light->setCastShadows(cast);
+    this->light->setCastShadows(cast);
+  }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -358,8 +444,8 @@
 
   if (this->light->getType() == Ogre::Light::LT_SPOTLIGHT)
     this->light->setSpotlightRange(
-        Ogre::Radian(Ogre::Degree(**this->spotInnerAngleP)), 
-        Ogre::Radian(Ogre::Degree(**this->spotOutterAngleP)), 
+        Ogre::Degree(**this->spotInnerAngleP), 
+        Ogre::Degree(**this->spotOutterAngleP), 
         **this->spotFalloffP);
 }
 
@@ -372,10 +458,9 @@
 
   if (this->light->getType() == Ogre::Light::LT_SPOTLIGHT)
     this->light->setSpotlightRange(
-        Ogre::Radian(Ogre::Degree(**this->spotInnerAngleP)), 
-        Ogre::Radian(Ogre::Degree(**this->spotOutterAngleP)), 
+        Ogre::Degree(**this->spotInnerAngleP), 
+        Ogre::Degree(**this->spotOutterAngleP), 
         **this->spotFalloffP);
-
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -387,8 +472,70 @@
 
   if (this->light->getType() == Ogre::Light::LT_SPOTLIGHT)
     this->light->setSpotlightRange(
-        Ogre::Radian(Ogre::Degree(**this->spotInnerAngleP)), 
-        Ogre::Radian(Ogre::Degree(**this->spotOutterAngleP)), 
+        Ogre::Degree(**this->spotInnerAngleP), 
+        Ogre::Degree(**this->spotOutterAngleP), 
         **this->spotFalloffP);
 
 }
+
+////////////////////////////////////////////////////////////////////////////////
+// Setup the shadow camera for the light
+void Light::SetupShadows()
+{
+  if (this->light->getType() == Ogre::Light::LT_DIRECTIONAL)
+  {
+    unsigned int numShadowTextures = 3;
+
+    // shadow camera setup
+    Ogre::PSSMShadowCameraSetup* pssmSetup = new Ogre::PSSMShadowCameraSetup();
+
+    Ogre::PSSMShadowCameraSetup::SplitPointList splitPointList = pssmSetup->getSplitPoints();
+
+    // These were hand tuned by me (Nate)...hopefully they work for all cases.
+    splitPointList[0] = 0.5;
+    splitPointList[1] = 5.5;
+    splitPointList[2] = 20.0;
+
+    pssmSetup->setSplitPoints(splitPointList);
+    pssmSetup->setSplitPadding(5.0);
+    pssmSetup->setUseSimpleOptimalAdjust(true);
+
+    // set the LISPM adjustment factor (see API documentation for these)
+    /*pssmSetup->setOptimalAdjustFactor(0, 5.0);
+    pssmSetup->setOptimalAdjustFactor(1, 3.0);
+    pssmSetup->setOptimalAdjustFactor(2, 1.0);
+    */
+
+    this->light->setCustomShadowCameraSetup(Ogre::ShadowCameraSetupPtr(pssmSetup));
+
+    Ogre::Vector4 splitPoints;
+    for (int i = 0; i < numShadowTextures; ++i)
+      splitPoints[i] = splitPointList[i];
+
+    Ogre::MaterialManager::ResourceMapIterator iter = Ogre::MaterialManager::getSingleton().getResourceIterator();
+
+    // Iterate over all the materials, and set the pssm split points
+    while(iter.hasMoreElements())
+    {
+      Ogre::MaterialPtr mat = iter.getNext();
+      for(int i = 0; i < mat->getNumTechniques(); i++) 
+      {
+        Ogre::Technique *tech = mat->getTechnique(i);
+        for(int j = 0; j < tech->getNumPasses(); j++) 
+        {
+          Ogre::Pass *pass = tech->getPass(j);
+          if (pass->hasFragmentProgram())
+          {
+            Ogre::GpuProgramParametersSharedPtr params = pass->getFragmentProgramParameters();
+            if (params->_findNamedConstantDefinition("pssm_split_points"))
+              params->setNamedConstant("pssm_split_points", splitPoints);
+          }
+        }
+      }
+    }
+  }
+  else if (this->light->getType() == Ogre::Light::LT_SPOTLIGHT)
+  {
+    this->light->setCustomShadowCameraSetup(Ogre::ShadowCameraSetupPtr(new Ogre::DefaultShadowCameraSetup()));
+  }
+}
Index: server/rendering/ogretest/main.cc
===================================================================
--- server/rendering/ogretest/main.cc	(revision 8976)
+++ server/rendering/ogretest/main.cc	(working copy)
@@ -1,139 +1,552 @@
-#include <Ogre.h>
-
-Ogre::Root *root;
-Ogre::SceneManager *sceneMgr;
-Ogre::RenderWindow *window;
-Ogre::Camera *camera;
-Ogre::Viewport *viewport;
-
-void SetupResources(void)
-{
-  Ogre::ConfigFile cf;
-  cf.load("resources.cfg");
-
-  Ogre::ConfigFile::SectionIterator seci = cf.getSectionIterator();
-
-  Ogre::String secName, typeName, archName;
-  while (seci.hasMoreElements())
-  {
-    secName = seci.peekNextKey();
-    Ogre::ConfigFile::SettingsMultiMap *settings = seci.getNext();
-    Ogre::ConfigFile::SettingsMultiMap::iterator i;
-    for (i = settings->begin(); i != settings->end(); ++i)
-    {
-      typeName = i->first;
-      archName = i->second;
-      Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
-          archName, typeName, secName);
-    }
-  }
-}
-
-void CreateScene()
-{
-  Ogre::Light *pointlight, *mSunLight;
-
-  sceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_ADDITIVE);
-  //sceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_MODULATIVE);
-  //sceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE);
-  //sceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_TEXTURE_ADDITIVE);
-
-  //sceneMgr->setShadowTextureCasterMaterial("Ogre/DepthShadowmap/Caster/Float");
-  //sceneMgr->setShadowTextureReceiverMaterial("Ogre/DepthShadowmap/Receiver/Float");
-      
-  sceneMgr->setAmbientLight( Ogre::ColourValue(0.0,0.0,0.0) );
-
-
-  mSunLight = sceneMgr->createLight("SunLight");
-  mSunLight->setType(Ogre::Light::LT_SPOTLIGHT);
-  mSunLight->setPosition(1500,1750,1300);
-  mSunLight->setSpotlightRange(Ogre::Degree(30), Ogre::Degree(50));
-  Ogre::Vector3 dir;
-  dir = -mSunLight->getPosition();
-  dir.normalise();
-  mSunLight->setDirection(dir);
-  mSunLight->setDiffuseColour(0.35, 0.35, 0.38);
-  mSunLight->setSpecularColour(0.9, 0.9, 1);
-  mSunLight->setCastShadows(true);
-
-
-  pointlight = sceneMgr->createLight("pointlight");
-  pointlight->setDiffuseColour( Ogre::ColourValue(0.8, 0.8, 0.8) );
-  pointlight->setSpecularColour(1,1,1);
-  pointlight->setAttenuation(8000, .1, 0.0005,0);
-  pointlight->setPosition(100, 500, 0);
-  pointlight->setCastShadows(true);
-
-
-  Ogre::MovablePlane *plane = new Ogre::MovablePlane("mplane");
-  plane->normal = Ogre::Vector3::UNIT_Y;
-  plane->d = 107;
-  Ogre::MeshManager::getSingleton().createPlane("Myplane",
-    Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, *plane,
-    1500,1500,50,50,true,1,5,5, Ogre::Vector3::UNIT_Z);
-
-  Ogre::Entity *planeEnt = sceneMgr->createEntity( "plane", "Myplane" );
-  //planeEnt->setMaterialName("Ogre/DepthShadowmap/Receiver/RockWall");
-  planeEnt->setCastShadows(false);
-  sceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(planeEnt);
-
-
-  Ogre::SceneNode *node = sceneMgr->getRootSceneNode()->createChildSceneNode();
-  Ogre::Entity *pEnt = sceneMgr->createEntity( "COl", "column.mesh" );
-  pEnt->setMaterialName("Gazebo/Grey");
-  node->attachObject( pEnt );
-  node->translate(0,0, 0);
-
-  /*sceneMgr->setShadowTextureSettings(512,2);
-  sceneMgr->setShadowColour(Ogre::ColourValue(0.5, 0.5, 0.5));
-
-  sceneMgr->setShadowTexturePixelFormat(Ogre::PF_FLOAT16_R);
-  sceneMgr->setShadowTextureCasterMaterial("Ogre/DepthShadowmap/Caster/Float");
-  sceneMgr->setShadowTextureReceiverMaterial("Ogre/DepthShadowmap/Receiver/Float");
-  */
- 
-  sceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_MODULATIVE);
-}
-
-int main(int argc, char **argv)
-{
-
-  // Pipe ogre output to a log file
-  Ogre::LogManager *logManager = new Ogre::LogManager();
-  logManager->createLog("Ogre.log", true, false, false);
-
-  root = new Ogre::Root("plugins.cfg", "ogre.cfg");
-
-  SetupResources();
-  root->showConfigDialog();
-
-  window = root->initialise(true);
-
-  // Create the scene manager
-  sceneMgr = root->createSceneManager(Ogre::ST_GENERIC);
-
-  // Load Resources
-  Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups();
-
-    // Create scene
-  CreateScene();
-
-// Create the camera
-  camera = sceneMgr->createCamera("Camera");
-  camera->setPosition( Ogre::Vector3(350, 200, 800));
-  camera->lookAt( Ogre::Vector3(0,10 ,0) );
-  camera->setNearClipDistance(5);
-  camera->setFarClipDistance(100000);
-
-  // Create viewports
-  viewport = window->addViewport(camera);
-  viewport->setBackgroundColour( Ogre::ColourValue(0,0,0) );
-  camera->setAspectRatio( Ogre::Real(viewport->getActualWidth()) /
-                          Ogre::Real(viewport->getActualHeight()) );
-
-
-  root->startRendering();
-
-  delete root;
-  return 0;
-}
+// sample example
+
+// actually, you can just include specifics here
+// instead of all of ogre, but this makes it easier
+// on me and this example
+#include <Ogre.h>
+// OIS is a bit lighting, though.  just include all of it
+#include <OIS/OIS.h>
+
+// for srand()
+#include <cstdlib>
+// for time()
+#include <ctime>
+
+// config files give us "stuff", not just stuff
+// we must manually remove the quotes
+Ogre::String removeQuotes(const Ogre::String &str) {
+    Ogre::String nstr = "";
+    for (size_t i = 0; i < str.size(); ++i) {
+        if (str[i] == '\"' || str[i] == '\'')
+            continue;
+        nstr += str[i];
+    }
+    return nstr;
+}
+
+// I don't really suggest you keep globals like
+// this, but, again, simplistic example
+class Mgr: public Ogre::WindowEventListener {
+  public:
+    // a config file we'll use to retrieve some settings
+    Ogre::ConfigFile cfgFile;
+
+    // our root
+    Ogre::Root *root;
+
+    // simples stuff here
+    Ogre::SceneManager *sceneMgr;
+    Ogre::Camera *cam;
+    Ogre::Viewport *vp;
+    Ogre::RenderWindow *window;
+    // note we only used one camera & viewport, simplistic
+    Ogre::Timer *timer; // we'll just use the root's timer
+    // otherwise you can make more complex timer systems
+
+    // just incase
+    Ogre::RenderSystem *rsys;
+
+    // OIS stuff O_o
+    OIS::InputManager *input;
+    OIS::Keyboard *keys;
+    OIS::Mouse *mouse;
+
+    // IGNORE THIS FOR NOW, until "initShadows".  capish?
+    void shadowTextureCasterPreViewProj(Ogre::Light *light, Ogre::Camera *cam);
+    // these are pure virtual but we don't need them...  so just make them empty
+    // otherwise we get "cannot declare of type Mgr due to missing abstract
+    // functions" and so on
+    void shadowTexturesUpdated(size_t) {}
+    void shadowTextureReceiverPreViewProj(Ogre::Light*, Ogre::Frustum*) {}
+
+    // local "continue?" variable
+    bool running;
+
+    // this tells us if the window closed (or alt-f4, for example)
+    void windowClosed(Ogre::RenderWindow *window) {
+        // stop running.  we don't compare any windows
+        // since we only make 1 window anyways
+        running = false;
+    }
+
+    Mgr():
+        root(NULL), sceneMgr(NULL), cam(NULL), vp(NULL), window(NULL), timer(NULL),
+        rsys(NULL), input(NULL), keys(NULL), mouse(NULL), running(true) {
+        // stupid constructor.  don't base your code on this code ;)
+        // but since I wanted to make it easy, everything is done
+        // in seperate "init" functions.  so this just makes everything
+        // default
+    }
+} mgr;
+
+// simple "choosing" of the renderer
+enum Renderer { D3D, OGL };
+
+// initialize Ogre and the renderer
+void initRenderer() { // default to D3D
+    // create our Root
+    // note the ""s.  we supply our own plugins and config options
+    mgr.root = new Ogre::Root("", ""); // default "Ogre.log"
+    mgr.root->loadPlugin("/home/nate/local/lib/OGRE/RenderSystem_GL.so");
+    mgr.root->loadPlugin("/home/nate/local/lib/OGRE/Plugin_CgProgramManager.so");
+
+    // get the available render systems
+    // technically, should be only one since we only load one plugin
+    // much better than comparing the string names like some people do it
+    Ogre::RenderSystemList renderers = mgr.root->getAvailableRenderers();
+
+    // use the first one
+    // (the '*' is because begin() returns an iterator, like the STL)
+    mgr.rsys = *(renderers.begin());
+    // tell the root to use this render system
+    mgr.root->setRenderSystem(mgr.rsys);
+
+    // now we can initialise the root
+    // though pass false since we want our own window creation
+    mgr.root->initialise(false);
+
+    // OK, this is really badly hard coded.  but its an example
+    // the disorder engine, for example, reads a lua script for these values
+    // (the disorder engine is what's under Portalized)
+    // (*cough*don'tworryifyou'veneverheardofit,it'smyproject*cough*)
+    Ogre::NameValuePairList miscParams;
+    // retrive anti aliasing from the config file
+    miscParams["FSAA"] = removeQuotes(mgr.cfgFile.getSetting("FSAA", "renderer"));
+    miscParams["vsync"] = removeQuotes(mgr.cfgFile.getSetting("vsync", "renderer"));
+
+    // get these settings from the cfg file, too
+    int width = 800, height = 600;
+    bool fullscreen = false;
+
+    std::string tempData = mgr.cfgFile.getSetting("width", "renderer");
+    width = Ogre::StringConverter::parseInt(removeQuotes(tempData));
+    tempData = mgr.cfgFile.getSetting("height", "renderer");
+    height = Ogre::StringConverter::parseInt(removeQuotes(tempData));
+    tempData = mgr.cfgFile.getSetting("fullscreen", "renderer");
+    fullscreen = Ogre::StringConverter::parseBool(removeQuotes(tempData));
+
+    // now we can just make a window, it's that easy
+    mgr.window = mgr.root->createRenderWindow(
+        "Ogre Soft Shadowing", width, height, fullscreen, &miscParams);
+
+    // btw, if my comments seem weird or something,
+    // it probably has to do with the fact that I'm listening
+    // to 50 cent right now, rocking with the awesome rap
+    // @ hatas! don't you hate 50 ;).  he's coo1.  (in da club, anyone?)
+
+    // ok, back to coding
+
+    // now, we can, for example, set the default texture filtering
+    ::Ogre::MaterialManager::getSingleton().setDefaultTextureFiltering(::Ogre::TFO_ANISOTROPIC);
+    // tada.
+
+    // tell the window it's active (duh, rofl)
+    mgr.window->setActive(true);
+    // make it auto updated on renderOneFrame()
+    mgr.window->setAutoUpdated(true);
+
+    // time to prepare the scene
+    mgr.sceneMgr = mgr.root->createSceneManager(Ogre::ST_GENERIC); // just generic for the example
+    // the shadows will work on anything that follows ogre materials properly, BTW
+    // "some" ambient light
+    mgr.sceneMgr->setAmbientLight(Ogre::ColourValue(0.2, 0.2, 0.2));
+
+    // alright, the next bit of code I'll just copy & paste from my project
+
+    // make the camera
+    mgr.cam = mgr.sceneMgr->createCamera("Mgr::cam");
+    mgr.cam->setNearClipDistance(0.01);
+    mgr.cam->setFarClipDistance(1000);
+
+    // add a viewport to the window and this camera
+    // (covers up the whole window)
+    mgr.vp = mgr.window->addViewport(mgr.cam);
+    // black background
+    mgr.vp->setBackgroundColour(Ogre::ColourValue(0.0, 0.0, 0.0));
+    // clear every frame for us
+    mgr.vp->setClearEveryFrame(true);
+
+    // aspect ratio, etc.
+    mgr.cam->setAspectRatio(mgr.window->getWidth() / float(mgr.window->getHeight()));
+    // 60 degree FOV
+    mgr.cam->setFOVy(Ogre::Degree(60));
+
+    // set the timer
+    mgr.timer = mgr.root->getTimer();
+
+    // we're done with Ogre itself
+}
+
+void stopRenderer() {
+    // the scene manager being destroyed will in turn
+    // handle the camera/viewport
+    mgr.root->destroySceneManager(mgr.sceneMgr);
+
+    // deleting the root will take care of the window and the root itself
+    delete mgr.root;
+    // actually, deleting the root shoot take care of the scene manager
+    // for us automatically.  but I just wanted to manually show it here.
+}
+
+void initResources() {
+    // just some hard coded stuff
+    Ogre::ResourceGroupManager *rgm = Ogre::ResourceGroupManager::getSingletonPtr();
+
+    // add our data directory (we sort of stuff everything in there
+    // just to make it easy on ourselves.  organize better otherwise!)
+    rgm->addResourceLocation("../data", "FileSystem", "Media");
+    // init this group
+    rgm->initialiseResourceGroup("Media"); // "Media" is the group from above
+}
+
+void initShadows() {
+    // we'll be self shadowing
+    mgr.sceneMgr->setShadowTextureSelfShadow(true);
+
+    // our caster material
+    mgr.sceneMgr->setShadowTextureCasterMaterial("shadow_caster");
+    // note we have no "receiver".  all the "receivers" are integrated.
+
+    // get the shadow texture count from the cfg file
+    std::string tempData = mgr.cfgFile.getSetting("shadowTextureCount", "renderer");
+    // (each light needs a shadow texture)
+    mgr.sceneMgr->setShadowTextureCount(Ogre::StringConverter::parseInt(removeQuotes(tempData)));
+
+    // the size, too (1024 looks good with 3x3 or more filtering)
+    tempData = mgr.cfgFile.getSetting("shadowTextureRes", "renderer");
+    mgr.sceneMgr->setShadowTextureSize(Ogre::StringConverter::parseInt(removeQuotes(tempData)));
+
+    // float 16 here.  we need the R and G channels.
+    // float 32 works a lot better with a low/none VSM epsilon (wait till the shaders)
+    // but float 16 is "good enough" and supports bilinear filtering on a lot of cards
+    // (note we're using floats and not bytes.  bytes, 0-255, won't be
+    // able to store our depth data accurately enough.  technically,
+    // we can "split" the floats into multiple bytes ourselves, but it's
+    // rather "complicated", to put it simply)
+    mgr.sceneMgr->setShadowTexturePixelFormat(Ogre::PF_FLOAT16_RGB);
+
+    // big NONO to render back faces for VSM.  it doesn't need any biasing
+    // so it's worthless (and rather problematic) to use the back face hack that
+    // works so well for normal depth shadow mapping (you know, so you don't
+    // get surface acne)
+    mgr.sceneMgr->setShadowCasterRenderBackFaces(false);
+
+    const unsigned numShadowRTTs = mgr.sceneMgr->getShadowTextureCount();
+    for (unsigned i = 0; i < numShadowRTTs; ++i) {
+        Ogre::TexturePtr tex = mgr.sceneMgr->getShadowTexture(i);
+        Ogre::Viewport *vp = tex->getBuffer()->getRenderTarget()->getViewport(0);
+        vp->setBackgroundColour(Ogre::ColourValue(1, 1, 1, 1));
+        vp->setClearEveryFrame(true);
+        Ogre::CompositorManager::getSingleton().addCompositor(vp, "blur");
+        Ogre::CompositorManager::getSingleton().setCompositorEnabled(vp, "blur", true);
+    }
+
+    // enable integrated additive shadows
+    // actually, since we render the shadow map ourselves, it doesn't
+    // really matter whether they are additive or modulative
+    // as long as they are integrated v(O_o)v
+    mgr.sceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED);
+
+    // some "tests" with shadow camera setups
+    //Ogre::LiSPSMShadowCameraSetup *camSetup = new Ogre::LiSPSMShadowCameraSetup();
+    //Ogre::FocusedShadowCameraSetup *camSetup = new Ogre::FocusedShadowCameraSetup();
+    //mgr.sceneMgr->setShadowCameraSetup(Ogre::ShadowCameraSetupPtr(camSetup));
+
+    // all done for the shadows.  see how easy it was?  might want to experiment
+    // with stuff like different shadow camera setups.  or something.
+}
+
+void Mgr::shadowTextureCasterPreViewProj(Ogre::Light *light, Ogre::Camera *cam) {
+    // basically, here we do some forceful camera near/far clip attenuation
+    // yeah.  simplistic, but it works nicely.  this is the function I was talking
+    // about you ignoring above in the Mgr declaration.
+    float range = light->getAttenuationRange();
+    cam->setNearClipDistance(range * 0.01);
+    cam->setFarClipDistance(range);
+    // we just use a small near clip so that the light doesn't "miss" anything
+    // that can shadow stuff.  and the far clip is equal to the lights' range.
+    // (thus, if the light only covers 15 units of objects, it can only
+    // shadow 15 units - the rest of it should be attenuated away, and not rendered)
+}
+
+void initInput() {
+    // aRGHh I forgot about input -_-
+
+    // window handle (IIRC, this was cross-platform)
+    size_t winHandle;
+    mgr.window->getCustomAttribute("WINDOW", &winHandle);
+
+    // create input "manager" or "hook", as I call it
+    mgr.input = OIS::InputManager::createInputSystem(winHandle);
+
+    mgr.keys = (OIS::Keyboard*)mgr.input->createInputObject(OIS::OISKeyboard, true);
+    mgr.mouse = (OIS::Mouse*)mgr.input->createInputObject(OIS::OISMouse, true);
+
+    // tada.  I think.  rofl just kidding.  seriously.  that's it.
+}
+
+void stopInput() {
+    // destroy the keyboard object, the mouse object
+    // and the input "hook"
+    mgr.input->destroyInputObject(mgr.keys);
+    mgr.input->destroyInputObject(mgr.mouse);
+    OIS::InputManager::destroyInputSystem(mgr.input);
+}
+
+void captureInput() {
+    // we have to "capture" the current "state" of the input devices
+    // every single frame.  (think of it as an "input update()")
+    mgr.keys->capture();
+    mgr.mouse->capture();
+}
+
+// handling the camera every frame based on a delta time and mouse/keys
+void handleCamera(float dt) {
+    // this is actually a bad way to do a first person camera
+    // however, I'm trying to keep this relatively simple.
+    static float pitch = 0, yaw = 0;
+
+    // get the current mouse state
+    const OIS::MouseState &ms = mgr.mouse->getMouseState();
+    // fix pitch and yaw
+    pitch += -ms.Y.rel; // add the relative mouse movement (up/down for pitching)
+    yaw += -ms.X.rel; // add the relative mouse movement (left/right for yawing)
+    // constrain pitch to +/- 90 degrees
+    if (pitch < -90) pitch = -90;
+    if (pitch >  90) pitch =  90;
+
+    // set the camera to a default orientation and then get
+    // it into our own rotation
+    mgr.cam->setOrientation(Ogre::Quaternion::IDENTITY);
+    // yaw first, pitch second (all in world space)
+    mgr.cam->yaw(Ogre::Degree(yaw));
+    mgr.cam->pitch(Ogre::Degree(pitch));
+
+    // define a local movement vector (+X == right, +Y == yp, -Z == forward)
+    Ogre::Vector3 move(0, 0, 0);
+    // basic WASD.  for your own entertainment, don't hardcode like me ;)
+    if (mgr.keys->isKeyDown(OIS::KC_W))
+        move.z += -1;
+    if (mgr.keys->isKeyDown(OIS::KC_S))
+        move.z += 1;
+    if (mgr.keys->isKeyDown(OIS::KC_A))
+        move.x += -1;
+    if (mgr.keys->isKeyDown(OIS::KC_D))
+        move.x += 1;
+    // move the camera based on where it's looking at a speed
+    const float CAM_SPEED = 10; // meters per second
+    mgr.cam->move(mgr.cam->getOrientation() * (move * CAM_SPEED * dt));
+}
+
+Ogre::Quaternion makeQuat(
+    const Ogre::Vector3 &forward, const Ogre::Vector3 &wantedUp = Ogre::Vector3::UNIT_Y) {
+    // if you don't understand this, don't worry
+    // just basically makes a full orientation based
+    // on a desired "up" vector and a desired "forward" vector
+    Ogre::Vector3 right = wantedUp.crossProduct(forward).normalisedCopy();
+    Ogre::Vector3 up = forward.crossProduct(right).normalisedCopy();
+    return Ogre::Quaternion(right, up, forward);
+}
+
+void setupScene() {
+    // create a simply "plane" mesh programmatically
+    Ogre::MeshPtr planeMesh = Ogre::MeshManager::getSingleton().createPlane(
+        "plane.mesh", // simulate actual ".mesh", rofl
+        "Media", // in the Media group
+        Ogre::Plane(Ogre::Vector3::UNIT_Y, 0), // plane facing up
+        25, 25, // world coordinates.  we want it nice and big
+        1, 1, // number of segments...  might want to tesselate it if you wish
+        true, // yes, we need normals for proper lighting
+        1, // one texture coordinate set
+        1, 1, // UV tiling (texture coordinates)
+        Ogre::Vector3::NEGATIVE_UNIT_Z); // up vector.  if it's facing up, then it's up is -Z
+    // make sure it loaded
+    planeMesh->load();
+
+    Ogre::SceneNode *rootNode = mgr.sceneMgr->getRootSceneNode();
+
+    // make an entity for this plane
+    Ogre::Entity *ent = mgr.sceneMgr->createEntity("planeEnt", "plane.mesh");
+    ent->setMaterialName("metal");
+    // make a node for it, scale to 10 by 10 meters
+    Ogre::SceneNode *node = rootNode->createChildSceneNode();
+    // attach
+    // EDIT: since we're using a level, no need to make the plane
+    // (so actually don't attach)
+    node->attachObject(ent);
+
+    // create some random knots
+    const size_t NUM_X = 5, NUM_Z = NUM_X;
+    for (size_t x = 0; x < NUM_X; ++x) {
+        for (size_t z = 0; z < NUM_Z; ++z) {
+            Ogre::Vector3 p(
+                Ogre::Math::RangeRandom(-5.0, 5.0),
+                Ogre::Math::RangeRandom(0.25, 2),
+                Ogre::Math::RangeRandom(-5.0, 5.0));
+            ent = mgr.sceneMgr->createEntity(
+                "ogre" + Ogre::StringConverter::toString(x) + "_" +
+                Ogre::StringConverter::toString(z), "knot.mesh");
+            ent->setMaterialName("ogre");
+            node = rootNode->createChildSceneNode();
+            node->attachObject(ent);
+            node->setPosition(p);
+            node->setScale(Ogre::Vector3(0.01, 0.01, 0.01));
+        }
+    }
+    /*ent = mgr.sceneMgr->createEntity("level", "level.mesh");
+    ent->setMaterialName("ogre");
+    node = rootNode->createChildSceneNode();
+    node->attachObject(ent);
+    node->setScale(Ogre::Vector3(0.01, 0.01, 0.01)); // from cm to m
+    */
+
+    // random position I found to be pretty
+    mgr.cam->setPosition(Ogre::Vector3(0.0361507, 2.70619, 7.03829));
+    mgr.cam->setDirection(Ogre::Vector3(0, 0, -1));
+
+    // create our flash light
+    Ogre::Light *light = mgr.sceneMgr->createLight("flashLight");
+    light->setDiffuseColour(Ogre::ColourValue(1, 1, 1));
+    light->setType(Ogre::Light::LT_SPOTLIGHT);
+    light->setSpotlightInnerAngle(Ogre::Degree(45));
+    light->setSpotlightOuterAngle(Ogre::Degree(65));
+    light->setAttenuation(50, 1, 1, 1); // meter range.  the others our shader ignores
+    light->setDirection(Ogre::Vector3(0, 0, -1));
+    node = rootNode->createChildSceneNode("flashLightNode");
+    node->attachObject(light);
+}
+
+void handleScene(float dt) {
+    // sync our "flashlight" with the camera
+    Ogre::SceneNode *node = mgr.sceneMgr->getSceneNode("flashLightNode");
+    node->setPosition(mgr.cam->getDerivedPosition());
+    node->setOrientation(mgr.cam->getDerivedOrientation());
+    // this is a simply "offset", to the bottom right, as if
+    // the camera is holding the light in its right hand
+    Ogre::Vector3 offset(0.225, -0.3, -0.3);
+    // local space means that it's relative to the node
+    // itself, not in world units
+    node->translate(offset, Ogre::Node::TS_LOCAL);
+}
+
+// example of a key listener
+struct LightControl: public OIS::KeyListener {
+    LightControl(size_t li = 0): lightIndex(li) {}
+
+    size_t lightIndex;
+
+    bool keyPressed(const OIS::KeyEvent &e) {
+        // place a light if we pressed space
+        if (e.key == OIS::KC_SPACE) {
+            std::string name = "light" + Ogre::StringConverter::toString(lightIndex++);
+            Ogre::Light *light = mgr.sceneMgr->createLight(name);
+            // random colour
+            float r = Ogre::Math::UnitRandom(),
+                g = Ogre::Math::UnitRandom(),
+                b = Ogre::Math::UnitRandom();
+            // make sure the light is not too dark
+            if (Ogre::Vector3(r, g, b).length() < 0.75) {
+                // if so, multiply by 2
+                r *= 2;
+                g *= 2;
+                b *= 2;
+            }
+            light->setDiffuseColour(Ogre::ColourValue(r, g, b));
+
+            light->setDirection(Ogre::Vector3(0, -1, 0));
+
+            light->setType(Ogre::Light::LT_POINT);
+            //light->setSpotlightInnerAngle(Ogre::Degree(70));
+            //light->setSpotlightOuterAngle(Ogre::Degree(90));
+
+            light->setAttenuation(30, 1, 1, 1); // meter range.  the others our shader ignores
+
+            Ogre::SceneNode *node =
+                mgr.sceneMgr->getRootSceneNode()->createChildSceneNode(name + "Node");
+            node->setPosition(mgr.cam->getDerivedPosition());
+            node->setOrientation(mgr.cam->getDerivedOrientation());
+            node->attachObject(light);
+        }
+
+        // toggle the flash light if we press F
+        if (e.key == OIS::KC_F) {
+            Ogre::Light *flashLight = mgr.sceneMgr->getLight("flashLight");
+            flashLight->setVisible(!flashLight->getVisible());
+        }
+
+        return true;
+    }
+
+    bool keyReleased(const OIS::KeyEvent &e) {
+        // do nothing
+        return true;
+    }
+} lightPlacer(0);
+// start off with a light index of 0 (we have a 0th light, but it's named "flashLight")
+
+int main(int, char**) {
+    // seed the random number generator
+    std::srand(std::time(NULL));
+
+    // load our config file
+    mgr.cfgFile.loadDirect("../data/config.ini");
+    // get our renderer (OpenGL or Direct3D)
+    Renderer renderer = OGL; // default to OGL
+    std::string rendererAsString = removeQuotes(mgr.cfgFile.getSetting("library", "renderer"));
+
+    // start up the renderer and a window (OGL for the example)
+    initRenderer();
+    // load all of our shaders and models and stuff
+    initResources();
+    // init the shadow setup we'll be using
+    initShadows();
+    // grab the window's input stuff with OIS
+    initInput();
+    // grab the keyboard input with our light placer
+    mgr.keys->setEventCallback(&lightPlacer);
+
+    // set up our basic scene
+    setupScene();
+
+    // this keeps track of time (seconds to keep it easy)
+    float currentTime = float(mgr.timer->getMilliseconds()) * 0.001;
+
+    // keep running until something stops us
+    // (frame listener, escape key, window closed (the mgr gets a message for this), etc.)
+    for (bool running = true; running; running = running && mgr.running) {
+        // note this
+        // when we render manually, we need to pump
+        // the window events ourselves
+        // (or we won't get window events, like closing of the window, input, etc.)
+        Ogre::WindowEventUtilities::messagePump();
+
+        // get the delta time and advance currentTime
+        float deltaTime = (float(mgr.timer->getMilliseconds()) * 0.001) - currentTime;
+        currentTime += deltaTime;
+
+        // capture our input state
+        captureInput();
+
+        // simply "escape" key exit
+        if (mgr.keys->isKeyDown(OIS::KC_ESCAPE))
+            running = false;
+
+        // handle the camera movement
+        handleCamera(deltaTime);
+
+        // handle the scene movement (like animations for the robot)
+        handleScene(deltaTime);
+
+        // render one frame by Ogre
+        // technically, we can go even lower-level and update the window RT
+        // ourselves.  but that needs tweaking for frame listeners and what-not
+        running = running && mgr.root->renderOneFrame();
+        // BTW, renderOneFrame() returns true if everything went alright
+        // (such as frame listeners, which we actually don't use here)
+    }
+
+    // destroy input
+    stopInput();
+    // stop and deinitialise Ogre
+    stopRenderer();
+}
Index: server/rendering/ogretest/CMakeLists.txt
===================================================================
--- server/rendering/ogretest/CMakeLists.txt	(revision 8976)
+++ server/rendering/ogretest/CMakeLists.txt	(working copy)
@@ -12,12 +12,14 @@
 
 if (PKG_CONFIG_FOUND)
   pkg_check_modules(OGRE OGRE)
+  pkg_check_modules(OIS OIS)
 endif (PKG_CONFIG_FOUND)
 
 include_directories(${OGRE_INCLUDE_DIRS})
+include_directories(${OIS_INCLUDE_DIRS})
 
 set (sources main.cc)
 
 add_executable(ogretest ${sources})
 
-target_link_libraries(ogretest ${OGRE_LIBRARIES} ${FLTK_LIBRARIES})
+target_link_libraries(ogretest ${OGRE_LIBRARIES} ${OIS_LIBRARIES} ${FLTK_LIBRARIES})
Index: server/rendering/Color.cc
===================================================================
--- server/rendering/Color.cc	(revision 8976)
+++ server/rendering/Color.cc	(working copy)
@@ -249,31 +249,38 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 // Get the red color
-float Color::R()
+float Color::R() const
 {
   return this->r;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Get the green color
-float Color::G()
+float Color::G() const
 {
   return this->g;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Get the blue color
-float Color::B()
+float Color::B() const
 {
   return this->b;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Get the alpha color
-float Color::A()
+float Color::A() const
 {
   return this->a;
 }
+
+////////////////////////////////////////////////////////////////////////////////
+/// Return the equivalent ogre color
+Ogre::ColourValue Color::GetOgreColor() const
+{
+  return Ogre::ColourValue(this->r, this->g, this->b, this->a);
+}
  
 ////////////////////////////////////////////////////////////////////////////////
 // Equals operator
Index: server/rendering/OrbitViewController.cc
===================================================================
--- server/rendering/OrbitViewController.cc	(revision 8976)
+++ server/rendering/OrbitViewController.cc	(working copy)
@@ -1,6 +1,6 @@
-#include <Ogre.h>
-#include "Simulator.hh"
 #include "Global.hh"
+#include "OgreVisual.hh"
+#include "OgreCreator.hh"
 #include "OgreCamera.hh"
 #include "Vector2.hh"
 #include "MouseEvent.hh"
@@ -14,44 +14,47 @@
 ////////////////////////////////////////////////////////////////////////////////
 /// Constructor
 OrbitViewController::OrbitViewController(OgreCamera *camera)
-  : ViewController(camera), yaw(M_PI), pitch(M_PI*.5), distance(5.0f)
+  : ViewController(camera), distance(5.0f)
 {
+  Vector3 rpy = this->camera->GetWorldPose().rot.GetAsEuler();
+
+  this->yaw = rpy.z;
+  this->pitch = rpy.y;
+
   this->focalPoint.Set(0,0,0);
+  this->distance = this->camera->GetWorldPosition().Distance(this->focalPoint);
+  this->refVisual = OgreCreator::Instance()->CreateVisual("", NULL, NULL, this->camera->GetScene());
+  this->refVisual->AttachMesh("unit_sphere");
+  this->refVisual->SetScale(Vector3(0.2,0.2,0.1));
+  this->refVisual->SetCastShadows(false);
+  this->refVisual->SetMaterial("Gazebo/YellowTransparent");
+  this->refVisual->SetVisible(false);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Destructor
 OrbitViewController::~OrbitViewController()
 {
+  if (this->refVisual)
+    OgreCreator::Instance()->DeleteVisual(this->refVisual);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// Activate the controller
-//void OrbitViewController::Activate()
-//{
-//}
-
-////////////////////////////////////////////////////////////////////////////////
 // Update
 void OrbitViewController::Update()
 {
   Vector3 pos;
-  pos.x = this->distance * cos( this->yaw ) * sin( this->pitch ) + this->focalPoint.x;
-  pos.z = this->distance * cos( this->pitch ) + this->focalPoint.z;
-  pos.y = this->distance * sin( this->yaw ) * sin( this->pitch ) + this->focalPoint.y;
+  pos.x = this->distance * cos( this->yaw ) * sin( this->pitch );
+  pos.z = this->distance * cos( this->pitch );
+  pos.y = this->distance * sin( this->yaw ) * sin( this->pitch );
 
-  this->camera->SetPosition(pos);
-  Pose3d pose = this->camera->GetCameraWorldPose();
+  pos += this->focalPoint;
 
-  Vector3 vec = pose.rot * (this->focalPoint - pos);
+  this->camera->SetWorldPosition(pos);
 
-  this->camera->SetDirection(vec);
-  //this->camera->GetOgreCamera()->setDirection(Ogre::Vector3(vec.x, vec.y, vec.z));
-
-  //camera_->setFixedYawAxis(true, reference_node_->getOrientation() * Ogre::Vector3::UNIT_Y);
-  //camera_->setDirection(reference_node_->getOrientation() * (focal_point_ - pos));
-
-  //focal_shape_->setPosition(focal_point_);
+  Quatern rot;
+  rot.SetFromEuler( Vector3(0, M_PI*0.5 - this->pitch, this->yaw - M_PI) );
+  this->camera->SetWorldRotation(rot);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -67,42 +70,57 @@
 
   if (event.left == MouseEvent::DOWN)
   {
-    this->yaw += drag.x * event.moveScale * 0.1;
-    this->pitch += drag.y * event.moveScale *0.1;
+    this->refVisual->SetVisible(true);
+    this->yaw += drag.x * event.moveScale * -0.1;
+    this->pitch += drag.y * event.moveScale * -0.1;
 
-    this->yaw = fmod(this->yaw, M_PI*2);
-    if (this->yaw < 0.0f)
-      this->yaw = M_PI * 2 + this->yaw;
-
-    if (this->pitch < PITCH_LIMIT_LOW)
-      this->pitch = PITCH_LIMIT_LOW;
-    else if (this->pitch > PITCH_LIMIT_HIGH)
-      this->pitch = PITCH_LIMIT_HIGH;
-
-    //this->camera->RotateYaw(DTOR(drag.x * 0.1));
-    //this->camera->RotatePitch(DTOR(-drag.y * 0.1));
+    this->NormalizeYaw(this->yaw);
+    this->NormalizePitch(this->pitch);
   }
-  /*else if (event.right == MouseEvent::DOWN)
+  else if (event.middle == MouseEvent::SCROLL)
   {
-    // interactively pan view
-    directionVec.x = 0;
-    directionVec.y =  drag.x * event.moveScale;
-    directionVec.z =  drag.y * event.moveScale;
+    this->refVisual->SetVisible(true);
+    distance +=  50.0 * event.scroll.y * event.moveScale;
   }
+  else if (event.right == MouseEvent::DOWN)
+  {
+    this->refVisual->SetVisible(true);
+    this->Translate(Vector3(0, drag.x * event.moveScale, drag.y * event.moveScale));
+  }
   else if (event.middle == MouseEvent::DOWN)
   {
-    directionVec.x =  drag.y * event.moveScale;
-    directionVec.y =  0;
-    directionVec.z =  0;
+    this->refVisual->SetVisible(true);
+    this->Translate(Vector3(drag.y * event.moveScale,0,0));
   }
-  else if (event.middle == MouseEvent::SCROLL)
+  else
+    this->refVisual->SetVisible(false);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Translate the focal point
+void OrbitViewController::Translate(Vector3 vec)
+{
+  this->focalPoint += this->camera->GetWorldPose().rot * vec;
+  this->refVisual->SetPosition(this->focalPoint);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Normalize yaw value
+void OrbitViewController::NormalizeYaw(float &v)
+{
+  v = fmod(v, M_PI*2);
+  if (v < 0.0f)
   {
-    directionVec.x -=  50.0 * event.scroll.y * event.moveScale;
-    directionVec.y =  0;
-    directionVec.z =  0;
+    v = M_PI * 2 + v;
   }
+}
 
-  this->camera->Translate(directionVec);
-  this->directionVec.Set(0,0,0);
-  */
+////////////////////////////////////////////////////////////////////////////////
+// Normalize pitch value
+void OrbitViewController::NormalizePitch(float &v)
+{
+  if (v < PITCH_LIMIT_LOW)
+    v = PITCH_LIMIT_LOW;
+  else if (v > PITCH_LIMIT_HIGH)
+    v = PITCH_LIMIT_HIGH;
 }
Index: server/rendering/OgreCamera.hh
===================================================================
--- server/rendering/OgreCamera.hh	(revision 8976)
+++ server/rendering/OgreCamera.hh	(working copy)
@@ -33,6 +33,7 @@
 #include "Param.hh"
 #include "Angle.hh"
 #include "Pose3d.hh"
+#include "Time.hh"
 
 // Forward Declarations
 namespace Ogre
@@ -52,6 +53,7 @@
   class Entity;
   class MouseEvent;
   class ViewController;
+  class Scene;
 
   /// \addtogroup gazebo_rendering
   /// \brief Basic camera 
@@ -67,45 +69,57 @@
   class OgreCamera 
   {
     /// \brief Constructor
-    public: OgreCamera(const std::string &namePrefix);
+    public: OgreCamera(const std::string &namePrefix, unsigned int sceneIndex);
   
     /// \brief Destructor
     public: virtual ~OgreCamera();
   
     /// \brief Load the camera using parameter from an XMLConfig node
     /// \param node The XMLConfig node
-    public: void LoadCam( XMLConfigNode *node );
+    public: void Load( XMLConfigNode *node );
 
     /// \brief Save camera info in xml format
     /// \param stream Output stream
-    public: void SaveCam(std::string &prefix, std::ostream &stream);
+    public: void Save(std::string &prefix, std::ostream &stream);
   
     /// \brief Initialize the camera
-    public: void InitCam();
+    public: void Init();
 
     /// \brief Render the camera
-    public: void Render();
+    public: virtual void Render();
 
+    /// \brief Post render
+    public: virtual void PostRender();
+
     /// \brief Update the sensor information
-    public: void UpdateCam();
+    public: void Update();
   
     /// Finalize the camera
-    public: void FiniCam();
+    public: void Fini();
 
     /// \brief Set to true to enable rendering
     public: void SetRenderingEnabled(bool value);
 
     /// \brief Get whether the rendering is enabled
     public: bool GetRenderingEnabled() const;
-  
+
+
     /// \brief Get the global pose of the camera
-    public: Pose3d GetCameraWorldPose() const;
+    public: Pose3d GetWorldPose() const;
 
+    /// \brief Get the camera position in the world
+    public: Vector3 GetWorldPosition() const;
+
+
     /// \brief Set the global pose of the camera
     public: void SetWorldPose(const Pose3d &pose);
 
     /// \brief Set the world position
-    public: void SetPosition(const Vector3 &pos);
+    public: void SetWorldPosition(const Vector3 &pos);
+
+    /// \brief Set the world orientation
+    public: void SetWorldRotation(const Quatern &quant);
+
   
     /// \brief Translate the camera
     public: void Translate( const Vector3 &direction );
@@ -116,6 +130,8 @@
     /// \brief Rotate the camera around the pitch axis
     public: void RotatePitch( float angle );
 
+
+
     /// \brief Set the clip distances
     public: void SetClipDist(float near, float far);
 
@@ -186,9 +202,6 @@
     /// \brief Get the viewport right vector
     public: Vector3 GetRight();
 
-    /// \brief Get the camera position in the world
-    public: Vector3 GetCameraPosition();
-
     /// \brief Get the average FPS
     public: virtual float GetAvgFPS() { return 0;}
 
@@ -204,26 +217,29 @@
     /// \brief Get whether the user can move the camera via the GUI
     public: bool GetUserMovable() const;
 
-    /// \brief Get the name of the camera
-    public: std::string GetCameraName();
-
     /// \brief Set the camera's scene node
-    public: void SetCameraSceneNode( Ogre::SceneNode *node );
+    public: void SetSceneNode( Ogre::SceneNode *node );
 
+    /// \brief Get the camera's scene node
+    public: Ogre::SceneNode *GetSceneNode() const;
+
     /// \brief Get a pointer to the image data
     public: virtual const unsigned char *GetImageData(unsigned int i=0);
 
     /// \brief Get the camera's name
-    public: std::string GetCamName();
+    public: std::string GetName() const;
 
     /// \brief Set the camera's name
-    public: void SetCamName( const std::string &name );
+    public: void SetName( const std::string &name );
 
     /// \brief Move the camera to focus on an entity
     public: void MoveToEntity(Entity *entity);
 
     /// \brief Set the camera to track an entity
     public: void TrackModel( Model *model );
+            
+    /// \brief Toggle whether to view the world in wireframe
+    public: void ToggleShowWireframe();
 
     /// \brief Set whether to view the world in wireframe
     public: void ShowWireframe(bool s);
@@ -245,18 +261,32 @@
     public: void HandleMouseEvent(const MouseEvent &evt);
 
     /// \brief Get the time of the last render update
-    public: gazebo::Time GetLastRenderTime() const; 
+    public: gazebo::Time GetLastUpdateTime() const; 
 
+    /// \brief Set view controller
+    public: void SetViewController( const std::string type );
+
+    /// \brief Set whether to capture data
+    public: void SetCaptureData( bool value );
+
+    /// \brief Set the render target
+    public: void CreateRenderTexture( const std::string &textureName );
+
+    /// \brief Get the scene this camera is in
+    public: Scene *GetScene() const;
+
     /// \brief if user requests bayer image, post process rgb from ogre to generate bayer formats
     private: void ConvertRGBToBAYER(unsigned char* dst, unsigned char* src, std::string format,int width, int height);
 
-
     // Save the camera frame
     protected: virtual void SaveFrame();
 
     /// \brief set update rate (render rate) of the OgreCamera
     public: void SetUpdateRate(const double &rate);
 
+    // Create the ogre camera
+    private: void CreateOgreCamera();
+
     private: std::string name;
 
     protected: ParamT<Angle> *hfovP;
@@ -265,9 +295,10 @@
     protected: unsigned int textureWidth, textureHeight;
   
     protected: Ogre::Camera *camera;
+    protected: Ogre::Viewport *viewport;
     protected: Ogre::SceneNode *origParentNode;
     protected: Ogre::SceneNode *sceneNode;
-    public: Ogre::SceneNode *pitchNode;
+    protected: Ogre::SceneNode *pitchNode;
   
     private: Pose3d pose;
   
@@ -283,17 +314,14 @@
     protected: Ogre::PixelFormat imageFormat;
     protected: unsigned int visibilityMask;
 
-    public: Ogre::RenderTarget *renderTarget;
+    protected: Ogre::RenderTarget *renderTarget;
 
     protected: Ogre::TexturePtr renderTexture;
 
-    protected: std::string ogreTextureName;
-    protected: std::string ogreMaterialName;
-
     private: static unsigned int cameraCounter;
     private: unsigned int myCount;
 
-    protected: std::string cameraName;
+    protected: std::string uniqueName;
 
     protected: bool captureData;
 
@@ -302,6 +330,8 @@
 
     protected: bool renderingEnabled;
 
+    protected: bool newData;
+
     protected: Time renderPeriod;
     protected: Time lastUpdate;
     private: Ogre::AnimationState *animState;
@@ -309,7 +339,7 @@
     private: ViewController *viewController;
 
     protected: Time lastRenderTime;
-
+    protected: Scene *scene;
   };
   
   /// \}
Index: server/rendering/OgreAdaptor.hh
===================================================================
--- server/rendering/OgreAdaptor.hh	(revision 8976)
+++ server/rendering/OgreAdaptor.hh	(working copy)
@@ -71,6 +71,7 @@
   class UserCamera;
   class OgreCamera;
   class OgreVisual;
+  class Scene;
   
   /// \brief Adptor to Ogre3d
   class OgreAdaptor : public SingletonT<OgreAdaptor>
@@ -100,32 +101,18 @@
     /// \brief Get the desired update rate
     public: double GetUpdateRate();
 
-    /// \brief Update all the cameras 
-    public: void UpdateCameras();
+    /// \brief Get a scene manager
+    public: Scene *GetScene(unsigned int index);
 
-    /// \brief Get an entity at a pixel location using a camera. Used for
-    ///        mouse picking. 
-    /// \param camera The ogre camera, used to do mouse picking
-    /// \param mousePos The position of the mouse in screen coordinates
-    /// \return The selected entity, or NULL
-    public: Entity *GetEntityAt(OgreCamera *camera, Vector2<int> mousePos, std::string &mod);
+    /// \brief Get the number of scene managers
+    public: unsigned int GetSceneCount() const;
 
-    /// \brief Get the world pos of a the first contact at a pixel location
-    public: Vector3 GetFirstContact(OgreCamera *camera, Vector2<int> mousePos);
+    /// \brief Update all the scenes 
+    public: void UpdateScenes();
 
-    /// \brief Register a user camera
-    public: void RegisterCamera( OgreCamera *cam );
-    public: void UnregisterCamera( OgreCamera *cam );
-
-    public: void PrintSceneGraph();
-
     /// \brief Returns true if the graphics card support GLSL
     public: bool HasGLSL();
 
-    /// \brief Print scene graph
-    private: void PrintSceneGraphHelper(std::string prefix, 
-                                        Ogre::Node *node);
-
     private: void LoadPlugins();
     private: void SetupResources();
     private: void SetupRenderSystem();
@@ -134,28 +121,13 @@
     public: Ogre::Root *root;
   
     /// Pointer to the scene manager
-    public: Ogre::SceneManager *sceneMgr;
+    private: std::vector<Scene *> scenes;
   
     /// Pointer to the rendering system
     public: Ogre::RenderSystem *renderSys;
  
     private: Ogre::LogManager *logManager;
-  
-    // Our custom frame listener
-    private: OgreFrameListener *frameListener;
-  
-    public: Ogre::ColourValue *backgroundColor;
-  
-    private: Ogre::RaySceneQuery *raySceneQuery;
-
-    //bsp attributes saved to write XML file back
-    private: int sceneType;
-    private: std::string worldGeometry;
-  
-    //private: Vector3 terrainSize;
-    //private: unsigned int terrainVertSize;
-    //private: std::string terrainImage;
-  
+ 
     /// ID for a dummy window. Used for gui-less operation
     protected: Window dummyWindowId;
 
@@ -168,14 +140,6 @@
     /// GLX context used to render the scenes.Used for gui-less operation
     protected: GLXContext dummyContext;
 
-    private: ParamT<Vector4> *ambientP;
-    private: ParamT<bool> *shadowsP;
-    private: ParamT<Vector3> *backgroundColorP;
-    private: ParamT<std::string> *skyMaterialP;
-    private: std::vector<Param*> parameters;
-
-    private: std::vector<OgreCamera*> cameras;
-
     private: friend class DestroyerT<OgreAdaptor>;
     private: friend class SingletonT<OgreAdaptor>;
   };
Index: server/rendering/OgreCreator.hh
===================================================================
--- server/rendering/OgreCreator.hh	(revision 8976)
+++ server/rendering/OgreCreator.hh	(working copy)
@@ -43,17 +43,18 @@
   class RenderWindow;
 }
 
-class Fl_Window;
 typedef struct _XDisplay Display;
 
 namespace gazebo
 {
+  class RenderControl;
   class XMLConfigNode;
   class Entity;
   class OgreVisual;
   class OgreMovableText;
   class OgreDynamicLines;
   class Light;
+  class Scene;
 
 /// \addtogroup gazebo_rendering
 /// \{
@@ -78,56 +79,20 @@
                 const Vector2<double> &uvTile, const std::string &material, 
                 bool castShadows, OgreVisual *parent, const std::string &name);
 
-    /// \brief Create a light source and attach it to the visual node
-    public: Light *CreateLight(Entity *parent);
-
-    /// \brief Remove a light
-    public: void DeleteLight(Light *light);
-
-    /// \brief Delete a line visual from lines vector
-    public: void DeleteDynamicLine(OgreDynamicLines* line);
-
-    /// \brief Helper function to create a camera
-    public: static Ogre::Camera *CreateCamera(const std::string &name, 
-                double nearClip, double farClip, double hfov, 
-                Ogre::RenderTarget *renderTarget);
-
-    public: static void DeleteCamera(Ogre::Camera* camera);
-
-    /// \brief Helper function to create fog
-    public: static void CreateFog(XMLConfigNode *node);
-
-    /// \brief Helper function to save the fog settings
-    public: static void SaveFog(std::string &prefix, std::ostream &stream);
-
-    /// \brief Helper function to create the sky 
-    public: static void CreateSky(std::string material);
-
     /// \brief Create a new window
-    public: Ogre::RenderWindow *CreateWindow(Fl_Window *flWindow, 
+    public: Ogre::RenderWindow *CreateWindow(RenderControl *window, 
                                              unsigned int width, 
                                              unsigned int height);
 
 
     /// \brief Create a window for Ogre
-    public: Ogre::RenderWindow *CreateWindow(Display *display, 
-                                             int screen, 
-                                             int32_t winId, 
+    public: Ogre::RenderWindow *CreateWindow(std::string ogreHandle, 
                                              unsigned int width, 
                                              unsigned int height);
 
     /// \brief Insert a mesh into Ogre 
     public: static void InsertMesh( const Mesh *mesh);
 
-    /// \brief Draw a named line
-    public: static void DrawLine(const Vector3 &start, const Vector3 &end, const std::string &name);
-
-    /// \brief Draw a line strip
-    public: static void DrawLineStrip(const std::vector<Vector3> &pts, const std::string &name);
-
-    /// \brief Hide a visual
-    public: static void SetVisible(const std::string &name, bool visible);
-
    /// \brief Remove a mesh by name
     public: static void RemoveMesh(const std::string &name);
 
@@ -142,16 +107,16 @@
     /// \brief Create a material from a texture file
     public: static std::string CreateMaterialFromTexFile(const std::string &filename);
 
-    public: OgreDynamicLines *CreateDynamicLine(OgreDynamicRenderable::OperationType opType);
-
     /// \brief Create a new ogre visual 
-    /// \param name Unique name for the new visual
+    /// \param name Unique name for the new visual. Leave empty to generate
+    //              a unique name
     /// \param parent Parent visual
     /// \param owner The entity that owns the visual
     /// \return The new ogre visual
     public: OgreVisual *CreateVisual( const std::string &name,
                                       OgreVisual *parent=NULL, 
-                                      Entity *owner = NULL );
+                                      Entity *owner = NULL,
+                                      Scene *scene = NULL );
     /// \brief Get a visual
     public: OgreVisual *GetVisual( const std::string &name );
 
@@ -187,17 +152,11 @@
 
     private: static unsigned int windowCounter;
 
-    // List of all the lines created
-    private: std::list<OgreDynamicLines*> lines;
-
     // List of all the movable text
     private: std::list<OgreMovableText*> text;
 
-    // List of all the light sources
-    private: std::list<Light*> lights;
-
     // All the visuals 
-    private: std::map<std::string, OgreVisual*> visuals;
+    private: std::list<OgreVisual*> visuals;
 
     // All the windows
     private: std::list<Ogre::RenderWindow *> windows;
Index: server/rendering/UserCamera.cc
===================================================================
--- server/rendering/UserCamera.cc	(revision 8976)
+++ server/rendering/UserCamera.cc	(working copy)
@@ -27,10 +27,12 @@
 #include <Ogre.h>
 #include <sstream>
 
+#include "Events.hh"
+#include "Scene.hh"
 #include "Simulator.hh"
 #include "RTShaderSystem.hh"
 #include "Global.hh"
-#include "GLWindow.hh"
+#include "RenderControl.hh"
 #include "OgreCamera.hh"
 #include "OgreAdaptor.hh"
 #include "OgreCreator.hh"
@@ -45,20 +47,22 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Constructor
-UserCamera::UserCamera(GLWindow *parentWindow)
-  : OgreCamera("UserCamera")
+UserCamera::UserCamera(RenderControl *parentWindow, unsigned int sceneIndex )
+  : OgreCamera("UserCamera", sceneIndex)
 {
   std::stringstream stream;
 
-  this->window = OgreCreator::Instance()->CreateWindow(parentWindow, 
-                         parentWindow->w(), parentWindow->h());
+  int w, h;
+  parentWindow->GetSize(&w, &h);
 
+  this->window = OgreCreator::Instance()->CreateWindow(parentWindow, w, h);
+
   stream << "UserCamera_" << this->count++;
   this->name = stream.str(); 
 
   this->viewport = NULL;
 
-  World::Instance()->ConnectShowCamerasSignal( boost::bind(&UserCamera::ShowVisual, this, _1) );
+  Events::ConnectShowCamerasSignal( boost::bind(&UserCamera::ToggleShowVisual, this) );
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -76,7 +80,7 @@
 // Load child
 void UserCamera::Load(XMLConfigNode *node)
 {
-  OgreCamera::LoadCam(node);
+  OgreCamera::Load(node);
 
   this->SetFOV( DTOR(90) );
   this->SetClipDist(0.001, 1000);
@@ -86,15 +90,13 @@
 /// Initialize
 void UserCamera::Init()
 {
-  this->SetCameraSceneNode( OgreAdaptor::Instance()->sceneMgr->getRootSceneNode()->createChildSceneNode( this->GetCameraName() + "_SceneNode") );
+  this->SetSceneNode( this->scene->GetManager()->getRootSceneNode()->createChildSceneNode( this->GetName() + "_SceneNode") );
 
-  this->InitCam();
+  OgreCamera::Init();
 
   this->visual = new OgreVisual(this->pitchNode);
-
   // The lines draw a visualization of the camera
-  OgreDynamicLines *line = OgreCreator::Instance()->CreateDynamicLine(
-      OgreDynamicRenderable::OT_LINE_LIST);
+  OgreDynamicLines *line = this->visual->AddDynamicLine( OgreDynamicRenderable::OT_LINE_LIST );
 
   float f = 0.2;
 
@@ -141,13 +143,16 @@
   line->AddPoint(Vector3(0.0, +0.00, +f+0.15)); 
   line->AddPoint(Vector3(0.0, -0.02, +f+0.1)); 
 
-  line->setMaterial("Gazebo/WhiteEmissive");
+  line->setMaterial("Gazebo/WhiteGlow");
   line->setVisibilityFlags(GZ_LASER_CAMERA);
 
-  this->visual->AttachObject(line);
   this->visual->SetVisible(false);
 
-  this->SetCamera(this);
+  this->window->removeAllViewports();
+  this->viewport = this->window->addViewport(this->GetOgreCamera());
+
+  this->SetAspectRatio( Ogre::Real(this->viewport->getActualWidth()) / Ogre::Real(this->viewport->getActualHeight()) );
+
   this->lastUpdate = Simulator::Instance()->GetRealTime();
 
   double ratio = (double)this->viewport->getActualWidth() / (double)this->viewport->getActualHeight();
@@ -156,46 +161,38 @@
   this->GetOgreCamera()->setFOVy(Ogre::Radian(vfov));
 
   this->viewport->setClearEveryFrame(true);
-  this->viewport->setBackgroundColour( *OgreAdaptor::Instance()->backgroundColor );
+  this->viewport->setBackgroundColour( this->scene->GetBackgroundColor().GetOgreColor() );
   this->viewport->setVisibilityMask(this->visibilityMask);
 
-  RTShaderSystem::AttachViewport(this->viewport);
+  RTShaderSystem::AttachViewport(this);
 }
 
-void UserCamera::SetCamera( OgreCamera *cam )
-{
-  this->window->removeAllViewports();
-
-  if (cam == NULL)
-    cam = this;
-
-  this->viewport = this->window->addViewport(cam->GetOgreCamera());
-
-  this->SetAspectRatio( Ogre::Real(this->viewport->getActualWidth()) / Ogre::Real(this->viewport->getActualHeight()) );
-
-}
-
-
 ////////////////////////////////////////////////////////////////////////////////
 /// Update
-void UserCamera::Update()
+void UserCamera::Render()
 {
   if (Simulator::Instance()->GetRealTime() - this->lastUpdate < this->renderPeriod)
     return;
 
-  this->lastUpdate = Simulator::Instance()->GetRealTime();
-
   {
     DIAGNOSTICTIMER(timer("UserCamera: UpdateCam with MDMutex",6));
     boost::recursive_mutex::scoped_lock md_lock(*Simulator::Instance()->GetMDMutex());
-    OgreCamera::UpdateCam();
+    OgreCamera::Update();
+    this->lastUpdate = Simulator::Instance()->GetRealTime();
+    this->newData = true;
+    this->window->update(false);
   }
   {
     DIAGNOSTICTIMER(timer("UserCamera: window->update",6));
     this->window->update();
   }
+}
 
-  if (this->saveFramesP->GetValue())
+void UserCamera::PostRender()
+{
+  this->window->swapBuffers();
+
+  if (this->newData && this->saveFramesP->GetValue())
   {
     char tmp[1024];
     if (!this->savePathnameP->GetValue().empty())
@@ -212,6 +209,7 @@
 
     this->saveCount++;
   }
+  this->newData = false;
 }
 
 
@@ -219,7 +217,7 @@
 // Finalize
 void UserCamera::Fini()
 {
-  OgreCamera::FiniCam();
+  OgreCamera::Fini();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -265,6 +263,13 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+// Toggle whether to show the visual
+void UserCamera::ToggleShowVisual()
+{
+  this->visual->ToggleVisible();
+}
+
+////////////////////////////////////////////////////////////////////////////////
 // Set whether to show the visual
 void UserCamera::ShowVisual(bool s)
 {
Index: server/rendering/ViewController.hh
===================================================================
--- server/rendering/ViewController.hh	(revision 8976)
+++ server/rendering/ViewController.hh	(working copy)
@@ -19,7 +19,7 @@
     /// \brief Handle a mouse event
     public: virtual void HandleMouseEvent(const MouseEvent &event) = 0;
 
-    protected: OgreCamera *camera;
+    protected: OgreCamera *camera; 
   };
 }
 #endif
Index: server/rendering/OgreVisual.hh
===================================================================
--- server/rendering/OgreVisual.hh	(revision 8976)
+++ server/rendering/OgreVisual.hh	(working copy)
@@ -30,6 +30,7 @@
 #include <Ogre.h>
 #include <string>
 
+#include "OgreDynamicRenderable.hh"
 #include "Pose3d.hh"
 #include "Quatern.hh"
 #include "Vector3.hh"
@@ -47,12 +48,14 @@
   class XMLConfigNode;
   class Entity;
   class SelectionObj;
+  class Scene;
+  class OgreDynamicLines;
 
   /// \brief Ogre Visual Object
   class OgreVisual : public Common, public Ogre::Any
   {
     /// \brief Constructor
-    public: OgreVisual (OgreVisual *node, Entity *owner = NULL);
+    public: OgreVisual (OgreVisual *node, Entity *owner = NULL, Scene *scene = NULL);
 
     /// \brief Constructor
     public: OgreVisual (Ogre::SceneNode *node, bool isStatic=false);
@@ -66,6 +69,9 @@
     /// \brief Load the visual
     public: void Load(XMLConfigNode *node);
 
+    /// \brief Update the visual.
+    public: void Update();
+
     /// \brief Attach a manipulation visual
     public: void AttachManipulation();
 
@@ -101,6 +107,9 @@
     /// \brief Set the transparency
     public: void SetTransparency( float trans );
 
+    /// \brief Get the transparency
+    public: float GetTransparency();
+
     /// \brief Set highlighted or no
     public: void SetHighlight( bool highlight);
 
@@ -112,6 +121,9 @@
     /// \param cascade setting this parameter in children too
     public: void SetVisible(bool visible, bool cascade=true);
 
+    /// \brief Toggle whether this visual is visible
+    public: void ToggleVisible();
+
     /// \brief Get whether the visual is visible
     public: bool GetVisible() const;
 
@@ -187,6 +199,22 @@
     /// \brief True on or off a ribbon trail
     public: void SetRibbonTrail(bool value);
 
+    /// \brief Get the size of the bounding box
+    public: Vector3 GetBoundingBoxSize() const;
+
+    /// \brief Set whether to use the RT Shader system
+    public: void SetUseRTShader(bool value);
+
+    /// \brief Get whether to user the RT shader system
+    public: bool GetUseRTShader() const;
+
+    /// \brief Add a line to the visual
+    public: OgreDynamicLines *AddDynamicLine(
+                 OgreDynamicRenderable::OperationType opType);
+
+    /// \brief Delete a dynamic line
+    public: void DeleteDynamicLine(OgreDynamicLines *line);
+
     private: Ogre::MaterialPtr origMaterial;
     private: Ogre::MaterialPtr myMaterial;
     private: std::string myMaterialName;
@@ -227,6 +255,13 @@
     private: static SelectionObj *selectionObj;
 
     private: Ogre::RibbonTrail *ribbonTrail;
+
+    private: Scene *scene;
+    private: bool useRTShader;
+
+    // List of all the lines created
+    private: std::list<OgreDynamicLines*> lines;
+    private: Time updateTime;
   };
 }
 
Index: server/CMakeLists.txt
===================================================================
--- server/CMakeLists.txt	(revision 8976)
+++ server/CMakeLists.txt	(working copy)
@@ -5,16 +5,21 @@
 string (REPLACE " " ";" boost_include_dirs_split "${boost_include_dirs}")
 string (REPLACE " " ";" assimp_include_dirs_split "${assimp_include_dirs}")
 string (REPLACE " " ";" bullet_include_dirs_split "${bullet_include_dirs}")
+string (REPLACE " " ";" parallel_quickstep_include_dirs_split "${parallel_quickstep_include_dirs}")
 string (REPLACE " " ";" threadpool_include_dirs_split "${threadpool_include_dirs}")
 string (REPLACE " " ";" boost_library_dirs_split "${boost_library_dirs}")
 string (REPLACE " " ";" assimp_library_dirs_split "${assimp_library_dirs}")
 string (REPLACE " " ";" bullet_library_dirs_split "${bullet_library_dirs}")
+string (REPLACE " " ";" parallel_quickstep_library_dirs_split "${parallel_quickstep_library_dirs}")
 
+include_directories( ${wxWidgets_INCLUDE_DIRS} )
+link_directories( ${wxWidgets_LIBRARY_DIRS} )
+include (${wxWidgets_USE_FILE})
 
 include_directories(
   .
   ${CMAKE_SOURCE_DIR}/libgazebo 
-  gui 
+  wx 
   physics 
   physics/ode
   physics/bullet
@@ -35,17 +40,19 @@
   ${assimp_include_dirs_split}
   ${freeimage_include_dir}
   ${bullet_include_dirs_split}
+  ${parallel_quickstep_include_dirs_split}
   ${threadpool_include_dirs_split}
-  ${FLTK_INCLUDE_DIR}
+  ${GTK2_INCLUDE_DIRS}
 )
 
 link_directories(  
  ${CMAKE_BINARY_DIR}/libgazebo 
- ${CMAKE_BINARY_DIR}/server/gui 
+ ${CMAKE_BINARY_DIR}/server/wx 
  ${CMAKE_BINARY_DIR}/server/physics/bullet 
  ${boost_library_dirs_split} 
  ${assimp_library_dirs_split} 
  ${bullet_library_dirs_split} 
+ ${parallel_quickstep_library_dirs_split} 
  ${freeimage_library_dir}
  ${gazeboserver_link_dirs} 
 )
@@ -61,7 +68,7 @@
 add_subdirectory(rendering)
 add_subdirectory(physics)
 add_subdirectory(sensors)
-add_subdirectory(gui)
+add_subdirectory(wx)
 add_subdirectory(controllers)
 add_subdirectory(audio_video)
 
@@ -84,6 +91,7 @@
              Angle.cc
              Param.cc
              GraphicsIfaceHandler.cc
+             SimulationIfaceHandler.cc
              Simulator.cc
              Rand.cc
              Factory.cc
@@ -95,6 +103,7 @@
              STLLoader.cc
              Logger.cc
              Plugin.cc
+             Events.cc
 )
 
 SET (headers Common.hh
@@ -118,6 +127,7 @@
              Angle.hh
              Param.hh
              GraphicsIfaceHandler.hh
+             SimulationIfaceHandler.hh
              Simulator.hh
              Rand.hh
              Factory.hh
@@ -128,7 +138,7 @@
              AssimpLoader.hh
              STLLoader.hh
              Logger.hh
-             Event.hh
+             Events.hh
              Plugin.hh
 )
 
@@ -159,8 +169,8 @@
   set_source_files_properties(${gazeboserver_sources} PROPERTIES LINK_FLAGS 
     ${CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE}})
   set_target_properties( gazebo-exec PROPERTIES LINK_FLAGS "${LINK_FLAGS} ${gazebo_lflags} ${CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE}}")
-else (CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE})
-  set_target_properties( gazebo-exec PROPERTIES LINK_FLAGS "${LINK_FLAGS} ${gazebo_lflags}")
+  else (CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE})
+    set_target_properties( gazebo-exec PROPERTIES LINK_FLAGS "${LINK_FLAGS} ${gazebo_lflags}")
 endif (CMAKE_LINK_FLAGS_${CMAKE_BUILD_TYPE})
 
 
@@ -172,19 +182,20 @@
                                    gazebo_server
                                    gazebo_rendering
                                    gazebo_av-shared
-                                   gazebo_gui
+                                   gazebo_wx
                                    gazebo_physics
                                    gazeboshm 
                                    assimp
                                    pthread
+                                   profiler
 )
+
 APPEND_TO_CACHED_LIST(gazeboserver_ldflags 
                       ${gazeboserver_ldflags_desc} 
-                      -lassimp -lgazebo_physics -lgazebo_av -lgazebo_gui 
-                      -lgazebo_rendering)
+                      -lassimp -lgazebo_physics -lgazebo_av -lgazebo_wx -lgazebo_rendering)
 
 
-target_link_libraries( gazebo_server ${libtool_library} ${freeimage_library} gazeboshm gazebo_rendering gazebo_physics )
+target_link_libraries( gazebo_server ${libtool_library} ${freeimage_library} gazeboshm gazebo_rendering gazebo_physics profiler)
 
 if (INCLUDE_BULLET)
   target_link_libraries(gazebo_server ${bullet_lflags} gazebo_physics_bullet )
@@ -196,8 +207,8 @@
 endif (INCLUDE_BULLET)
 
 if (INCLUDE_ODE)
-  target_link_libraries(gazebo_server gazebo_physics_ode ${ODE_LIBRARIES})
-  target_link_libraries(gazebo-exec gazebo_physics_ode ${ODE_LIBRARIES})
+  target_link_libraries(gazebo_server ${parallel_quickstep_lflags} gazebo_physics_ode ${ODE_LIBRARIES})
+  target_link_libraries(gazebo-exec ${parallel_quickstep_lflags} gazebo_physics_ode ${ODE_LIBRARIES})
   APPEND_TO_CACHED_LIST(gazeboserver_ldflags 
                       ${gazeboserver_ldflags_desc} 
                       -lgazebo_physics_ode)
Index: server/Time.cc
===================================================================
--- server/Time.cc	(revision 8976)
+++ server/Time.cc	(working copy)
@@ -336,20 +336,4 @@
 bool Time::operator>=( int time ) const
 {
   return *this >= Time((double)time);
-}
-
-
-void Time::Correct()
-{
-  // Make any corrections
-  if (this->nsec > 1e9)
-  {
-    this->sec++;
-    this->nsec = (int32_t)(this->nsec - 1e9);
-  }
-  else if (this->nsec < 0)
-  {
-    this->sec--;
-    this->nsec = (int32_t)(this->nsec + 1e9);
-  }
-}
+}
\ No newline at end of file
Index: server/Model.cc
===================================================================
--- server/Model.cc	(revision 8976)
+++ server/Model.cc	(working copy)
@@ -26,10 +26,15 @@
 
 //#include <boost/python.hpp>
 
+#include <tbb/parallel_for.h>
+#include <tbb/blocked_range.h>
+
 #include <sstream>
 #include <iostream>
 #include <float.h>
 
+#include "Events.hh"
+#include "RenderState.hh"
 #include "OgreVisual.hh"
 #include "Light.hh"
 #include "GraphicsIfaceHandler.hh"
@@ -52,12 +57,36 @@
 
 uint Model::lightNumber = 0;
 
+class BodyUpdate_TBB
+{
+  public: BodyUpdate_TBB(std::vector<Body*> *bodies) : bodies(bodies) {}
+
+  public: void operator() (const tbb::blocked_range<size_t> &r) const
+  {
+    for (size_t i=r.begin(); i != r.end(); i++)
+    {
+      (*this->bodies)[i]->Update();
+      /*Common *common = (*this->children)[i];
+      if ( common->HasType(BODY) )
+      {
+        ((Body*)common)->Update();
+      }
+      */
+    }
+  }
+
+  private: std::vector<Body*> *bodies;
+};
+
+
 ////////////////////////////////////////////////////////////////////////////////
 // Constructor
 Model::Model(Model *parent)
     : Entity(parent)
 {
-  this->type = MODEL;
+  this->AddType(MODEL);
+  this->GetVisualNode()->SetShowInGui(false);
+
   this->modelType = "";
   this->joint = NULL;
 
@@ -99,9 +128,9 @@
 // Destructor
 Model::~Model()
 {
-  /*std::vector<Entity*>::iterator eiter;
+  /*std::vector<Common*>::iterator eiter;
   for (eiter =this->children.begin(); eiter != this->children.end();)
-    if (*eiter && (*eiter)->GetType() == Entity::BODY)
+    if (*eiter && (*eiter)->HasType(BODY))
     {
       delete (*eiter);
       *eiter = NULL;
@@ -116,7 +145,7 @@
 
   if (this->light)
   {
-    OgreCreator::Instance()->DeleteLight(this->light);
+    delete this->light;
   }
 
   if (this->graphicsHandler)
@@ -161,13 +190,13 @@
   XMLConfigNode *childNode;
   std::string scopedName;
   Pose3d pose;
-  Entity* dup;
+  Common* dup;
 
   this->nameP->Load(node);
 
   scopedName = this->GetScopedName();
 
-  dup = World::Instance()->GetEntityByName(scopedName);
+  dup = Common::GetByName(scopedName);
 
   // Look for existing models by the same name
   if(dup != NULL && dup != this)
@@ -180,7 +209,7 @@
     {
       // Delete the existing one (this should only be reached when called
       // via the factory interface).
-      World::Instance()->DeleteEntity(scopedName.c_str());
+      Events::deleteEntitySignal(scopedName.c_str());
     }
   }
 
@@ -217,7 +246,9 @@
 
   // Set the relative pose of the model
   if (!this->IsStatic())
+  {
     this->SetRelativePose( pose );
+  }
 
   // Record the model's initial pose (for reseting)
   this->SetInitPose(pose);
@@ -249,11 +280,18 @@
   {
     /// FIXME: Model::pose is set to the pose of first body
     ///        seems like there should be a warning for users
-    Entity *entity = this->children.front();
-    if (entity && entity->GetType() == Entity::BODY)
-      this->canonicalBodyNameP->SetValue( entity->GetName() );
+    for (unsigned int i=0; i < this->children.size(); i++)
+    {
+      if (this->children[i]->HasType(BODY))
+      {
+        this->canonicalBodyNameP->SetValue( this->children[i]->GetName() );
+        break;
+      }
+    }
   }
 
+  this->canonicalBody = (Body*)this->GetChild(**this->canonicalBodyNameP);
+
   // This must be placed after creation of the bodies
   // Static variable overrides the gravity
   if (**this->staticP == false)
@@ -297,7 +335,10 @@
 {
   std::string p = prefix + "  ";
   std::string typeName;
-  std::vector<Entity* >::iterator entityIter;
+  //std::vector<Entity* >::iterator entityIter;
+
+  //std::map<std::string, Body* >::iterator bodyIter;
+  std::vector<Common* >::iterator bodyIter;
   std::map<std::string, Controller* >::iterator contIter;
   JointContainer::iterator jointIter;
 
@@ -321,12 +362,15 @@
   {
     stream << prefix << "  " << *(this->staticP) << "\n";
 
-    for (entityIter=this->children.begin(); entityIter!=this->children.end(); entityIter++)
+    //for (entityIter=this->children.begin(); entityIter!=this->children.end(); entityIter++)
+    for (bodyIter=this->children.begin(); bodyIter!=this->children.end(); bodyIter++)
     {
       stream << "\n";
-      if ((*entityIter) && (*entityIter)->GetType() == Entity::BODY)
+      Entity *entity = (Entity*)*bodyIter;
+      if (entity && entity->HasType(BODY))
       {
-        Body *body = (Body*)(*entityIter);
+        //Body *body = (Body*)(*entityIter);
+        Body *body = (Body*)(entity);
         body->Save(p, stream);
       }
     }
@@ -360,10 +404,10 @@
   }
 
   // Save all child models
-  std::vector< Entity* >::iterator eiter;
+  std::vector< Common* >::iterator eiter;
   for (eiter = this->children.begin(); eiter != this->children.end(); eiter++)
   {
-    if (*eiter && (*eiter)->GetType() == Entity::MODEL)
+    if (*eiter && (*eiter)->HasType(MODEL))
     {
       Model *cmodel = (Model*)*eiter;
       cmodel->Save(p, stream);
@@ -377,7 +421,7 @@
 // Initialize the model
 void Model::Init()
 {
-  std::vector<Entity* >::iterator biter;
+  std::vector<Common* >::iterator biter;
   std::map<std::string, Controller* >::iterator contIter;
 
   this->graphicsHandler->Init();
@@ -386,9 +430,9 @@
   {
     if (*biter)
     {
-      if ((*biter)->GetType() == Entity::BODY)
+      if ((*biter)->HasType(BODY))
         ((Body*)*biter)->Init();
-      else if ((*biter)->GetType() == Entity::MODEL)
+      else if ((*biter)->HasType(MODEL))
         ((Model*)*biter)->Init();
     }
   }
@@ -417,80 +461,56 @@
     return;
 
   //DiagnosticTimer timer("Model[" + this->GetName() + "] Update ");
-
-  std::vector<Entity*>::iterator entityIter;
   std::map<std::string, Controller* >::iterator contIter;
-  JointContainer::iterator jointIter;
 
-  this->updateSignal();
+  tbb::parallel_for( tbb::blocked_range<size_t>(0, this->bodies.size(), 10),
+      BodyUpdate_TBB(&this->bodies) );
 
+  this->contacts.clear();
+
+/*
+  std::vector<Entity*>::iterator entityIter;
+  for (entityIter=this->children.begin(); 
+       entityIter!=this->children.end(); entityIter++)
   {
-    //DiagnosticTimer timer("Model[" + this->GetName() + "] Bodies Update ");
-
-    for (entityIter=this->children.begin(); 
-         entityIter!=this->children.end(); entityIter++)
+    if (*entityIter)
     {
-      if (*entityIter)
+      if ((*entityIter)->GetType() == Entity::BODY)
       {
-        if ((*entityIter)->GetType() == Entity::BODY)
-        {
-          Body *body = (Body*)(*entityIter);
-#ifdef USE_THREADPOOL
-          World::Instance()->threadPool->schedule(boost::bind(&Body::Update,body));
-#else
-          body->Update();
-#endif
-        }
-        else if ((*entityIter)->GetType() == Entity::MODEL)
-        {
-          // for nested Models
-          Model *model = (Model*)(*entityIter);
-#ifdef USE_THREADPOOL
-          World::Instance()->threadPool->schedule(boost::bind(&Model::Update,model));
-#else
-          model->Update();
-#endif
-        }
+        Body *body = (Body*)(*entityIter);
+        body->Update();
       }
+      else if ((*entityIter)->GetType() == Entity::MODEL)
+      {
+        // for nested Models
+        Model *model = (Model*)(*entityIter);
+        model->Update();
+      }
     }
   }
+*/
 
+  for (contIter=this->controllers.begin();
+      contIter!=this->controllers.end(); contIter++)
   {
-    //DiagnosticTimer timer("Model[" + this->GetName() + "] Controllers Update ");
-    for (contIter=this->controllers.begin();
-        contIter!=this->controllers.end(); contIter++)
+    if (contIter->second)
     {
-      if (contIter->second)
-      {
-#ifdef USE_THREADPOOL
-        World::Instance()->threadPool->schedule(boost::bind(&Controller::Update,(contIter->second)));
-#else
-        contIter->second->Update();
-#endif
-      }
+      contIter->second->Update();
     }
   }
 
 
-  if (World::Instance()->GetShowJoints())
+  if (RenderState::GetShowJoints())
   {
-    //DiagnosticTimer timer("Model[" + this->GetName() + "] Joints Update ");
+    JointContainer::iterator jointIter;
     for (jointIter = this->joints.begin(); 
          jointIter != this->joints.end(); jointIter++)
     {
-#ifdef USE_THREADPOOL
-      World::Instance()->threadPool->schedule(
-          boost::bind(&Joint::Update,*jointIter));
-#else
       (*jointIter)->Update();
-#endif
     }
   }
 
-  {
-    //DiagnosticTimer timer("Model[" + this->GetName() + "] Children Update ");
-    this->UpdateChild();
-  }
+  this->UpdateChild();
 }
 
 void Model::OnPoseChange()
@@ -508,7 +528,7 @@
 {
   JointContainer::iterator jiter;
 
-  if (child->GetType() == Entity::BODY)
+  if (child->HasType(BODY))
   {
     bool done = false;
 
@@ -540,9 +560,9 @@
 
   Entity::RemoveChild(child);
 
-  std::vector<Entity*>::iterator iter;
+  std::vector<Common*>::iterator iter;
   for (iter =this->children.begin(); iter != this->children.end(); iter++)
-    if (*iter && (*iter)->GetType() == Entity::BODY)
+    if (*iter && (*iter)->HasType(BODY))
       ((Body*)*iter)->SetEnabled(true);
 
 }
@@ -562,7 +582,7 @@
 // Finalize the model
 void Model::Fini()
 {
-  std::vector<Entity* >::iterator biter;
+  std::vector<Common* >::iterator biter;
   std::map<std::string, Controller* >::iterator contIter;
 
   for (contIter = this->controllers.begin();
@@ -573,7 +593,7 @@
 
   for (biter=this->children.begin(); biter != this->children.end(); biter++)
   {
-    if (*biter && (*biter)->GetType() == Entity::BODY)
+    if (*biter && (*biter)->HasType(BODY))
     {
       Body *body = (Body*)*biter;
       body->Fini();
@@ -586,10 +606,10 @@
     this->graphicsHandler = NULL;
   }
 
-  std::vector< Entity* >::iterator iter;
+  std::vector< Common* >::iterator iter;
   for (iter = this->children.begin(); iter != this->children.end(); iter++)
   {
-    if (*iter && (*iter)->GetType() == Entity::MODEL)
+    if (*iter && (*iter)->HasType(MODEL))
     {
       Model *m = (Model*)*iter;
       m->Fini();
@@ -603,9 +623,9 @@
 // Reset the model
 void Model::Reset()
 {
-  boost::recursive_mutex::scoped_lock lock(*Simulator::Instance()->GetMRMutex());
+  //boost::recursive_mutex::scoped_lock lock(*Simulator::Instance()->GetMRMutex());
   JointContainer::iterator jiter;
-  std::vector< Entity* >::iterator biter;
+  std::vector< Common* >::iterator biter;
   std::map<std::string, Controller* >::iterator citer;
   Vector3 v(0,0,0);
 
@@ -623,7 +643,7 @@
 
   for (biter=this->children.begin(); biter != this->children.end(); biter++)
   {
-    if (*biter && (*biter)->GetType() == Entity::BODY)
+    if (*biter && (*biter)->HasType(BODY))
     {
       Body *body = (Body*)*biter;
       body->SetLinearVel(v);
@@ -661,11 +681,11 @@
 void Model::SetLinearVel( const Vector3 &vel )
 {
   Body *body;
-  std::vector<Entity* >::iterator iter;
+  std::vector<Common* >::iterator iter;
 
   for (iter=this->children.begin(); iter!=this->children.end(); iter++)
   {
-    if (*iter && (*iter)->GetType() == Entity::BODY)
+    if (*iter && (*iter)->HasType(BODY))
     {
       body = (Body*)*iter;
       body->SetEnabled(true);
@@ -679,11 +699,11 @@
 void Model::SetAngularVel( const Vector3 &vel )
 {
   Body *body;
-  std::vector<Entity* >::iterator iter;
+  std::vector<Common* >::iterator iter;
 
   for (iter=this->children.begin(); iter!=this->children.end(); iter++)
   {
-    if (*iter && (*iter)->GetType() == Entity::BODY)
+    if (*iter && (*iter)->HasType(BODY))
     {
       body = (Body*)*iter;
       body->SetEnabled(true);
@@ -697,11 +717,11 @@
 void Model::SetLinearAccel( const Vector3 &accel )
 {
   Body *body;
-  std::vector<Entity* >::iterator iter;
+  std::vector<Common* >::iterator iter;
 
   for (iter=this->children.begin(); iter!=this->children.end(); iter++)
   {
-    if (*iter && (*iter)->GetType() == Entity::BODY)
+    if (*iter && (*iter)->HasType(BODY))
     {
       body = (Body*)*iter;
       body->SetEnabled(true);
@@ -715,11 +735,11 @@
 void Model::SetAngularAccel( const Vector3 &accel )
 {
   Body *body;
-  std::vector<Entity* >::iterator iter;
+  std::vector<Common* >::iterator iter;
 
   for (iter=this->children.begin(); iter!=this->children.end(); iter++)
   {
-    if (*iter && (*iter)->GetType() == Entity::BODY)
+    if (*iter && (*iter)->HasType(BODY))
     {
       body = (Body*)*iter;
       body->SetEnabled(true);
@@ -822,14 +842,14 @@
 void Model::GetBoundingBox(Vector3 &min, Vector3 &max) const
 {
   Vector3 bbmin, bbmax;
-  std::vector<Entity* >::const_iterator iter;
+  std::vector<Common* >::const_iterator iter;
 
   min.Set(FLT_MAX, FLT_MAX, FLT_MAX);
   max.Set(-FLT_MAX, -FLT_MAX, -FLT_MAX);
 
   for (iter=this->children.begin(); iter!=this->children.end(); iter++)
   {
-    if (*iter && (*iter)->GetType() == Entity::BODY)
+    if (*iter && (*iter)->HasType(BODY))
     {
       Body *body = (Body*)*iter;
       body->GetBoundingBox(bbmin, bbmax);
@@ -848,8 +868,11 @@
 // Create and return a new body
 Body *Model::CreateBody()
 {
+  Body *body = World::Instance()->GetPhysicsEngine()->CreateBody(this);
+  this->bodies.push_back(body);
+
   // Create a new body
-  return World::Instance()->GetPhysicsEngine()->CreateBody(this);
+  return body;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -905,26 +928,9 @@
     gzthrow("Trying to load a joint with NULL XML information");
 
   Joint *joint;
-  Joint::Type jtype;
 
-  // Create a Hinge Joint
-  if (node->GetName() == "hinge")
-    jtype = Joint::HINGE;
-  else if (node->GetName() == "ball")
-    jtype = Joint::BALL;
-  else if (node->GetName() == "slider")
-    jtype = Joint::SLIDER;
-  else if (node->GetName() == "hinge2")
-    jtype = Joint::HINGE2;
-  else if (node->GetName() == "universal")
-    jtype = Joint::UNIVERSAL;
-  else
-  {
-    gzthrow("Uknown joint[" + node->GetName() + "]\n");
-  }
+  joint = World::Instance()->GetPhysicsEngine()->CreateJoint(node->GetName());
 
-  joint = World::Instance()->GetPhysicsEngine()->CreateJoint(jtype);
-
   joint->SetModel(this);
 
   // Load each joint
@@ -997,11 +1003,11 @@
 Sensor *Model::GetSensor(const std::string &name) const
 {
   Sensor *sensor = NULL;
-  std::vector< Entity* >::const_iterator biter;
+  std::vector< Common* >::const_iterator biter;
 
   for (biter=this->children.begin(); biter != this->children.end(); biter++)
   {
-    if ( *biter && (*biter)->GetType() == Entity::BODY)
+    if ( *biter && (*biter)->HasType(BODY))
     {
       Body *body = (Body*)*biter;
       if ((sensor = body->GetSensor(name)) != NULL)
@@ -1017,11 +1023,11 @@
 Geom *Model::GetGeom(const std::string &name) const
 {
   Geom *geom = NULL;
-  std::vector< Entity* >::const_iterator biter;
+  std::vector< Common* >::const_iterator biter;
 
   for (biter=this->children.begin(); biter != this->children.end(); biter++)
   {
-    if (*biter && (*biter)->GetType() == Entity::BODY)
+    if (*biter && (*biter)->HasType(BODY))
     {
       Body *body = (Body*)*biter;
       if ((geom = body->GetGeom(name)) != NULL)
@@ -1036,12 +1042,11 @@
 /// Get a body by name
 Body *Model::GetBody(const std::string &name)
 {
-  std::vector< Entity* >::const_iterator biter;
+  std::vector< Common* >::const_iterator biter;
 
   if (name == "canonical")
     return this->GetCanonicalBody();
 
-
   for (biter=this->children.begin(); biter != this->children.end(); biter++)
   {
     if ((*biter)->GetName() == name)
@@ -1078,13 +1083,13 @@
     this->myBodyNameP->Load(node);
   }
 
-  if (this->parent->GetType() == Entity::MODEL)
+  if (this->parent->HasType(MODEL))
     parentModel = (Model*)this->parent;
 
   if (parentModel == NULL)
     gzthrow("Parent cannot be NULL when attaching two models");
 
-  this->joint =World::Instance()->GetPhysicsEngine()->CreateJoint(Joint::HINGE);
+  this->joint =World::Instance()->GetPhysicsEngine()->CreateJoint("hinge");
 
   Body *myBody = this->GetBody(**(this->myBodyNameP));
   Body *pBody = parentModel->GetBody(**(this->parentBodyNameP));
@@ -1106,21 +1111,7 @@
 /// Get the canonical body. Used for connected Model heirarchies
 Body * Model::GetCanonicalBody() const
 {
-  if (!this->children.empty())
-  {
-    std::vector<Entity*>::const_iterator iter;
-    Body *body = NULL;
-    for (iter = this->children.begin(); iter != this->children.end(); iter++)
-      if ((*iter)->GetName() == **this->canonicalBodyNameP)
-      {
-        body = (Body*)(*iter);
-        break;
-      }
-
-    return body;
-  }
-
-  return NULL;
+  return this->canonicalBody;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -1128,12 +1119,12 @@
 void Model::SetGravityMode( const bool &v )
 {
   Body *body;
-  std::vector<Entity* >::iterator iter;
+  std::vector<Common* >::iterator iter;
 
   for (iter=this->children.begin(); iter!=this->children.end(); iter++)
   {
 
-    if (*iter && (*iter)->GetType() == Entity::BODY)
+    if (*iter && (*iter)->HasType(BODY))
     {
       body = (Body*)*iter;
       body->SetGravityMode( v );
@@ -1146,11 +1137,11 @@
 void Model::SetFrictionMode( const bool &v )
 {
   Body *body;
-  std::vector<Entity* >::iterator iter;
+  std::vector<Common* >::iterator iter;
 
   for (iter=this->children.begin(); iter!=this->children.end(); iter++)
   {
-    if ((*iter) && (*iter)->GetType() == Entity::BODY)
+    if ((*iter) && (*iter)->HasType(BODY))
     {
       body = (Body*)*iter;
       body->SetFrictionMode( v );
@@ -1163,11 +1154,11 @@
 void Model::SetCollideMode( const std::string &m )
 {
   Body *body;
-  std::vector<Entity* >::iterator iter;
+  std::vector<Common* >::iterator iter;
 
   for (iter=this->children.begin(); iter!=this->children.end(); iter++)
   {
-    if (*iter && (*iter)->GetType() == Entity::BODY)
+    if (*iter && (*iter)->HasType(BODY))
     {
       body = (Body*)*iter;
       body->SetCollideMode( m );
@@ -1180,11 +1171,11 @@
 void Model::SetLaserFiducialId( const int &id )
 {
   Body *body;
-  std::vector<Entity* >::iterator iter;
+  std::vector<Common* >::iterator iter;
 
   for (iter=this->children.begin(); iter!=this->children.end(); iter++)
   {
-    if (*iter && (*iter)->GetType() == Entity::BODY)
+    if (*iter && (*iter)->HasType(BODY))
     {
       body = (Body*)(*iter);
       body->SetLaserFiducialId( id );
@@ -1207,11 +1198,11 @@
 {
   Body *body;
 
-  std::vector<Entity* >::iterator iter;
+  std::vector<Common* >::iterator iter;
 
   for (iter=this->children.begin(); iter!=this->children.end(); iter++)
   {
-    if (*iter && (*iter)->GetType() == Entity::BODY)
+    if (*iter && (*iter)->HasType(BODY))
     {
       body = (Body*)*iter;
       body->SetLaserRetro( retro );
@@ -1231,11 +1222,12 @@
   char lightNumBuf[8];
   sprintf(lightNumBuf, "%d", lightNumber++);
   body->SetName(this->GetName() + "_RenderableBody_" + lightNumBuf);
+  body->SetEnabled( false );
 
   if (Simulator::Instance()->GetRenderEngineEnabled() && 
       (childNode = node->GetChild("light")))
   {
-    this->light = OgreCreator::Instance()->CreateLight(body);
+    this->light = new Light(body, 0);
     this->light->Load(childNode);
   }
 
@@ -1289,7 +1281,7 @@
 /// e.g "pioneer2dx_model1::laser::laser_iface0->laser"
 void Model::GetModelInterfaceNames(std::vector<std::string>& list) const
 {
-  std::vector< Entity* >::const_iterator biter;
+  std::vector< Common* >::const_iterator biter;
   std::map<std::string, Controller* >::const_iterator contIter;
 
   for (contIter=this->controllers.begin();
@@ -1301,7 +1293,7 @@
 
   for (biter=this->children.begin(); biter != this->children.end(); biter++)
   {
-    if (*biter && (*biter)->GetType() == Entity::BODY)
+    if (*biter && (*biter)->HasType(BODY))
     {
       const Body *body = (Body*)*biter;
       body->GetInterfaceNames(list);
@@ -1322,3 +1314,40 @@
   else 
     return Pose3d();
 }
+
+////////////////////////////////////////////////////////////////////////////////
+/// Add an occurance of a contact to this geom
+void Model::StoreContact(const Geom *geom, const Contact &contact)
+{
+  this->contacts[geom->GetName()].push_back( contact.Clone() );
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Get the number of contacts for a geom
+unsigned int Model::GetContactCount(const Geom *geom) const
+{
+  std::map<std::string, std::vector<Contact> >::const_iterator iter;
+  iter = this->contacts.find( geom->GetName() );
+
+  if (iter != this->contacts.end())
+    return iter->second.size();
+  else
+    gzerr(0) << "Invalid contact index\n";
+
+  return 0;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Retreive a contact
+Contact Model::RetrieveContact(const Geom *geom, unsigned int i) const
+{
+  std::map<std::string, std::vector<Contact> >::const_iterator iter;
+  iter = this->contacts.find( geom->GetName() );
+
+  if (iter != this->contacts.end() && i < iter->second.size())
+    return iter->second[i];
+  else
+    gzerr(0) << "Invalid contact index\n";
+
+  return Contact();
+}
Index: server/audio_video/CMakeLists.txt
===================================================================
--- server/audio_video/CMakeLists.txt	(revision 8976)
+++ server/audio_video/CMakeLists.txt	(working copy)
@@ -27,9 +27,9 @@
 
 
 #TARGET_LINK_LIBRARIES(gazebo_av ${OAL_LIBRARIES} ${AVC_LIBRARIES} ${AVF_LIBRARIES})
-TARGET_LINK_LIBRARIES(gazebo_av-shared ${OAL_LIBRARIES} ${AVC_LIBRARIES} ${AVF_LIBRARIES})
+target_link_libraries(gazebo_av-shared ${OAL_LIBRARIES} ${AVC_LIBRARIES} ${AVF_LIBRARIES} profiler)
 
 #SET_TARGET_PROPERTIES(gazebo_av PROPERTIES OUTPUT_NAME "gazebo_av")
-SET_TARGET_PROPERTIES(gazebo_av-shared PROPERTIES OUTPUT_NAME "gazebo_av" VERSION ${GAZEBO_VERSION})
+set_target_properties(gazebo_av-shared PROPERTIES OUTPUT_NAME "gazebo_av" VERSION ${GAZEBO_VERSION})
 
 INSTALL (TARGETS gazebo_av-shared DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)
Index: server/World.cc
===================================================================
--- server/World.cc	(revision 8976)
+++ server/World.cc	(working copy)
@@ -29,10 +29,15 @@
 #include <fstream>
 #include <sys/time.h> //gettimeofday
 
+#include <tbb/parallel_for.h>
+#include <tbb/blocked_range.h>
+
+#include "Events.hh"
 #include "OgreVisual.hh"
 #include "Body.hh"
 #include "Factory.hh"
 #include "GraphicsIfaceHandler.hh"
+#include "SimulationIfaceHandler.hh"
 #include "Global.hh"
 #include "GazeboError.hh"
 #include "GazeboMessage.hh"
@@ -52,11 +57,27 @@
 
 using namespace gazebo;
 
+class ModelUpdate_TBB
+{
+  public: ModelUpdate_TBB(std::vector<Model*> *models) : models(models) {}
+
+  public: void operator() (const tbb::blocked_range<size_t> &r) const
+  {
+    for (size_t i=r.begin(); i != r.end(); i++)
+    {
+      (*models)[i]->Update();
+    }
+  }
+
+  private: std::vector<Model*> *models;
+};
+
 ////////////////////////////////////////////////////////////////////////////////
 // Private constructor
 World::World()
 {
   this->server = NULL;
+/*
   this->simIface = NULL;
   this->showBoundingBoxes = false;
   this->showJoints = false;
@@ -66,9 +87,10 @@
   this->showCameras = false;
   this->wireframe = false;
   this->showPhysics = false;
+*/
   this->physicsEngine = NULL;
-  this->server = NULL;
   this->graphics = NULL;
+  this->simIfaceHandler = NULL;
   this->openAL = NULL;
   this->selectedEntity = NULL;
 
@@ -80,6 +102,9 @@
   this->saveStateTimeoutP = new ParamT<Time>("saveStateResolution",0.1,0);
   this->saveStateBufferSizeP = new ParamT<unsigned int>("saveStateBufferSize",1000,0);
   Param::End();
+
+  Events::ConnectSetSelectedEntitySignal( boost::bind(&World::SetSelectedEntityCB, this, _1) );
+  Events::ConnectDeleteEntitySignal( boost::bind(&World::DeleteEntityCB, this, _1) );
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -104,6 +129,7 @@
       (*iter) = NULL;
     }
   }
+  this->models.clear();
 
   if (this->physicsEngine)
   {
@@ -111,31 +137,34 @@
     this->physicsEngine = NULL;
   }
 
-  if (this->server)
-  {
-    delete this->server;
-    this->server =NULL;
-  }
-
   try
   {
-    if (this->simIface)
+    if (this->simIfaceHandler)
     {
-      delete this->simIface;
-      this->simIface = NULL;
+      delete this->simIfaceHandler;
+      this->simIfaceHandler = NULL;
     }
+
+    if (this->graphics)
+      delete this->graphics;
+    this->graphics = NULL;
+
+    if (this->factory)
+      delete this->factory;
+    this->factory = NULL;
   }
   catch (std::string e)
   {
     gzthrow(e);
   }
 
-  if (this->factory)
+  if (this->server)
   {
-    delete this->factory;
-    this->factory = NULL;
+    delete this->server;
+    this->server =NULL;
   }
 
+  /*
   if (this->saveStateTimeoutP)
     delete this->saveStateTimeoutP;
   this->saveStateTimeoutP = NULL;
@@ -147,13 +176,7 @@
   if (this->threadsP)
     delete this->threadsP;
   this->threadsP = NULL;
-
-#ifdef USE_THREADPOOL
-  if (this->threadPool)
-    delete this->threadPool;
-  this->threadPool = NULL;
-#endif
-
+  */
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -162,24 +185,29 @@
 {
   Simulator::Instance()->ConnectPauseSignal( 
       boost::bind(&World::PauseSlot, this, _1) );
-  
+ 
   // Create the server object (needs to be done before models initialize)
-  this->server = new libgazebo::Server();
-
-  try
+  if (this->server == NULL)
   {
-    this->server->Init(serverId, true );
+    this->server = new libgazebo::Server();
+
+    try
+    {
+      this->server->Init(serverId, true );
+    }
+    catch ( std::string err)
+    {
+      gzthrow (err);
+    }
   }
-  catch ( std::string err)
-  {
-    gzthrow (err);
-  }
 
   // Create the simulator interface
   try
   {
-    this->simIface = new libgazebo::SimulationIface();
-    this->simIface->Create(this->server, "default" );
+    if (!this->simIfaceHandler)
+    {
+      this->simIfaceHandler = new SimulationIfaceHandler();
+    }
   }
   catch (std::string err)
   {
@@ -187,10 +215,11 @@
   }
 
   // Create the default factory
-  this->factory = new Factory();
+  if (!this->factory)
+    this->factory = new Factory();
 
   // Create the graphics iface handler
-  if (Simulator::Instance()->GetRenderEngineEnabled())
+  if (!this->graphics && Simulator::Instance()->GetRenderEngineEnabled())
   {
     this->graphics = new GraphicsIfaceHandler();
     this->graphics->Load("default");
@@ -209,6 +238,12 @@
 
   if (Simulator::Instance()->GetPhysicsEnabled() && physicsNode)
   {
+    if (this->physicsEngine)
+    {
+      delete this->physicsEngine;
+      this->physicsEngine = NULL;
+    }
+
     this->physicsEngine = PhysicsFactory::NewPhysicsEngine( physicsNode->GetName());
     if (this->physicsEngine == NULL)
       gzthrow("Unable to create physics engine\n");
@@ -231,11 +266,6 @@
   this->worldStatesInsertIter = this->worldStates.begin();
   this->worldStatesEndIter = this->worldStates.begin();
   this->worldStatesCurrentIter = this->worldStatesInsertIter;
-
-#ifdef USE_THREADPOOL
-  // start a thread pool with X threads
-  this->threadPool = new boost::threadpool::pool(this->threadsP->GetValue());
-#endif
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -263,15 +293,8 @@
 // Initialize the world
 void World::Init()
 {
-#ifdef USE_THREADPOOL
-  // If calling Body::Update in threadpool
-  this->physicsEngine->InitForThread();
-#endif
-
   std::vector< Model* >::iterator miter;
 
-  this->simPauseTime = 0;
-
   // Initialize all the entities
   for (miter = this->models.begin(); miter != this->models.end(); miter++)
   {
@@ -311,51 +334,30 @@
       (*miter)->GraphicsUpdate();
     }
   }
-
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Update the world
 void World::Update()
 {
-  this->worldUpdateStartSignal();
+  Events::worldUpdateStartSignal();
 
-  if (this->simPauseTime > 0)
-  {
-    if (Simulator::Instance()->GetSimTime() >= this->simPauseTime)
-    {
-      this->simPauseTime = 0;
-      Simulator::Instance()->SetPaused(true);
+  tbb::parallel_for( tbb::blocked_range<size_t>(0, this->models.size(), 10),
+      ModelUpdate_TBB(&this->models) );
 
-      // Tell the simiface that it's okay to trigger the go ack
-      this->simIface->GoAckPost();
-    }
-    else
-    {
-      Simulator::Instance()->SetPaused(false);
-    }
-  }
 
-  {
+  /*{
     DIAGNOSTICTIMER(timer("World::Update Models",6));
 
     // Update all the models
     std::vector< Model* >::iterator miter;
     for (miter=this->models.begin(); miter!=this->models.end(); miter++)
     {
-#ifdef USE_THREADPOOL
-      this->threadPool->schedule(boost::bind(&Model::Update,(*miter)));
-#else
       (*miter)->Update();
-#endif
     }
 
-#ifdef USE_THREADPOOL
-  this->threadPool->wait();
-#endif
+  }*/
 
-  }
-
   if (!Simulator::Instance()->IsPaused() &&
        Simulator::Instance()->GetPhysicsEnabled())
   {
@@ -374,12 +376,11 @@
   /// Update all the sensors
   SensorManager::Instance()->Update();
 
-
   this->factory->Update();
 
   Logger::Instance()->Update();
 
-  this->worldUpdateEndSignal();
+  Events::worldUpdateEndSignal();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -389,7 +390,10 @@
   std::vector< Model* >::iterator miter;
 
   if (Simulator::Instance()->GetRenderEngineEnabled() && this->graphics)
+  {
     delete this->graphics;
+    this->graphics = NULL;
+  }
 
   // Finalize the models
   for (miter=this->models.begin(); miter!=this->models.end(); miter++)
@@ -403,8 +407,8 @@
   // Done with the external interface
   try
   {
-    if (this->simIface)
-      this->simIface->Destroy();
+    if (this->simIfaceHandler)
+      this->simIfaceHandler->Fini();
   }
   catch (std::string e)
   { 
@@ -426,7 +430,10 @@
   try
   {
     if (this->server)
-      this->server->Fini();
+    {
+      delete this->server;
+      this->server = NULL;
+    }
   }
   catch (std::string e)
   {
@@ -439,6 +446,35 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
+/// Remove all entities from the world
+void World::Clear()
+{
+  std::vector<Model*>::iterator iter;
+  for (iter = this->models.begin(); iter != this->models.end(); iter++)
+    Events::deleteEntitySignal((*iter)->GetCompleteScopedName());
+  this->ProcessEntitiesToDelete();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the number of parameters
+unsigned int World::GetParamCount() const
+{
+  return this->parameters.size();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get a param
+Param *World::GetParam(unsigned int index) const
+{
+  if (index < this->parameters.size())
+    return this->parameters[index];
+  else
+    gzerr(2) << "World::GetParam - Invalid param index\n";
+
+  return NULL;
+}
+
+////////////////////////////////////////////////////////////////////////////////
 // Retun the libgazebo server
 libgazebo::Server *World::GetGzServer() const
 {
@@ -466,7 +502,7 @@
     if (node->GetNSPrefix() == "model")
     {
       model = this->LoadModel(node, parent, removeDuplicate, initModel);
-      this->addEntitySignal(model);
+      Events::addEntitySignal(model->GetCompleteScopedName());
     }
   }
 
@@ -535,13 +571,13 @@
     for (miter=this->toDeleteEntities.begin();
         miter!=this->toDeleteEntities.end(); miter++)
     {
-      Entity *entity = this->GetEntityByName(*miter);
+      Common *common = Common::GetByName(*miter);
 
-      if (entity)
+      if (common)
       {
-        if (entity->GetType() == Entity::MODEL)
+        if (common->HasType(MODEL))
         {
-          Model *model = (Model*)entity;
+          Model *model = (Model*)common;
 
           model->Fini();
 
@@ -551,28 +587,26 @@
           if (newiter != this->models.end())
             this->models.erase( newiter );
         }
-        else if (entity->GetType() == Entity::BODY)
-          ((Body*)entity)->Fini();
+        else if (common->HasType(BODY))
+          ((Body*)common)->Fini();
 
-        delete (entity);
-        this->deleteEntitySignal(*miter);
+        delete (common);
       }
     }
 
     this->toDeleteEntities.clear();
   }
- 
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Delete an entity by name
-void World::DeleteEntity(const std::string &name)
+void World::DeleteEntityCB(const std::string &name)
 {
   std::vector< Model* >::iterator miter;
 
-  Entity *entity = this->GetEntityByName(name);
+  Common *common = Common::GetByName(name);
 
-  if (!entity)
+  if (!common)
     return;
 
   this->toDeleteEntities.push_back(name);
@@ -609,45 +643,30 @@
   return model;
 }
 
-////////////////////////////////////////////////////////////////////////////////
-// Get a pointer to a model based on a name
-Entity *World::GetEntityByName(const std::string &name) const
+///////////////////////////////////////////////////////////////////////////////
+/// Update the simulation iface
+void World::UpdateSimulationIface()
 {
-  std::vector< Model *>::const_iterator iter;
-  Entity *result = NULL;
-
-  for (iter = this->models.begin(); 
-       iter != this->models.end() && result == NULL; iter++)
-    result = this->GetEntityByNameHelper(name, (*iter));
-  return result;
+  this->simIfaceHandler->Update();
 }
 
-////////////////////////////////////////////////////////////////////////////////
-// Get an entity by name
-Entity *World::GetEntityByNameHelper(const std::string &name, Entity *parent) const
+///////////////////////////////////////////////////////////////////////////////
+/// Get the number of models
+unsigned int World::GetModelCount() const
 {
-  if (!parent)
-    return NULL;
-
-  if (parent->GetCompleteScopedName() == name)
-    return parent;
-
-  const std::vector<Entity*> children = parent->GetChildren();
-  std::vector< Entity* >::const_iterator iter;
-
-  Entity *result = NULL;
-
-  for (iter = children.begin(); iter != children.end() && result ==NULL; iter++)
-    result = this->GetEntityByNameHelper(name, *iter);
-
-  return result;
+  return this->models.size();
 }
 
-////////////////////////////////////////////////////////////////////////////////
-///  Get an iterator over the models
-const std::vector<Model*> &World::GetModels() const
+///////////////////////////////////////////////////////////////////////////////
+/// Get a model based on an index
+Model *World::GetModel(unsigned int index)
 {
-  return this->models;
+  if (index < this->models.size())
+    return this->models[index];
+  else
+    gzerr(2) << "Invalid model index\n";
+
+  return NULL;
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -663,1035 +682,6 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// True if the bounding boxes of the models are being shown
-bool World::GetShowBoundingBoxes()
-{
-  return this->showBoundingBoxes;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Set if the bounding boxes are shown or no
-void World::SetShowBoundingBoxes(bool show)
-{
-  this->showBoundingBoxes = show;
-  this->showBoundingBoxesSignal(this->showBoundingBoxes);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get wheter to show the joints
-bool World::GetShowJoints()
-{
-  return this->showJoints;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Set whether to show the joints
-void World::SetShowJoints(bool show)
-{
-  this->showJoints = show;
-  this->showJointsSignal(show);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Set whether to show the joints
-void World::SetShowContacts(bool show)
-{
-  this->showContacts = show;
-  this->showContactsSignal(this->showContacts);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get whether to show the joints
-bool World::GetShowContacts() const
-{
-  return this->showContacts;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Set whether to show the light source visuals
-void World::SetShowLights(bool show)
-{
-  this->showLights = show;
-  this->showLightsSignal(this->showLights);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get whether to show the light source visuals
-bool World::GetShowLights() const
-{
-  return this->showLights;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Set whether to show the camera visuals
-void World::SetShowCameras(bool show)
-{
-  this->showCameras = show;
-  this->showCamerasSignal(this->showCameras);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get whether to show the camera visuals
-bool World::GetShowCameras() const
-{
-  return this->showCameras;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Set to view as wireframe
-void World::SetWireframe( bool wire )
-{
-  this->wireframe = wire;
-  this->wireframeSignal(this->wireframe);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get whether to view as wireframe
-bool World::GetWireframe()
-{
-  return this->wireframe;
-}
-
-
-////////////////////////////////////////////////////////////////////////////////
-/// Get wheter to show the joints
-bool World::GetShowPhysics()
-{
-  return this->showPhysics;
-}
-
-////////////////////////////////////////////////////////////////////////////////
-/// Set whether to show the joints
-void World::SetShowPhysics(bool show)
-{
-  this->showPhysics = show;
-  this->showPhysicsSignal(this->showPhysics);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Update the simulation interface
-void World::UpdateSimulationIface()
-{
-  libgazebo::SimulationRequestData *response = NULL;
-
-  //TODO: Move this method to simulator? Hard because of the models
-  this->simIface->Lock(1);
-
-  /* This call releases our lock, which can lead to hard-to-track-down
-   * synchronization bugs.  Besides, it's a small optimization at best
-  if (this->simIface->GetOpenCount() <= 0)
-  {
-    this->simIface->Unlock();
-    return;
-  }
-  */
-
-  response = this->simIface->data->responses;
-
-  this->simIface->data->simTime = Simulator::Instance()->GetSimTime().Double();
-  this->simIface->data->pauseTime = Simulator::Instance()->GetPauseTime().Double();
-  this->simIface->data->realTime = Simulator::Instance()->GetRealTime().Double();
-  this->simIface->data->stepTime = this->physicsEngine->GetStepTime().Double();
-  this->simIface->data->state = !Simulator::Instance()->IsPaused();
-
-  unsigned int requestCount = this->simIface->data->requestCount;
-
-  // Make sure the request count is valid
-  if (this->simIface->data->requestCount > GAZEBO_SIMULATION_MAX_REQUESTS)
-  {
-    gzerr(0) << "Request count[" << this->simIface->data->requestCount << "] greater than max allowable[" << GAZEBO_SIMULATION_MAX_REQUESTS << "]\n";
-
-    requestCount = GAZEBO_SIMULATION_MAX_REQUESTS;
-  }
-
-  // Process all the requests
-  for (unsigned int i=0; i < requestCount; i++)
-  {
-    libgazebo::SimulationRequestData *req = &(this->simIface->data->requests[i]);
-
-    switch (req->type)
-    {
-      case libgazebo::SimulationRequestData::UNPAUSE: 
-        Simulator::Instance()->SetPaused(false);
-        break;
-      case libgazebo::SimulationRequestData::PAUSE: 
-        Simulator::Instance()->SetPaused(
-            !Simulator::Instance()->IsPaused());
-        break;
-
-      case libgazebo::SimulationRequestData::STEP: 
-        Simulator::Instance()->SetStepInc(true);
-        break;
-
-      case libgazebo::SimulationRequestData::RESET:
-        this->Reset();
-        break;
-
-      case libgazebo::SimulationRequestData::SAVE:
-        Simulator::Instance()->Save();
-        break;
-
-      case libgazebo::SimulationRequestData::SET_ENTITY_PARAM_VALUE:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-
-          if (ent)
-            ent->SetParam( req->strValue, req->strValue1 );
-          else
-            gzerr(0) << "Invalid entity name[" << req->name 
-                     << "] in simulation interface Set Param Request.\n";
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::APPLY_FORCE:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-
-          if (ent && ent->GetType() == Entity::BODY)
-          {
-            Body *body = (Body*)(ent);
-
-            Vector3 force(req->vec3Value.x, req->vec3Value.y, req->vec3Value.z);
-
-            body->SetForce(force);
-          }
-          else
-          {
-            gzerr(0) << "Invalid body name[" << req->name 
-              << "] in simulation interface Set Force Request.\n";
-          }
-          break;
-
-        }
-
-      case libgazebo::SimulationRequestData::APPLY_TORQUE:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-
-          if (ent && ent->GetType() == Entity::BODY)
-          {
-            Body *body = (Body*)(ent);
-
-            Vector3 torque(req->vec3Value.x,req->vec3Value.y, req->vec3Value.z);
-
-            body->SetTorque(torque);
-          }
-          else
-          {
-            gzerr(0) << "Invalid body name[" << req->name 
-              << "] in simulation interface Set Torque Request.\n";
-          }
-          break;
-
-        }
-      case libgazebo::SimulationRequestData::SET_LINEAR_VEL:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-
-          if (ent && ent->GetType() == Entity::MODEL)
-          {
-            Model *model = (Model*)(ent);
-
-            Vector3 linearVel( req->modelLinearVel.x, req->modelLinearVel.y,
-                               req->modelLinearVel.z);
-
-            Pose3d pose = model->GetWorldPose();
-            linearVel = pose.rot.RotateVector(linearVel);
-            model->SetLinearVel(linearVel);
-          }
-          else
-          {
-            gzerr(0) << "Invalid model name[" << req->name 
-              << "] in simulation interface Set Linear Vel Request.\n";
-          }
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::SET_ANGULAR_VEL:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-
-          if (ent && (ent->GetType() == Entity::MODEL || 
-              ent->GetType() == Entity::BODY))
-          {
-
-            Vector3 vel( req->modelAngularVel.x, req->modelAngularVel.y,
-                         req->modelAngularVel.z);
-
-            Pose3d pose = ent->GetWorldPose();
-            vel = pose.rot.RotateVector(vel);
-
-            if (ent->GetType()==Entity::MODEL)
-              ((Model*)ent)->SetAngularVel(vel);
-            else if (ent->GetType() == Entity::BODY)
-              ((Body*)ent)->SetAngularVel(vel);
-
-          }
-          else
-          {
-            gzerr(0) << "Invalid model name[" << req->name 
-              << "] in simulation interface Set Angular Vel Request.\n";
-          }
-          break;
-        }
-
- 
-      case libgazebo::SimulationRequestData::SET_LINEAR_ACCEL:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-
-          if (ent && ent->GetType() == Entity::MODEL)
-          {
-            Model *model = (Model*)ent;
-
-            Vector3 accel( req->modelLinearAccel.x, req->modelLinearAccel.y,
-                               req->modelLinearAccel.z);
-
-            Pose3d pose = model->GetWorldPose();
-            accel = pose.rot.RotateVector(accel);
-            model->SetLinearAccel(accel);
-          }
-          else
-          {
-            gzerr(0) << "Invalid model name[" << req->name 
-              << "] in simulation interface Set Linear Accel Request.\n";
-          }
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::SET_ANGULAR_ACCEL:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-
-          if (ent && ent->GetType() == Entity::MODEL)
-          {
-            Model *model = (Model*)ent;
-            Vector3 accel( req->modelAngularAccel.x, req->modelAngularAccel.y,
-                               req->modelAngularAccel.z);
-
-            Pose3d pose = model->GetWorldPose();
-            accel = pose.rot.RotateVector(accel);
-            model->SetAngularAccel(accel);
-          }
-          else
-          {
-            gzerr(0) << "Invalid model name[" << req->name 
-              << "] in simulation interface Set Linear Accel Request.\n";
-          }
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::SET_STATE:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-
-          if (ent && ent->GetType() == Entity::MODEL)
-          {
-            Model *model = (Model*)ent;
-
-            Pose3d pose;
-            Vector3 linearVel( req->modelLinearVel.x,
-                               req->modelLinearVel.y,
-                               req->modelLinearVel.z);
-            Vector3 angularVel( req->modelAngularVel.x,
-                                req->modelAngularVel.y,
-                                req->modelAngularVel.z);
-            Vector3 linearAccel( req->modelLinearAccel.x,
-                                 req->modelLinearAccel.y,
-                                 req->modelLinearAccel.z);
-            Vector3 angularAccel( req->modelAngularAccel.x,
-                                  req->modelAngularAccel.y,
-                                  req->modelAngularAccel.z);
-
-
-            pose.pos.x = req->modelPose.pos.x;
-            pose.pos.y = req->modelPose.pos.y;
-            pose.pos.z = req->modelPose.pos.z;
-
-            // The the model's pose
-            pose.rot.SetFromEuler(
-                Vector3(
-                  req->modelPose.roll, 
-                  req->modelPose.pitch,
-                  req->modelPose.yaw));
-            model->SetWorldPose(pose);
-
-            linearVel = pose.rot.RotateVector(linearVel);
-            angularVel = pose.rot.RotateVector(angularVel);
-
-            linearAccel = pose.rot.RotateVector(linearAccel);
-            angularAccel = pose.rot.RotateVector(angularAccel);
-
-            // Set the model's linear and angular velocity
-            model->SetLinearVel(linearVel);
-            model->SetAngularVel(angularVel);
-
-            // Set the model's linear and angular acceleration
-            model->SetLinearAccel(linearAccel);
-            model->SetAngularAccel(angularAccel);
-          }
-          else
-          {
-            gzerr(0) << "Invalid model name[" << req->name 
-                     << "] in simulation interface Set State Request.\n";
-          }
-          break;
-        }
-      case libgazebo::SimulationRequestData::SET_POSE3D:
-        {
-          Pose3d pose;
-          Entity *ent = this->GetEntityByName((char*)req->name);
-
-          if (ent && ent->GetType() == Entity::MODEL)
-          {
-            Model *model = (Model*)(ent);
-            pose.pos.x = req->modelPose.pos.x;
-            pose.pos.y = req->modelPose.pos.y;
-            pose.pos.z = req->modelPose.pos.z;
-
-            pose.rot.SetFromEuler(
-                Vector3(req->modelPose.roll, 
-                  req->modelPose.pitch,
-                  req->modelPose.yaw));
-            model->SetWorldPose(pose);
-          }
-          else
-          {
-            gzerr(0) << "Invalid model name[" << req->name << "] in simulation interface Set Pose 3d Request.\n";
-          }
-
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::GET_NUM_MODELS:
-        {
-          response->type= req->type;
-          response->uintValue = this->models.size();
-          response++;
-          this->simIface->data->responseCount += 1;
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::GET_NUM_CHILDREN:
-        {
-          Entity *entity = this->GetEntityByName((char*)req->name);
-
-          if (entity)
-          {
-            response->type= req->type;
-            response->uintValue = entity->GetChildren().size();
-            response++;
-            this->simIface->data->responseCount += 1;
-          }
-          else
-            gzerr(0) << "Invalid entity name[" << req->name << "] in simulation interface Get Num Children.\n";
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::GET_ENTITY_PARAM_KEY:
-        {
-          Entity *entity = this->GetEntityByName((char*)req->name);
-          if (entity)
-          {
-            Param *param = entity->GetParam(req->uintValue);
-            response->type= req->type;
-            memset(response->strValue, 0, 512);
-
-            if (param)
-              strncpy(response->strValue, param->GetKey().c_str(), 512);
-
-            response->strValue[511] = '\0';
-
-            response++;
-            this->simIface->data->responseCount += 1;
-          }
-          else
-            gzerr(0) << "Invalid entity name[" << req->name << "] in simulation interface GET_ENTITY_PARAM.\n";
-
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::GET_ENTITY_PARAM_VALUE:
-        {
-          Entity *entity = this->GetEntityByName((char*)req->name);
-          if (entity)
-          {
-            Param *param = entity->GetParam(req->uintValue);
-            response->type= req->type;
-            memset(response->strValue, 0, 512);
-
-            if (param)
-              strncpy(response->strValue, param->GetAsString().c_str(), 512);
-
-            response->strValue[511] = '\0';
-            response++;
-            this->simIface->data->responseCount += 1;
-          }
-          else
-            gzerr(0) << "Invalid entity name[" << req->name << "] in simulation interface GET_ENTITY_PARAM.\n";
-
-          break;
-        }
-
-
-
-      case libgazebo::SimulationRequestData::GET_ENTITY_PARAM_COUNT:
-        {
-          Entity *entity = this->GetEntityByName((char*)req->name);
-          if (entity)
-          {
-            unsigned int count = entity->GetParamCount();
-            response->type= req->type;
-            response->uintValue = count;
-            response++;
-            this->simIface->data->responseCount += 1;
-          }
-          else
-            gzerr(0) << "Invalid entity name[" << req->name << "] in simulation interface GET_ENTITY_PARAM_COUNT.\n";
-
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::GET_MODEL_NAME:
-        {
-          unsigned int index = req->uintValue;
-
-          if (index < this->models.size())
-          {
-            Model *model = this->models[index];
-            memset(response->name, 0, 512);
-
-            strncpy(response->name, model->GetCompleteScopedName().c_str(), 512);
-            response->strValue[511] = '\0';
-
-            response++;
-            this->simIface->data->responseCount += 1;
-          }
-          else
-            gzerr(0) << "Invalid model name[" << req->name << "] in simulation interface Get Model Name.\n";
-
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::GET_CHILD_NAME:
-        {
-          Entity *entity = this->GetEntityByName((char*)req->name);
-
-          if (entity)
-          {
-            Entity *child;
-            unsigned int index;
-            response->type= req->type;
-
-            index = req->uintValue;
-
-            child = entity->GetChildren()[index];
-            if (child)
-            {
-              memset(response->strValue, 0, 512);
-              strncpy(response->name, child->GetCompleteScopedName().c_str(), 512);
-              response->strValue[511] = '\0';
-
-              response++;
-              this->simIface->data->responseCount += 1;
-            }
-            else
-            gzerr(0) << "Invalid child index in simulation interface Get Child Name.\n";
-          }
-          else
-            gzerr(0) << "Invalid model name[" << req->name << "] in simulation interface Get Child Name.\n";
-
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::GET_MODEL_FIDUCIAL_ID:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-
-          if (ent && ent->GetType() == Entity::MODEL)
-          {
-            Model *model = (Model*)ent;
-            response->type = req->type;
-            response->uintValue = model->GetLaserFiducialId();
-            response++;
-            this->simIface->data->responseCount += 1;
-            break;
-          } 
-        }
-      case libgazebo::SimulationRequestData::GET_ENTITY_TYPE:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-          if (ent)
-          {
-            response->type = req->type;
-            memset(response->strValue, 0, 512);
-            if (ent->GetType() == Entity::MODEL)
-              strncpy(response->strValue, "model", 512);
-            else if (ent->GetType() == Entity::BODY)
-              strncpy(response->strValue, "body", 512);
-            else if (ent->GetType() == Entity::GEOM)
-              strncpy(response->strValue, "geom", 512);
-
-            response->strValue[511] = '\0';
-            response++;
-            this->simIface->data->responseCount += 1;
-          }
-          else
-            gzerr(0) << "Invalid entity name[" << req->name << "] in simulation interface Get Model Type.\n";
-
-          break;
-        }
-      case libgazebo::SimulationRequestData::GET_MODEL_TYPE:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-
-          if (ent && ent->GetType() == Entity::MODEL)
-          {
-            Model *model = (Model*)ent;
-
-            response->type = req->type;
-            memset(response->strValue, 0, 512);
-            strncpy(response->strValue, model->GetModelType().c_str(), 512);
-            response->strValue[511] = '\0';
-
-            response++;
-            this->simIface->data->responseCount += 1;
-          }
-          else
-            gzerr(0) << "Invalid model name[" << req->name << "] in simulation interface Get Model Type.\n";
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::GET_MODEL_EXTENT:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-          if (ent && ent->GetType() == Entity::MODEL)
-          {
-            Model *model = (Model*)ent;
-            Vector3 min, max;
-            model->GetBoundingBox(min, max);
-
-            response->type = req->type;
-            strcpy( response->name, req->name);
-            response->vec3Value.x = max.x - min.x;
-            response->vec3Value.y = max.y - min.y;
-            response->vec3Value.z = max.z - min.z;
-
-            response++;
-            this->simIface->data->responseCount += 1;
-          }
-          else
-            gzerr(0) << "Invalid model name[" << req->name << "] in simulation interface Get Model Extent.\n";
-
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::GET_STATE:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-          if (ent)// && ent->GetType() == Entity::MODEL)
-          {
-            Pose3d pose;
-            Vector3 linearVel;
-            Vector3 angularVel;
-            Vector3 linearAccel;
-            Vector3 angularAccel;
-
-            pose = ent->GetWorldPose();
-
-            // Get the model's linear and angular velocity
-            linearVel = ent->GetWorldLinearVel();
-            angularVel = ent->GetWorldAngularVel();
-
-            // Get the model's linear and angular acceleration
-            linearAccel = ent->GetWorldLinearAccel();
-            angularAccel = ent->GetWorldAngularAccel();
-
-            response->modelPose.pos.x = pose.pos.x;
-            response->modelPose.pos.y = pose.pos.y;
-            response->modelPose.pos.z = pose.pos.z;
-
-            response->modelPose.roll = pose.rot.GetAsEuler().x;
-            response->modelPose.pitch = pose.rot.GetAsEuler().y;
-            response->modelPose.yaw = pose.rot.GetAsEuler().z;
-
-            response->modelLinearVel.x = linearVel.x;
-            response->modelLinearVel.y = linearVel.y;
-            response->modelLinearVel.z = linearVel.z;
-
-            response->modelAngularVel.x = angularVel.x;
-            response->modelAngularVel.y = angularVel.y;
-            response->modelAngularVel.z = angularVel.z;
-
-            response->modelLinearAccel.x = linearAccel.x;
-            response->modelLinearAccel.y = linearAccel.y;
-            response->modelLinearAccel.z = linearAccel.z;
-
-            response->modelAngularAccel.x = angularAccel.x;
-            response->modelAngularAccel.y = angularAccel.y;
-            response->modelAngularAccel.z = angularAccel.z;
-
-            response++;
-            this->simIface->data->responseCount += 1;
-          }
-          else
-            gzerr(0) << "Invalid model name[" << req->name << "] in simulation interface Get State Request.\n";
-          break;
-        }
- 
-      case libgazebo::SimulationRequestData::GET_POSE2D:
-      case libgazebo::SimulationRequestData::GET_POSE3D:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-          if (ent && ent->GetType() == Entity::MODEL)
-          {
-            Model *model = (Model*)ent;
-
-            Pose3d pose = model->GetWorldPose();
-            Vector3 rot = pose.rot.GetAsEuler();
-
-            response->type = req->type;
-
-            strcpy( response->name, req->name);
-            response->modelPose.pos.x = pose.pos.x;
-            response->modelPose.pos.y = pose.pos.y;
-            response->modelPose.pos.z = pose.pos.z;
-
-            response->modelPose.roll = rot.x;
-            response->modelPose.pitch = rot.y;
-            response->modelPose.yaw = rot.z;
-
-            response++;
-            this->simIface->data->responseCount += 1;
-          }
-          else
-          {
-            gzerr(0) << "Invalid model name[" << req->name << "] in simulation interface Get Pose 3d Request.\n";
-          }
-
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::GET_INTERFACE_TYPE:
-        {
-          std::vector<std::string> list;
-
-          response->type = req->type;
-          strcpy( response->name, req->name);
-          std::vector<Model*>::iterator mmiter;
-
-          for (mmiter=models.begin(); mmiter!=models.end(); mmiter++)
-            GetInterfaceNames((*mmiter), list);
-
-          std::string mname = req->name;		
-          unsigned int i=mname.find(".");        
-
-          while(i!= std::string::npos)
-          {
-            mname.erase(i,1);
-            mname.insert(i,"::");
-            i= mname.find(".");
-          }
-
-          std::vector<std::string> candids;
-
-          for(unsigned int j=0;j<list.size();j++)
-          {
-            size_t ind = list[j].find(mname);
-            if( ind==0 && ind != std::string::npos && 
-               list[j].size() > mname.size())
-            {
-              candids.push_back(list[j].substr(ind+mname.size(),
-                    list[j].size()-ind-mname.size()) );
-            }
-          }
-
-          for(i=0; i<candids.size(); i++)
-          {
-            if(candids[i][0]=='>')
-            {
-              strcpy(response->strValue,
-                     candids[i].substr(2,candids[i].size()-2).c_str());
-              response->strValue[511]='\0';
-              i=candids.size()+5;
-            }
-          }
-
-          if(strcmp(response->strValue,"irarray")==0)
-          {
-            strcpy(response->strValue,"ranger");
-            response->strValue[511]='\0';		
-          }
-
-          if(i<candids.size()+4) // the model is not an interface
-          {
-            strcpy(response->strValue,"unkown");
-            response->strValue[511]='\0';
-          }
-
-          response++;
-          this->simIface->data->responseCount += 1;
-
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::GET_MODEL_INTERFACES:
-        {
-          response->nChildInterfaces=0;
-          std::vector<std::string> list;
-
-          response->type = req->type;
-          strcpy( response->name, req->name);
-          std::vector<Model*>::iterator mmiter;
-
-
-          for (mmiter=models.begin(); mmiter!=models.end(); mmiter++)
-            GetInterfaceNames((*mmiter), list);
-
-
-          // removing the ">>type" from the end of each interface names 
-          for(unsigned int jj=0;jj<list.size();jj++){
-            unsigned int index = list[jj].find(">>");
-            if(index !=std::string::npos)
-              list[jj].replace(index,list[jj].size(),"");
-          }
-	  
-          // removing the ">>type" from the end of each interface names 
-          for(unsigned int jj=0;jj<list.size();jj++)
-          {
-            unsigned int index = list[jj].find(">>");
-            if(index !=std::string::npos)
-              list[jj].replace(index,list[jj].size(),"");
-          }
-
-          if(strcmp((char*)req->name,"")==0)
-          {
-            std::vector<std::string> chlist;
-            for(unsigned int i=0;i<list.size();i++)
-            {
-
-
-
-              std::string str = list[i].substr(0,list[i].find("::"));
-              std::vector<std::string>::iterator itr;
-              itr = std::find(chlist.begin(),chlist.end(), str);
-
-              if(itr!=chlist.end() || str=="")
-                continue;
-
-              unsigned int ii=str.find("::");        
-              while(ii!= std::string::npos){
-
-                str.erase(ii,2);
-                str.insert(ii,".");
-                ii= str.find("::");
-              }
-
-              chlist.push_back(str);
-              strcpy(response->childInterfaces[response->nChildInterfaces++],str.c_str());
-              response->childInterfaces[response->nChildInterfaces-1][511]='\0';
-
-            }
-
-          }
-          else
-          {
-            std::vector<std::string> newlist;
-            std::string mname = (char*)req->name;
-
-            size_t i=mname.find(".");        
-            while( i != std::string::npos)
-            {
-              mname.erase(i,1);
-              mname.insert(i,"::");
-              i= mname.find(".");
-            }
-
-            for(unsigned int j=0;j<list.size();j++)
-            {
-              unsigned int ind = list[j].find(mname);
-              if(ind==0 && ind!=std::string::npos && 
-                  list[j].size() > mname.size())
-              {
-                newlist.push_back(list[j].substr(ind+mname.size()+2,
-                      list[j].size()-ind-mname.size()-2));
-              }
-            }
-
-            std::vector<std::string> chlist;
-            for( i=0;i<newlist.size();i++)
-            {
-              unsigned int indx = newlist[i].find("::");
-              indx = (indx==std::string::npos)?newlist[i].size():indx;
-              std::string str = newlist[i].substr(0,indx);
-              std::vector<std::string>::iterator itr;
-              itr = std::find(chlist.begin(),chlist.end(), str);
-
-
-              if(itr!=chlist.end() || str=="")
-                continue;
-
-              chlist.push_back(str);
-              // Adding the parent name to the child name e.g "parent.child" 
-              str=mname+"."+str;
-
-              unsigned int i=str.find("::");        
-              while(i!=std::string::npos){
-                str.erase(i,2);
-                str.insert(i,".");
-                i= str.find("::");
-              }
-
-              strcpy(response->childInterfaces[response->nChildInterfaces++],
-                  str.c_str());
-              response->childInterfaces[response->nChildInterfaces-1][511]='\0';
-            }
-          }
-
-          response++;
-          this->simIface->data->responseCount += 1;
-
-          break;  
-        }
-
-     case libgazebo::SimulationRequestData::START_LOG:
-        {
-          Logger::Instance()->AddLog(req->name, req->strValue);
-          break;
-        }
-
-     case libgazebo::SimulationRequestData::STOP_LOG:
-        {
-          Logger::Instance()->RemoveLog(req->name);
-          break;
-        }
-
-     case libgazebo::SimulationRequestData::SET_STEP_TIME:
-        {
-          this->physicsEngine->SetStepTime(Time(req->dblValue));
-          break;
-        }
-
-     case libgazebo::SimulationRequestData::SET_STEP_ITERS:
-        {
-          this->physicsEngine->SetSORPGSIters(req->uintValue);
-          break;
-        }
-
-     case libgazebo::SimulationRequestData::SET_STEP_TYPE:
-        {
-          this->physicsEngine->SetStepType(req->strValue);
-          break;
-        }
-
-     case libgazebo::SimulationRequestData::GET_STEP_TYPE:
-        {
-          memset(response->strValue, 0, 512);
-          strncpy(response->strValue, this->physicsEngine->GetStepType().c_str(), 512);
-          response->strValue[511] = '\0';
-          response++;
-          this->simIface->data->responseCount += 1;
-          break;
-        }
-
-     case libgazebo::SimulationRequestData::GET_PLUGIN_COUNT:
-        {
-          response->type= req->type;
-          response->uintValue = Simulator::Instance()->GetPluginCount();
-          response++;
-          this->simIface->data->responseCount += 1;
-          break;
-        }
-
-     case libgazebo::SimulationRequestData::GET_PLUGIN_NAME:
-        {
-          memset(response->strValue, 0, 512);
-          strncpy(response->strValue, Simulator::Instance()->GetPluginName(req->uintValue).c_str(), 512);
-          response->strValue[511] = '\0';
-          response++;
-          this->simIface->data->responseCount += 1;
-          break;
-        }
-
- 
-     case libgazebo::SimulationRequestData::ADD_PLUGIN:
-        {
-          Simulator::Instance()->AddPlugin(req->strValue, req->name);
-          break;
-        }
-
-     case libgazebo::SimulationRequestData::REMOVE_PLUGIN:
-        {
-          Simulator::Instance()->RemovePlugin(req->strValue);
-          break;
-        }
-
-     case libgazebo::SimulationRequestData::GO:
-        {
-          int sec = req->runTime/1000;
-          int nsec = (req->runTime - sec*1000) * 1e6;
-
-          this->simPauseTime = Simulator::Instance()->GetSimTime() 
-                                  + Time(sec, nsec);
-
-          Simulator::Instance()->SetPaused(false);
-          break;
-        }
-
-      case libgazebo::SimulationRequestData::SET_POSE2D:
-        {
-          Entity *ent = this->GetEntityByName((char*)req->name);
-
-          if (ent && ent->GetType() == Entity::MODEL)
-          {
-            Model *model = (Model*)ent;
-
-            Pose3d pose = model->GetWorldPose();
-            Vector3 rot = pose.rot.GetAsEuler();
-
-            pose.pos.x = req->modelPose.pos.x;
-            pose.pos.y = req->modelPose.pos.y;
-
-            pose.rot.SetFromEuler(Vector3(rot.x, rot.y,
-                  req->modelPose.yaw));
-            model->SetWorldPose(pose);
-          }
-          else
-          {
-            gzerr(0) << "Invalid model name[" << req->name << "] in simulation interface Get Children Request.\n";
-          }
-          break;
-        }
-
-      default:
-        gzerr(0) << "Unknown simulation iface request[" << req->type << "]\n";
-        break;
-    }
-
-    this->simIface->data->requestCount = 0;
-  }
-
-  this->simIface->Unlock();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// Get all the interface names
-void World::GetInterfaceNames(Entity* en, std::vector<std::string>& list)
-{
-  if (!en || en->GetType() != Entity::MODEL)
-    return;
-
-	Model* m = (Model*)(en);
-
-  m->GetModelInterfaceNames(list);
-
-  const std::vector<Entity*> children = en->GetChildren();
-	std::vector<Entity*>::const_iterator citer;
-	for (citer=children.begin(); citer!=children.end(); citer++)
-		this->GetInterfaceNames((*citer),list);
-}
-
-////////////////////////////////////////////////////////////////////////////////
 // Save the state of the world
 void World::SaveState()
 {
@@ -1779,8 +769,11 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Set the selected entity
-void World::SetSelectedEntity( Entity *ent )
+void World::SetSelectedEntityCB( const std::string &name )
 {
+  Common *common = Common::GetByName(name);
+  Entity *ent = dynamic_cast<Entity*>(common);
+
   // unselect selectedEntity
   if (this->selectedEntity)
   {
@@ -1799,7 +792,7 @@
   else
     this->selectedEntity = NULL;
 
-  this->entitySelectedSignal(this->selectedEntity);
+  Events::entitySelectedSignal(this->selectedEntity);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -1819,3 +812,10 @@
     (*iter)->Print("");
   }
 }
+
+////////////////////////////////////////////////////////////////////////////////
+// Get the server id
+int World::GetServerId() const
+{
+  return this->server->serverId;
+}
Index: server/Common.cc
===================================================================
--- server/Common.cc	(revision 8976)
+++ server/Common.cc	(working copy)
@@ -25,17 +25,28 @@
  * SVN: $Id$
  */
 
+#include "World.hh"
 #include "Common.hh"
+#include "Model.hh"
 #include "GazeboMessage.hh"
+#include "GazeboError.hh"
 
 using namespace gazebo;
 
 unsigned int Common::idCounter = 0;
 
+Common *Common::root = new Common(NULL);
+
 ////////////////////////////////////////////////////////////////////////////////
 /// Constructor
-Common::Common()
+Common::Common(Common *parent)
+ : parent(parent)
 {
+  this->AddType(COMMON);
+
+  if (this->parent == NULL)
+    this->parent = this->root;
+
   this->id = ++idCounter;
 
   Param::Begin(&this->parameters);
@@ -43,12 +54,35 @@
   Param::End();
 
   this->saveable = true;
+
+  if (this->parent)
+    this->parent->AddChild(this);
+
+  this->showInGui = true;
+  this->selected = false;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 /// Destructor
 Common::~Common()
 {
+  // remove self as a child of the parent
+  if (this->parent)
+    this->parent->RemoveChild(this);
+
+  this->SetParent(NULL);
+
+  std::vector<Common*>::iterator iter;
+
+  for (iter = this->children.begin(); iter != this->children.end(); iter++)
+  {
+    if (*iter)
+    {
+      (*iter)->SetParent(NULL);
+      delete *iter;
+    }
+  }
+
   delete this->nameP;
 }
 
@@ -150,3 +184,249 @@
 {
   return this->saveable;
 }
+
+////////////////////////////////////////////////////////////////////////////////
+// Return the ID of the parent
+int Common::GetParentId() const
+{
+  return this->parent == NULL ? 0 : this->parent->GetId();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Set the parent
+void Common::SetParent(Common *parent)
+{
+  this->parent = parent;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Get the parent
+Common *Common::GetParent() const
+{
+  return this->parent;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Add a child to this entity
+void Common::AddChild(Common *child)
+{
+  if (child == NULL)
+    gzthrow("Cannot add a null child to an entity");
+
+  // Add this child to our list
+  this->children.push_back(child);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Remove a child from this entity
+void Common::RemoveChild(Common *child)
+{
+  std::vector<Common*>::iterator iter;
+  for (iter = this->children.begin(); iter != this->children.end(); iter++)
+  {
+    if ((*iter)->GetName() == child->GetName())
+    {
+      this->children.erase(iter);
+      break;
+    }
+  }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+///  Get the number of children
+unsigned int Common::GetChildCount() const
+{
+  return this->children.size();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Add a type specifier
+void Common::AddType( EntityType t )
+{
+  this->type.push_back(t);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get a child by index
+Common *Common::GetChild(unsigned int i) const
+{
+  if (i < this->children.size())
+    return this->children[i];
+  
+  return NULL;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get a child by name
+Common *Common::GetChild(const std::string &name )
+{
+  std::string fullName = this->GetCompleteScopedName() + "::" + name;
+  return this->GetByNameHelper(fullName, this);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Get an element by name
+Common *Common::GetByName(const std::string &name)
+{
+  return root->GetByNameHelper(name, root);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Get by name helper
+Common *Common::GetByNameHelper(const std::string &name, Common *parent)
+{
+  if (parent->GetCompleteScopedName() == name)
+    return parent;
+
+  Common *result = NULL;
+  std::vector<Common*>::const_iterator iter;
+
+  for (iter = parent->children.begin(); 
+       iter != parent->children.end() && result ==NULL; iter++)
+    result = GetByNameHelper(name, *iter);
+
+  return result;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Return the name of this entity with the model scope
+/// model1::...::modelN::entityName
+std::string Common::GetScopedName() const
+{
+  Common *p = this->parent;
+  std::string scopedName = this->GetName();
+
+  while (p)
+  {
+    if (p && p->HasType(MODEL))
+    {
+      Model *m = (Model*)p;
+      scopedName.insert(0, m->GetName()+"::");
+    }
+    p = p->GetParent();
+  }
+
+  return scopedName;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Return the name of this entity with the model scope
+/// model1::...::modelN::entityName
+std::string Common::GetCompleteScopedName() const
+{
+  Common *p = this->parent;
+  std::string scopedName = this->GetName();
+
+  while (p)
+  {
+    scopedName.insert(0, p->GetName()+"::");
+    p = p->GetParent();
+  }
+
+  return scopedName;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the type
+bool Common::HasType(const EntityType &t) const
+{
+  return std::binary_search(this->type.begin(), this->type.end(), t);
+
+  /*for (unsigned int i=0; i < this->type.size(); i++)
+    if (this->type[i] == t)
+      return true;
+
+  return false;
+  */
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the number of types
+unsigned int Common::GetTypeCount() const
+{
+  return this->type.size();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get a type by index
+EntityType Common::GetType(unsigned int index) const
+{
+  if (index < this->type.size())
+    return this->type[index];
+
+  gzthrow("Invalid type index");
+  return COMMON;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the leaf type (last type set)
+EntityType Common::GetLeafType() const
+{
+  return this->type.back();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+void Common::Print(std::string prefix)
+{
+  std::vector<Common*>::iterator iter;
+  std::cout << prefix << this->GetName() << "\n";
+
+  prefix += "  ";
+  for (iter = this->children.begin(); iter != this->children.end(); iter++)
+    (*iter)->Print(prefix);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// True == show parameters in the gui
+bool Common::GetShowInGui() const
+{
+  return this->showInGui;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// True == show parameters in the gui
+void Common::SetShowInGui(bool v)
+{
+  this->showInGui = v;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Set whether this entity has been selected by the user through the gui
+bool Common::SetSelected( bool s )
+{
+  std::vector< Common *>::iterator iter;
+
+  this->selected = s;
+
+  for (iter = this->children.begin(); iter != this->children.end(); iter++)
+    (*iter)->SetSelected(s);
+
+  return true;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// True if the entity is selected by the user
+bool Common::IsSelected() const
+{
+  return this->selected;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+/// Get the parent model, if one exists
+Model *Common::GetParentModel() const
+{
+  Common *p = this->parent;
+
+  while (p && p->HasType(MODEL))
+    p = p->GetParent();
+
+  return (Model*)p;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+/// Returns true if the entities are the same. Checks only the name
+bool Common::operator==(const Common &ent) const 
+{
+  return ent.GetName() == this->GetName();
+}
Index: worlds/empty.world
===================================================================
--- worlds/empty.world	(revision 8976)
+++ worlds/empty.world	(working copy)
@@ -1,5 +1,4 @@
-<?xml version="1.0"?>
-
+<?xml version="1.0"?> 
 <gazebo:world 
   xmlns:gazebo="http://playerstage.sourceforge.net/gazebo/xmlschema/#gz" 
   xmlns:model="http://playerstage.sourceforge.net/gazebo/xmlschema/#model" 
@@ -15,7 +14,7 @@
   <verbosity>4</verbosity>
 
   <physics:ode>
-    <stepTime>0.1</stepTime>
+    <stepTime>0.001</stepTime>
     <gravity>0 0 -9.8</gravity>
     <cfm>0.0000000001</cfm>
     <erp>0.2</erp>
@@ -57,18 +56,21 @@
       </geom:plane>
     </body:plane>
   </model:physical>
-
+ 
   <!-- White Point light -->
   <model:renderable name="point_white">
-    <xyz>0.0 5.0 10</xyz>
+    <xyz>0.0 0 10</xyz>
+    <rpy>0 0 0</rpy>
     <static>true</static>
     <light>
       <type>point</type>
-      <diffuseColor>0.4 0.4 0.4</diffuseColor>
-      <specularColor>.1 .1 .1</specularColor>
-      <attenuation>0.2 0.01 0.001</attenuation>
-      <range>30</range>
+      <diffuseColor>0.6 0.6 0.6 1.0</diffuseColor>
+      <specularColor>.1 .1 .1 1.0</specularColor>
+      <attenuation>.2 0.1 0.0</attenuation>
+      <range>20</range>
+      <direction>0 0 -1.0</direction>
       <castShadows>true</castShadows>
     </light>
   </model:renderable>
+
 </gazebo:world>
Index: worlds/pr2.world
===================================================================
--- worlds/pr2.world	(revision 8976)
+++ worlds/pr2.world	(working copy)
@@ -35,7 +35,7 @@
 
   <rendering:ogre>
     <ambient>.2 .2 .2 1</ambient>
-    <shadows>false</shadows>
+    <shadows>true</shadows>
     <grid>false</grid>
   </rendering:ogre>
 
Index: worlds/pioneer2dx.world
===================================================================
--- worlds/pioneer2dx.world	(revision 8976)
+++ worlds/pioneer2dx.world	(working copy)
@@ -25,7 +25,7 @@
     <erp>0.2</erp>
 
     <stepType>quick</stepType>
-    <stepIters>100</stepIters>
+    <stepIters>10</stepIters>
     <stepW>1.3</stepW>
     <contactMaxCorrectingVel>100.0</contactMaxCorrectingVel>
     <contactSurfaceLayer>0.00</contactSurfaceLayer>
Index: benchmarks/pioneer_circle_benchmark.cc
===================================================================
--- benchmarks/pioneer_circle_benchmark.cc	(revision 8976)
+++ benchmarks/pioneer_circle_benchmark.cc	(working copy)
@@ -278,9 +278,11 @@
   for (iter = step_types.begin(); iter != step_types.end(); iter++)
   {
     std::string path = std::string("/home/nate/work/simpar/data/pioneer_circle/") + *iter + "/";
-    system((std::string("mkdir -p ")+path).c_str());
+    if (system((std::string("mkdir -p ")+path).c_str()) == -1)
+      std::cerr << "Error\n";
 
 
+
     FILE *out = fopen(std::string(path+"index.txt").c_str(), "w");
     fprintf(out,"# index step_time iterations\n");
 
@@ -303,7 +305,8 @@
         RunSim(step);
 
         std::string mv_cmd = std::string("mv /tmp/pioneer.log ") + path + "pioneer_circle_benchmark_" + *iter + "_" + boost::lexical_cast<std::string>(i) + ".data";
-        system(mv_cmd.c_str());
+        if (system(mv_cmd.c_str()) == -1)
+          std::cerr << "Error\n";
       }
     }
 
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 8976)
+++ CMakeLists.txt	(working copy)
@@ -77,20 +77,30 @@
 ENDIF (NOT CMAKE_BUILD_TYPE)
 STRING(TOUPPER ${CMAKE_BUILD_TYPE} CMAKE_BUILD_TYPE)
 
-SET (build_errors "" CACHE INTERNAL "build errors" FORCE)
+set (build_errors "" CACHE INTERNAL "build errors" FORCE)
+set (build_warnings "" CACHE INTERNAL "build warnings" FORCE)
 
 MESSAGE (STATUS "\n\n====== Finding 3rd Party Packages ======")
 INCLUDE (${gazebo_cmake_dir}/SearchForStuff.cmake)
 MESSAGE (STATUS "----------------------------------------\n")
 
+if ( build_warnings )
+  message(STATUS "BUILD WARNINGS")
+  foreach (msg ${build_warnings})
+    message(STATUS ${msg})
+  endforeach (msg ${build_warnings})
+  message(STATUS "END BUILD WARNINGS\n")
+endif (build_warnings)
+
 if ( build_errors )
-  message(STATUS "!!! BUILD ERRORS !!!")
-  message(STATUS "These errors must be resolved before compiling")
+  message(STATUS "BUILD ERRORS: These must be resolved before compiling.")
   foreach (msg ${build_errors})
     message(STATUS ${msg})
   endforeach (msg ${build_errors})
-  message(STATUS "!!! END BUILD ERRORS !!!\n")
+  message(STATUS "END BUILD ERRORS\n")
 else (build_errors)
+
+
   ########################################
   # Write the config.h file
   configure_file (${PROJECT_SOURCE_DIR}/gazebo_config.h.in ${PROJECT_BINARY_DIR}/gazebo_config.h)
