diff -r 07ee66b6be0e Media/materials/programs/DepthMap.vert
--- a/Media/materials/programs/DepthMap.vert	Wed Feb 23 12:57:41 2011 -0800
+++ b/Media/materials/programs/DepthMap.vert	Mon Feb 28 16:59:16 2011 -0800
@@ -6,9 +6,11 @@
 
 void main()
 {
-	gl_Position = ftransform();
+  gl_Position = ftransform();
   gl_Position.xy += texelOffsets.zw * gl_Position.w;
 
-  //depth = gl_Position.z / (pFar - pNear);
-  depth = (gl_Position.z - pNear) / (pFar - pNear);
+  // depth = (gl_Position.z / (pFar - pNear) + pNear) * (pFar - pNear);
+  // depth = (gl_Position.z + pNear) * (pFar - gl_Position.z);
+  // depth = (gl_Position.z + pNear) * (gl_Position.z);
+  depth = gl_Position.w;
 }
diff -r 07ee66b6be0e server/rendering/OgreCamera.cc
--- a/server/rendering/OgreCamera.cc	Wed Feb 23 12:57:41 2011 -0800
+++ b/server/rendering/OgreCamera.cc	Mon Feb 28 16:59:16 2011 -0800
@@ -87,6 +87,7 @@
   Param::End();
 
   this->captureData = false;
+  this->simulateDepthData = false;
 
   this->camera = NULL;
 
@@ -387,6 +388,9 @@
       }
     }
 
+    // produce depth data for the camera
+    if (this->simulateDepthData) this->RenderDepthData();
+
     this->lastUpdate = Simulator::Instance()->GetSimTime();
   }
 
@@ -726,6 +730,12 @@
   this->name = _name;
 }
 
+//////////////////////////////////////////////////////////////////////////////
+// Simulate Depth Data
+void OgreCamera::RenderDepthData()
+{
+
+}
 
 //////////////////////////////////////////////////////////////////////////////
 // Save the current frame to disk
diff -r 07ee66b6be0e server/rendering/OgreCamera.hh
--- a/server/rendering/OgreCamera.hh	Wed Feb 23 12:57:41 2011 -0800
+++ b/server/rendering/OgreCamera.hh	Mon Feb 28 16:59:16 2011 -0800
@@ -254,6 +254,9 @@
     // Save the camera frame
     protected: virtual void SaveFrame();
 
+    // Render Depth Data
+    protected: virtual void RenderDepthData();
+
     /// \brief set update rate (render rate) of the OgreCamera
     public: void SetUpdateRate(const double &rate);
 
@@ -296,6 +299,7 @@
     protected: std::string cameraName;
 
     protected: bool captureData;
+    protected: bool simulateDepthData;
 
     private: bool userMovable;
     protected: std::vector<Param*> camParameters;
diff -r 07ee66b6be0e server/sensors/camera/StereoCameraSensor.cc
--- a/server/sensors/camera/StereoCameraSensor.cc	Wed Feb 23 12:57:41 2011 -0800
+++ b/server/sensors/camera/StereoCameraSensor.cc	Mon Feb 28 16:59:16 2011 -0800
@@ -119,22 +119,25 @@
   // Create the render textures for the color textures
   for (i = 0; i<2; i++)
   {
-    this->renderTexture[i] = this->CreateRTT(this->textureName[i], false);
-    this->renderTargets[i] = this->renderTexture[i]->getBuffer()->getRenderTarget();
+    this->renderTextures[i] = this->CreateRTT(this->textureName[i], false);
+    this->renderTargets[i] = this->renderTextures[i]->getBuffer()->getRenderTarget();
     this->renderTargets[i]->setAutoUpdated(false);
   }
 
   // Create the render texture for the depth textures
   for (i = 2; i<4; i++)
   {
-    this->renderTexture[i] = this->CreateRTT(this->textureName[i], true);
-    this->renderTargets[i] = this->renderTexture[i]->getBuffer()->getRenderTarget();
+    this->renderTextures[i] = this->CreateRTT(this->textureName[i], true);
+    this->renderTargets[i] = this->renderTextures[i]->getBuffer()->getRenderTarget();
     this->renderTargets[i]->setAutoUpdated(false);
   }
 
-    this->renderTarget = this->renderTargets[D_LEFT];
+  this->renderTarget = this->renderTargets[D_LEFT];
+  this->renderTexture = this->renderTextures[D_LEFT];
+  this->InitCam();
 
-  this->InitCam();
+  // tell OgreCamera::Render() to RenderDepthData() in the rendering thread
+  this->simulateDepthData = true;
 
   // Hack to make the camera use the right render target too.
   for (i=0; i<4; i++)
@@ -156,17 +159,21 @@
     matPtr->getTechnique(0)->getPass(0)->setDepthCheckEnabled(false);
     matPtr->getTechnique(0)->getPass(0)->setDepthWriteEnabled(false);
     matPtr->getTechnique(0)->getPass(0)->setLightingEnabled(false);
-    
+
 
     matPtr->getTechnique(0)->getPass(0)->createTextureUnitState(
         this->textureName[i] );
   }
 
   // Get pointer to the depth map material
-  this->depthMaterial = Ogre::MaterialManager::getSingleton().load("Gazebo/DepthMap", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+  //this->depthMaterial = Ogre::MaterialManager::getSingleton().load("Gazebo/DepthMap", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+  this->depthMaterial = Ogre::MaterialManager::getSingleton().getByName("Gazebo/DepthMap");
+  this->depthMaterial->load();
 
 
-  mBuffer = this->renderTexture[D_LEFT]->getBuffer(0,0);
+
+
+  mBuffer = this->renderTextures[D_LEFT]->getBuffer(0,0);
   this->textureWidth = mBuffer->getWidth();
   this->textureHeight = mBuffer->getHeight();
 
@@ -206,6 +213,12 @@
 // Update the drawing
 void StereoCameraSensor::UpdateChild()
 {
+}
+
+//////////////////////////////////////////////////////////////////////////////
+// Render Depth Data
+void StereoCameraSensor::RenderDepthData()
+{
   OgreAdaptor *adapt = OgreAdaptor::Instance();
   Ogre::RenderSystem *renderSys = adapt->root->getRenderSystem();
   Ogre::Viewport *vp = NULL;
@@ -251,9 +264,11 @@
 
     vp = this->renderTargets[i]->getViewport(0);
 
+    Ogre::CompositorManager::getSingleton().setCompositorEnabled(vp, "Gazebo/DepthMap", true);
+
     // Need this line to render the ground plane. No idea why it's necessary.
     renderSys->_setViewport(vp);
-    sceneMgr->_setPass(pass, true, false); 
+    sceneMgr->_setPass(pass, true, false);
     autoParamDataSource.setCurrentPass(pass);
     autoParamDataSource.setCurrentViewport(vp);
     autoParamDataSource.setCurrentRenderTarget(this->renderTargets[i]);
@@ -265,18 +280,18 @@
 #else
     pass->_updateAutoParams(&autoParamDataSource,1);
 #endif
-    
+
     renderSys->setLightingEnabled(false);
     renderSys->_setFog(Ogre::FOG_NONE);
-    
+
     // These two lines don't seem to do anything useful
-    renderSys->_setProjectionMatrix(this->GetOgreCamera()->getProjectionMatrixRS()); 
+    renderSys->_setProjectionMatrix(this->GetOgreCamera()->getProjectionMatrixRS());
     renderSys->_setViewMatrix(this->GetOgreCamera()->getViewMatrix(true));
 
     // NOTE: We MUST bind parameters AFTER updating the autos
     if (pass->hasVertexProgram())
     {
-      renderSys->bindGpuProgram( 
+      renderSys->bindGpuProgram(
           pass->getVertexProgram()->_getBindingDelegate() );
 
 #if OGRE_VERSION_MAJOR == 1 && OGRE_VERSION_MINOR == 6
@@ -289,23 +304,23 @@
     }
 
     if (pass->hasFragmentProgram())
-    {   
-      renderSys->bindGpuProgram( 
+    {
+      renderSys->bindGpuProgram(
           pass->getFragmentProgram()->_getBindingDelegate() );
 
 #if OGRE_VERSION_MAJOR == 1 && OGRE_VERSION_MINOR == 6
-      renderSys->bindGpuProgramParameters(Ogre::GPT_FRAGMENT_PROGRAM, 
+      renderSys->bindGpuProgramParameters(Ogre::GPT_FRAGMENT_PROGRAM,
             pass->getFragmentProgramParameters());
 #else
-        renderSys->bindGpuProgramParameters(Ogre::GPT_FRAGMENT_PROGRAM, 
+        renderSys->bindGpuProgramParameters(Ogre::GPT_FRAGMENT_PROGRAM,
             pass->getFragmentProgramParameters(), 1);
 #endif
     }
-   
+
     this->renderTargets[i]->update();
   }
 
-  sceneMgr->_suppressRenderStateChanges(false); 
+  sceneMgr->_suppressRenderStateChanges(false);
 
   // Render the image texture
   for (i=0; i<2; i++)
@@ -318,7 +333,7 @@
 
   this->FillBuffers();
 
-  if (this->saveFramesP->GetValue())
+  //if (this->saveFramesP->GetValue())
     this->SaveFrame();
 }
 
@@ -361,7 +376,7 @@
   for (i=0; i<4; i++)
   {
     // Get access to the buffer and make an image and write it to file
-    hardwareBuffer = this->renderTexture[i]->getBuffer(0, 0);
+    hardwareBuffer = this->renderTextures[i]->getBuffer(0, 0);
 
     hardwareBuffer->lock(Ogre::HardwarePixelBuffer::HBL_NORMAL);
 
@@ -444,7 +459,7 @@
     this->GetImageData(i);
 
     // Get access to the buffer and make an image and write it to file
-    mBuffer = this->renderTexture[i]->getBuffer(0, 0);
+    mBuffer = this->renderTextures[i]->getBuffer(0, 0);
 
     // Create image data structure
     imgData  = new Ogre::ImageCodec::ImageData();
@@ -564,7 +579,7 @@
 
   // Create the left render texture
   return Ogre::TextureManager::getSingleton().createManual(
-      name, 
+      name,
       Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
       Ogre::TEX_TYPE_2D,
       this->imageSizeP->GetValue().x, this->imageSizeP->GetValue().y, 0,
diff -r 07ee66b6be0e server/sensors/camera/StereoCameraSensor.hh
--- a/server/sensors/camera/StereoCameraSensor.hh	Wed Feb 23 12:57:41 2011 -0800
+++ b/server/sensors/camera/StereoCameraSensor.hh	Mon Feb 28 16:59:16 2011 -0800
@@ -99,6 +99,9 @@
     // Save the camera frame
     protected: virtual void SaveFrame();
   
+    // Render Depth Data
+    protected: virtual void RenderDepthData();
+  
     /// \brief Fill all the image buffers
     private: void FillBuffers();
   
@@ -106,7 +109,7 @@
   
     //private: void UpdateAllDependentRenderTargets();
   
-    private: Ogre::TexturePtr renderTexture[4];
+    private: Ogre::TexturePtr renderTextures[4];
     private: Ogre::RenderTarget *renderTargets[4];
     private: Ogre::MaterialPtr depthMaterial;
   
