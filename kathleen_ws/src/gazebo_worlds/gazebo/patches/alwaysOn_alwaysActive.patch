Index: server/controllers/Controller.cc
===================================================================
--- server/controllers/Controller.cc	(revision 8861)
+++ server/controllers/Controller.cc	(working copy)
@@ -45,8 +45,10 @@
 {
   Param::Begin(&this->parameters);
   this->nameP = new ParamT<std::string>("name","",1);
+  this->alwaysActiveP = new ParamT<bool>("alwaysActive", false, 0);
+  /// \brief @todo: prepare to tick tock alwaysOn --> alwaysActive
   this->alwaysOnP = new ParamT<bool>("alwaysOn", false, 0);
-  this->updatePeriodP = new ParamT<double>("updateRate", 10, 0);
+  this->updateRateP = new ParamT<double>("updateRate", 10, 0);
   Param::End();
 
   if (!dynamic_cast<Model*>(entity) && !dynamic_cast<Sensor*>(entity))
@@ -62,8 +64,10 @@
 Controller::~Controller()
 {
   delete this->nameP;
+  delete this->alwaysActiveP;
+  /// \brief @todo: prepare to tick tock alwaysOn --> alwaysActive
   delete this->alwaysOnP;
-  delete this->updatePeriodP;
+  delete this->updateRateP;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -79,11 +83,13 @@
 
   this->nameP->Load(node);
 
+  this->alwaysActiveP->Load(node);
+  /// \brief @todo: prepare to tick tock alwaysOn --> alwaysActive
   this->alwaysOnP->Load(node);
 
-  this->updatePeriodP->Load(node);
+  this->updateRateP->Load(node);
 
-  double updateRate  = this->updatePeriodP->GetValue();
+  double updateRate  = this->updateRateP->GetValue();
   if (updateRate == 0)
     this->updatePeriod = 0.0; // no throttling if updateRate is 0
   else
@@ -159,7 +165,7 @@
 
   stream << prefix << "<controller:" << this->typeName << " name=\"" << this->nameP->GetValue() << "\">\n";
 
-  stream << prefix << "  " << *(this->updatePeriodP) << "\n";
+  stream << prefix << "  " << *(this->updateRateP) << "\n";
 
   // Ouptut the interfaces
   for (iter = this->ifaces.begin(); iter != this->ifaces.end(); iter++)
@@ -185,7 +191,8 @@
 /// Update the controller. Called every cycle.
 void Controller::Update()
 {
-  if (this->IsConnected() || **this->alwaysOnP)
+  /// \brief @todo: prepare to tick tock alwaysOn --> alwaysActive
+  if (this->IsConnected() || **this->alwaysOnP || **this->alwaysActiveP)
   {
     //DiagnosticTimer timer("Controller[" + this->GetName() +"] Update Timer");
 
@@ -226,7 +233,8 @@
   std::vector<libgazebo::Iface*>::const_iterator iter;
 
   // if the alwaysOn flag is true, this controller is connected
-  if (this->alwaysOnP->GetValue())
+  /// \brief @todo: prepare to tick tock alwaysOn --> alwaysActive
+  if (this->alwaysOnP->GetValue() || this->alwaysActiveP->GetValue())
     return true;
 
   for (iter=this->ifaces.begin(); iter!=this->ifaces.end(); iter++)
Index: server/controllers/Controller.hh
===================================================================
--- server/controllers/Controller.hh	(revision 8861)
+++ server/controllers/Controller.hh	(working copy)
@@ -119,11 +119,14 @@
   protected: Entity *parent;
 
   /// \brief flag to keep controllers updating continuously
+  protected: ParamT<bool> *alwaysActiveP;
+
+  /// \brief @todo: prepare to tick tock alwaysOn --> alwaysActive
   protected: ParamT<bool> *alwaysOnP;
 
   /// \brief Update period 
   protected: double updatePeriod;
-  protected: ParamT<double> *updatePeriodP;
+  protected: ParamT<double> *updateRateP;
 
   private: std::string typeName;
 
